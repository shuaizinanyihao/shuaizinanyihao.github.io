<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IDEA远程调试</title>
    <url>/post/159c8b21.html</url>
    <content><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>在开发中每次遇到很棘手的线上环境问题，但是又不能debug调试的时候，就可以使用IDEA远程调试的方法来进行调试。</p><p>请开始您的表演~</p><a id="more"></a><h3 id="（一）IDEA配置"><a href="#（一）IDEA配置" class="headerlink" title="（一）IDEA配置"></a>（一）IDEA配置</h3><p>在idea启动栏中选择Edit Configurations,添加Remote远程连接。<br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210309134206.png" alt=""></p><h3 id="（二）远程服务器配置"><a href="#（二）远程服务器配置" class="headerlink" title="（二）远程服务器配置"></a>（二）远程服务器配置</h3><p>设置名称为：workerDebug，<br>Host：为远程要连接的服务器地址，Port：为debug时的端口号<br>在idea中配置完远程连接后，复制：<br>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8088<br>粘贴到idea的JVM信息栏目中，如下图：<br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210309134215.jpg" alt=""></p><h3 id="（三）远程服务器开启调试模式"><a href="#（三）远程服务器开启调试模式" class="headerlink" title="（三）远程服务器开启调试模式"></a>（三）远程服务器开启调试模式</h3><p>增加JVM启动参数，以支持远程调试，重新停止并启动命令:<br>java -jar -Xrunjdwp:transport=dt_socket,address=8088,suspend=y,server=y test.jar &amp;</p><h3 id="（四）如何验证是否远程调试连接成功"><a href="#（四）如何验证是否远程调试连接成功" class="headerlink" title="（四）如何验证是否远程调试连接成功"></a>（四）如何验证是否远程调试连接成功</h3><p>控制台如果出现Connected to the target VM, address: ‘10.37.141.252:8899’,transport:’socket’，<br>即说明远程连接成功可以打断点，调用接口进行调试。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>ES优化知识点总结</title>
    <url>/post/320ab92e.html</url>
    <content><![CDATA[<h3 id="（一）分片策略"><a href="#（一）分片策略" class="headerlink" title="（一）分片策略"></a>（一）分片策略</h3><h4 id="1-选择合适的分片数和副本数。"><a href="#1-选择合适的分片数和副本数。" class="headerlink" title="1.选择合适的分片数和副本数。"></a>1.选择合适的分片数和副本数。</h4><p>ES的分片分为两种，主分片（Primary Shard）和副本（Replicas）。<br>默认情况下，ES会为每个索引创建5个分片，即使是在单机环境下，这种冗余被称作过度分配（Over Allocation），目前看来这么做完全没有必要，仅在散布文档到分片和处理查询的过程中就增加了更多的复杂性，好在ES的优秀性能掩盖了这一点。假设一个索引由一个分片构成，那么当索引的大小超过单个节点的容量的时候，ES不能将索引分割成多份，因此必须在创建索引的时候就指定好需要的分片数量。此时我们所能做的就是创建一个新的索引，并在初始设定之中指定这个索引拥有更多的分片。<a id="more"></a> 反之如果过度分配，就增大了Lucene在合并分片查询结果时的复杂度，从而增大了耗时，所以我们得到了以下结论：我们应该使用最少的分片！主分片，副本和节点最大数之间数量存在以下关系：<br>节点数&lt;=主分片数*（副本数+1）</p><h4 id="2-控制分片分配行为。"><a href="#2-控制分片分配行为。" class="headerlink" title="2.控制分片分配行为。"></a>2.控制分片分配行为。</h4><p>以上是在创建每个索引的时候需要考虑的优化方法，然而在索引已创建好的前提下，是否就是没有办法从分片的角度提高了性能了呢？当然不是，首先能做的是调整分片分配器的类型，具体是在elasticsearch.yml中设置cluster.routing.allocation.type属性，共有两种分片器even_shard , balanced（默认）。even_shard是尽量保证每个节点都具有相同数量的分片，balanced是基于可控制的权重进行分配，相对于前一个分配器，它更暴漏了一些参数而引入调整分配过程的能力。每次ES的分片调整都是在ES上的数据分布发生了变化的时候进行的，最有代表性的就是有新的数据节点加入了集群的时候。当然调整分片的时机并不是由某个阈值触发的，ES内置十一个裁决者来决定是否触发分片调整，这里暂不赘述。另外，这些分配部署策略都是可以在运行时更新的。</p><h3 id="（二）路由优化"><a href="#（二）路由优化" class="headerlink" title="（二）路由优化"></a>（二）路由优化</h3><p>ES中所谓的路由和IP网络不同，是一个类似于Tag的东西。在创建文档的时候，可以通过字段为文档增加一个路由属性的Tag。ES内在机制决定了拥有相同路由属性的文档，一定会被分配到同一个分片上，无论是主分片还是副本。那么，在查询的过程中，一旦指定了感兴趣的路由属性，ES就可以直接到相应的分片所在的机器上进行搜索，而避免了复杂的分布式协同的一些工作，从而提升了ES的性能。于此同时，假设机器1上存有路由属性A的文档，机器2上存有路由属性为B的文档，那么我在查询的时候一旦指定目标路由属性为A，即使机器2故障瘫痪，对机器1构不成很大影响，所以这么做对灾况下的查询也提出了解决方案。所谓的路由，本质上是一个分桶（Bucketing）操作。当然，查询中也可以指定多个路由属性，机制大同小异。</p><h3 id="（三）ES上的GC调优"><a href="#（三）ES上的GC调优" class="headerlink" title="（三）ES上的GC调优"></a>（三）ES上的GC调优</h3><p>ElasticSearch本质上是个Java程序，所以配置JVM垃圾回收器本身也是一个很有意义的工作。我们使用JVM的Xms和Xmx参数来提供指定内存大小，本质上提供的是JVM的堆空间大小，当JVM的堆空间不足的时候就会触发致命的OutOfMemoryException。这意味着要么内存不足，要么出现了内存泄露。处理GC问题，首先要确定问题的源头，一般有三种方案：</p><ul><li>开启ElasticSearch上的GC日志</li><li>使用jstat命令</li><li>生成内存Dump</li></ul><p>第一条，在ES的配置文件elasticsearch.yml中有相关的属性可以配置。<br>第二条，jstat命令可以帮助我们查看JVM堆中各个区的使用情况和GC的耗时情况。<br>第三条，最后的办法就是将JVM的堆空间转储到文件中去，实质上是对JVM堆空间的一个快照。<br>另外，通过修改ES节点的启动参数，也可以调整GC的方式，但是实质上和上述方法是等同的。</p><h3 id="（四）避免内存交换"><a href="#（四）避免内存交换" class="headerlink" title="（四）避免内存交换"></a>（四）避免内存交换</h3><p>这一点很简单，由于操作系统的虚拟内存页交换机制，会给性能带来障碍，如数据写满内存会写入Linux中的Swap分区。可以通过在elasticsearch.yml文件中的bootstrap.mlockall设置为true来实现，但是需要管理员权限，需要修改操作系统的相关配置文件。</p><h3 id="（五）控制索引合并"><a href="#（五）控制索引合并" class="headerlink" title="（五）控制索引合并"></a>（五）控制索引合并</h3><p>ES中的分片和副本本质上都是Lucene索引，而Lucene索引又基于多个索引段构建（至少一个），索引文件中的绝大多数都是只被写一次，读多次，在Lucene内在机制控制下，当满足某种条件的时候多个索引段会被合并到一个更大的索引段，而那些旧的索引段会被抛弃并移除磁盘，这个操作叫做段合并。<br>Lucene要执行段合并的理由很简单充分：索引段粒度越小，查询性能越低且耗费的内存越多。频繁的文档更改操作会导致大量的小索引段，从而导致文件句柄打开过多的问题，如修改系统配置，增大系统允许的最大文件打开数。总的来讲，当索引段由多一个合并为一个的时候，会减少索引段的数量从而提高ES性能。对于研发者来讲，我们所能做的就是选择合适的合并策略，尽管段合并完全是Lucene的任务，但随着Lucene开放更多配置借口，新版本的ES还是提供了三种合并的策略tiered，log_byte_size，log_doc。另外，ES也提供了两种Lucene索引段合并的调度器：concurrent和serial。其中各者具体区别，这里暂不赘述，只是抛砖引玉。</p><h3 id="（六）参考文献"><a href="#（六）参考文献" class="headerlink" title="（六）参考文献"></a>（六）参考文献</h3><ol><li>​ <a href="https://my.oschina.net/yjwxh/blog/706305" target="_blank" rel="noopener">https://my.oschina.net/yjwxh/blog/706305</a></li><li>​ <a href="https://dy.163.com/article/EUI3N6EN0511Q1AF.html" target="_blank" rel="noopener">https://dy.163.com/article/EUI3N6EN0511Q1AF.html</a></li><li>​ <a href="https://my.oschina.net/u/4296857/blog/3605645" target="_blank" rel="noopener">https://my.oschina.net/u/4296857/blog/3605645</a></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>各大主流消息中间件综合对比介绍</title>
    <url>/post/8f1d9eba.html</url>
    <content><![CDATA[<p>1.ActiveMQ，性能不是很好，因此在高并发的场景下，直接被pass掉了。它的Api很完善，在中小型互联网公司可以去使用。<br>2.kafka，主要强调高性能，如果对业务需要可靠性消息的投递的时候。那么就不能够选择kafka了。但是如果做一些日志收集呢，kafka还是很好的。因为kafka的性能是十分好的。</p><a id="more"></a><p>3.RocketMQ，它的特点非常好。它高性能、满足可靠性、分布式事物、支持水平扩展、上亿级别的消息堆积、主从之间的切换等等。MQ的所有优点它基本都满足。但是它最大的缺点：商业版收费。因此它有许多功能是不对外提供的。</p><p>具体详细如下图:</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210309134939.png" alt=""></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Fiddler拦截重定向到本地服务</title>
    <url>/post/cf54cb02.html</url>
    <content><![CDATA[<blockquote><p>开发过程中，调试线上PC的web系统页面的有时候需要把线上的接口转发到本地启动的服务中的时候，可以借助Fiddler的转发功能来拦截请求到本地服务。</p></blockquote><a id="more"></a><h4 id="一、打开Fiddler配置规则"><a href="#一、打开Fiddler配置规则" class="headerlink" title="一、打开Fiddler配置规则"></a>一、打开Fiddler配置规则</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20200821094443.png" alt="Fiddler"></p><h4 id="二、编辑自动响应中的规则编辑器"><a href="#二、编辑自动响应中的规则编辑器" class="headerlink" title="二、编辑自动响应中的规则编辑器"></a>二、编辑自动响应中的规则编辑器</h4><p>添加规则：</p><ol><li>原请求（线上地址）表达式：regex:<a href="http://112.118.31.213:2191/(.*)" target="_blank" rel="noopener">http://112.118.31.213:2191/(.*)</a></li><li>响应到（本地地址）：<a href="http://127.0.0.1:8081/$1" target="_blank" rel="noopener">http://127.0.0.1:8081/$1</a></li><li>最后启用规则，重新刷新页面，发现请求已经转发到本地项目中</li></ol><h4 id="三、拦截Java程序内的请求"><a href="#三、拦截Java程序内的请求" class="headerlink" title="三、拦截Java程序内的请求"></a>三、拦截Java程序内的请求</h4><p>在IDEA启动服务的编辑栏目中，添加JVM参数来把请求代理到Fiddler如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-DproxySet=<span class="keyword">true</span> -DproxyHost=代理IP -DproxyPort=代理端口</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler</tag>
      </tags>
  </entry>
  <entry>
    <title>JmockData模拟mock数据</title>
    <url>/post/cf673b93.html</url>
    <content><![CDATA[<blockquote><p>开发面对复杂的接口数据，每次开发完成一次接口最难搞的就是写一堆的假数据来测试接口是否正常使用，然后自己去写一堆乱七八糟的数据去测试接口。我觉得是一件非常麻烦的事情，上次逛某技术平台的时候，偶尔发现一个特别好用的工具。</p></blockquote><a id="more"></a><h4 id="一、Jmockdata官网"><a href="#一、Jmockdata官网" class="headerlink" title="一、Jmockdata官网"></a>一、Jmockdata官网</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">官网 : https:&#x2F;&#x2F;github.com&#x2F;jsonzou&#x2F;jmockdata</span><br></pre></td></tr></table></figure><h4 id="二、POM依赖"><a href="#二、POM依赖" class="headerlink" title="二、POM依赖"></a>二、POM依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--  Jmockdta是一款实现模拟JAVA类型或对象的实例化并随机初始化对象的数据的工具框架。单元测试的利器。 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.jsonzou&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jmockdata&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="三、创建测试类"><a href="#三、创建测试类" class="headerlink" title="三、创建测试类"></a>三、创建测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfRefData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String string;</span><br><span class="line">    <span class="keyword">private</span> Integer integerId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="四、运行"><a href="#四、运行" class="headerlink" title="四、运行"></a>四、运行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 随机模拟假数据测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>： Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>： 2020/8/17 11:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JMockDataTest</span> </span>&#123;</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MockConfig mockConfig = <span class="keyword">new</span> MockConfig().setEnabledCircle(<span class="keyword">true</span>);</span><br><span class="line">        SelfRefData selfRefData = JMockData.mock(SelfRefData<span class="class">.<span class="keyword">class</span>, <span class="title">mockConfig</span>)</span>;</span><br><span class="line">        System.out.println(JSON.toJSONString(selfRefData));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="五、结果"><a href="#五、结果" class="headerlink" title="五、结果"></a>五、结果</h4><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="string">"59zf8i"</span>,<span class="attr">"integerId"</span>:<span class="number">9891</span>,<span class="attr">"string"</span>:<span class="string">"Z"</span>&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>丢弃掉那些BeanUtils工具类吧，MapStruct真香！！！</title>
    <url>/post/827efc3c.html</url>
    <content><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在前几天的文章《为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？》中，我曾经对几款属性拷贝的工具类进行了对比。然后在评论区有些读者反馈说MapStruct才是真的香，于是我就抽时间了解了一下MapStruct。结果我发现，这真的是一个神仙框架，炒鸡香。<br>这一篇文章就来简单介绍下MapStruct的用法，并且再和其他几个工具类进行一下对比。</p><a id="more"></a><h5 id="一、为什么需要MapStruct-？"><a href="#一、为什么需要MapStruct-？" class="headerlink" title="一、为什么需要MapStruct ？"></a>一、为什么需要MapStruct ？</h5><p>首先，我们先说一下MapStruct这类框架适用于什么样的场景，为什么市面上会有这么多的类似的框架。<br>在软件体系架构设计中，分层式结构是最常见，也是最重要的一种结构。很多人都对三层架构、四层架构等并不陌生。<br>甚至有人说：<strong>“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，如果不行，那就加两层。”</strong><br>但是，随着软件架构分层越来越多，那么各个层次之间的数据模型就要面临着相互转换的问题，典型的就是我们可以在代码中见到各种O，如DO、DTO、VO等。</p><p>一般情况下，同样一个数据模型，我们在不同的层次要使用不同的数据模型。<strong>如在数据存储层，我们使用DO来抽象一个业务实体；在业务逻辑层，我们使用DTO来表示数据传输对象；到了展示层，我们又把对象封装成VO来与前端进行交互。</strong></p><p>那么，数据的从前端透传到数据持久化层（从持久层透传到前端），就需要进行对象之间的互相转化，即在不同的对象模型之间进行映射。</p><p>通常我们可以使用get/set等方式逐一进行字段映射操作，很是麻烦，所以就是可以使用对象的拷贝工具类来代替这个繁琐的代码。</p><h5 id="二、MapStruct的使用"><a href="#二、MapStruct的使用" class="headerlink" title="二、MapStruct的使用"></a>二、MapStruct的使用</h5><p>MapStruct（<a href="https://mapstruct.org/" target="_blank" rel="noopener">https://mapstruct.org/</a> ）是一种代码生成器，它极大地简化了基于”约定优于配置”方法的Java bean类型之间映射的实现。生成的映射代码使用纯方法调用，因此快速、类型安全且易于理解。</p><blockquote><p>约定优于配置，也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量，获得简单的好处，而又不失灵活性。</p></blockquote><p>假设我们有两个类需要进行互相转换，分别是PersonDO和PersonDTO，类定义如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> Gender gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们演示下如何使用MapStruct进行bean映射。</p><p>想要使用MapStruct，首先需要依赖他的相关的jar包，使用maven依赖方式如下：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.1.Final&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.1.Final&lt;/version&gt;</span><br><span class="line">        &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>之后，我们需要定义一个做映射的接口，主要代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 需要定义一个做映射的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/17 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mappings</span>(<span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>))</span><br><span class="line">    <span class="function">PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注解@Mapper定义一个Converter接口，在其中定义一个do2dto方法，方法的入参类型是PersonDO，出参类型是PersonDTO，这个方法就用于将PersonDO转成PersonDTO。</p><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>： 测试转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>： Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>： 2020/8/17 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PersonDO personDO = <span class="keyword">new</span> PersonDO();</span><br><span class="line">        personDO.setName(<span class="string">"JIA"</span>);</span><br><span class="line">        personDO.setAge(<span class="number">21</span>);</span><br><span class="line">        personDO.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">        personDO.setId(<span class="number">8</span>);</span><br><span class="line">        PersonDTO personDTO = PersonConverter.INSTANCE.do2dto(personDO);</span><br><span class="line">        System.out.println(personDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PersonDTO(userName=JIA, age=<span class="number">21</span>, birthday=Mon Aug <span class="number">17</span> <span class="number">16</span>:<span class="number">15</span>:<span class="number">58</span> CST <span class="number">2020</span>, gender=<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p>可以看到，我们使用MapStruct完美的将PersonDO转成了PersonDTO。上面的代码可以看出，MapStruct的用法比较简单，主要依赖@Mapper注解。但是我们知道，大多数情况下，我们需要互相转换的两个类之间的属性名称、类型等并不完全一致，还有些情况我们并不想直接做映射，那么该如何处理呢？其实MapStruct在这方面也是做的很好的。</p><h5 id="三、MapStruct处理字段映射"><a href="#三、MapStruct处理字段映射" class="headerlink" title="三、MapStruct处理字段映射"></a>三、MapStruct处理字段映射</h5><p>首先，可以明确的告诉大家，如果要转换的两个类中源对象属性与目标对象属性的类型和名字一致的时候，会自动映射对应属性。</p><p>那么，如果遇到特殊情况如何处理呢？</p><ol><li><h6 id="名字不一致如何映射"><a href="#名字不一致如何映射" class="headerlink" title="名字不一致如何映射"></a>名字不一致如何映射</h6><p>如上面的例子中，在PersonDO中用name表示用户名称，而在PersonDTO中使用userName表示用户名，那么如何进行参数映射呢。这时候就要使用@Mapping注解了，只需要在方法签名上，使用该注解，并指明需要转换的源对象的名字和目标对象的名字就可以了，如将name的值映射给userName，可以使用如下方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, target = <span class="string">"userName"</span>)</span><br></pre></td></tr></table></figure></li><li><h6 id="可以自动映射的类型"><a href="#可以自动映射的类型" class="headerlink" title="可以自动映射的类型"></a>可以自动映射的类型</h6><p>除了名字不一致以外，还有一种特殊情况，那就是类型不一致，如上面的例子中，在PersonDO中用String类型表示用户性别，而在PersonDTO中使用一个Genter的枚举表示用户性别。</p><p>这时候类型不一致，就需要涉及到互相转换的问题</p><p>其实，MapStruct会对部分类型自动做映射，不需要我们做额外配置，如例子中我们将String类型自动转成了枚举类型。</p><p>一般情况下，对于以下情况可以做自动类型转换：</p><ul><li>基本类型及其他们对应的包装类型。</li><li>基本类型的包装类型和String类型之间</li><li>String类型和枚举类型之间</li></ul></li><li><h6 id="自定义常量"><a href="#自定义常量" class="headerlink" title="自定义常量"></a>自定义常量</h6><p>如果我们在转换映射过程中，想要给一些属性定义一个固定的值，这个时候可以使用 constant</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(source = <span class="string">"name"</span>, constant = <span class="string">"JIA"</span>)</span><br></pre></td></tr></table></figure></li><li><h6 id="类型不一致的如何映射"><a href="#类型不一致的如何映射" class="headerlink" title="类型不一致的如何映射"></a>类型不一致的如何映射</h6><p>还是上面的例子，如果我们需要在Person这个对象中增加家庭住址这个属性，那么我们一般在PersonoDTO中会单独定义一个HomeAddress类来表示家庭住址，而在Person类中，我们一般使用String类型表示家庭住址。这就需要在HomeAddress和String之间使用JSON进行互相转化，这种情况下，MapStruct也是可以支持的。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> HomeAddress address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"userName"</span>, target = <span class="string">"name"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"address"</span>,expression = <span class="string">"java(homeAddressToString(dto2do.getAddress()))"</span>)</span><br><span class="line">    <span class="function">PersonDO <span class="title">dto2do</span><span class="params">(PersonDTO dto2do)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">homeAddressToString</span><span class="params">(HomeAddress address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在PersonConverter中在定义一个方法（因为PersonConverter是一个接口，所以在JDK 1.8以后的版本中可以定义一个default方法），这个方法的作用就是将HomeAddress转换成String类型。</p><blockquote><p>default方法：Java 8 引入的新的语言特性，用关键字default来标注，被default所标注的方法，需要提供实现，而子类可以选择实现或者不实现该方法</p></blockquote><p>然后在dto2do方法上，通过以下注解方式即可实现类型的转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"address"</span>,expression = <span class="string">"java(homeAddressToString(dto2do.getAddress()))"</span>)</span><br></pre></td></tr></table></figure><p>上面这种是自定义的类型转换，还有一些类型的转换是MapStruct本身就支持的，如String和Date之间的转换：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br></pre></td></tr></table></figure><p>以上，简单介绍了一些常用的字段映射的方法，也是我自己在工作中经常遇到的几个场景，更多的情况大家可以查看官方的示例（<a href="https://github.com/mapstruct/mapstruct-examples）。" target="_blank" rel="noopener">https://github.com/mapstruct/mapstruct-examples）。</a></p></li></ol><h5 id="四、MapStruct的性能"><a href="#四、MapStruct的性能" class="headerlink" title="四、MapStruct的性能"></a>四、MapStruct的性能</h5><p>前面说了这么多MapStruct的用法，可以看出MapStruct的使用还是比较简单的，并且字段映射上面的功能很强大，那么他的性能到底怎么样呢？</p><p>参考《<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&mid=2650137356&idx=1&sn=c1d3f57eb9ae9b535ed41560939a13b7&chksm=f36bfe2dc41c773b9086fa01735581616c438dba1619c0e8e26d429612739155d65c6b9ca120&scene=21#wechat_redirect" target="_blank" rel="noopener">为什么阿里巴巴禁止使用Apache Beanutils进行属性的copy？</a>》中的示例，我们对MapStruct进行性能测试。</p><p>分别执行1000、10000、100000、1000000次映射的耗时分别为：0ms、1ms、3ms、6ms。</p><p>可以看到，<strong>MapStruct的耗时相比较于其他几款工具来说是非常短的</strong>。</p><p>那么，为什么MapStruct的性能可以这么好呢？</p><p>其实，MapStruct和其他几类框架最大的区别就是：<strong>与其他映射框架相比，MapStruct在编译时生成bean映射，这确保了高性能，可以提前将问题反馈出来，也使得开发人员可以彻底的错误检查。</strong></p><p>引入MapStruct的依赖的时候，并且我们在代码中使用了很多MapStruct提供的注解，这使得在编译期，MapStruct就可以直接生成bean映射的代码，相当于代替我们写了很多setter和getter。</p><p>如我们在代码中定义了以下一个Mapper：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line">    PersonConverter INSTANCE = Mappers.getMapper(PersonConverter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="meta">@Mapping</span>(source = <span class="string">"userName"</span>, target = <span class="string">"name"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"address"</span>,expression = <span class="string">"java(homeAddressToString(dto2do.getAddress()))"</span>)</span><br><span class="line">    <span class="meta">@Mapping</span>(target = <span class="string">"birthday"</span>,dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">    <span class="function">PersonDO <span class="title">dto2do</span><span class="params">(PersonDTO dto2do)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">homeAddressToString</span><span class="params">(HomeAddress address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过代码编译后，会自动生成一个PersonConverterImpl：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by Fernflower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">package</span> com.mapstruct;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonConverterImpl</span> <span class="keyword">implements</span> <span class="title">PersonConverter</span> </span>&#123;</span><br><span class="line">    PersonConverterImpl() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PersonDTO <span class="title">do2dto</span><span class="params">(PersonDO person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (person == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            PersonDTO personDTO = <span class="keyword">new</span> PersonDTO();</span><br><span class="line">            personDTO.setUserName(person.getName());</span><br><span class="line">            personDTO.setAge(person.getAge());</span><br><span class="line">            personDTO.setBirthday(person.getBirthday());</span><br><span class="line">            personDTO.setGender(person.getGender());</span><br><span class="line">            <span class="keyword">return</span> personDTO;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行期，对于bean进行映射的时候，就会直接调用PersonConverterImpl的dto2do方法，这样就没有什么特殊的事情要做了，只是在内存中进行set和get就可以了。</p><p>所以，因为在编译期做了很多事情，所以MapStruct在运行期的性能会很好，并且还有一个好处，那就是可以把问题的暴露提前到编译期。</p><p>使得如果代码中字段映射有问题，那么应用就会无法编译，强制开发者要解决这个问题才行。</p><h5 id="五、其他拷贝工具类"><a href="#五、其他拷贝工具类" class="headerlink" title="五、其他拷贝工具类"></a>五、其他拷贝工具类</h5><ul><li>DozerBeanMapper</li><li>Orika</li><li>BeanCopier</li><li>ModelMapper(Model Mapper 是通过反射的性能不是很好的，只是减少了代码set get量。性能却下降了,不建议使用在生产环境)。</li><li><a href="https://blog.csdn.net/weixin_36142042/article/details/84931600?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-4" target="_blank" rel="noopener">Bean拷贝工具类比较</a></li></ul><h5 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h5><p>本文介绍了一款Java中的字段映射工具类，MapStruct，他的用法比较简单，并且功能非常完善，可以应付各种情况的字段映射。并且因为他是编译期就会生成真正的映射代码，使得运行期的性能得到了大大的提升。</p><p>强烈推荐，真的很香！！！</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>EasyPoI自定义样式</title>
    <url>/post/ee4afaf1.html</url>
    <content><![CDATA[<h3 id="一、依赖"><a href="#一、依赖" class="headerlink" title="一、依赖"></a>一、依赖</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">              &lt;groupId&gt;cn.afterturn&lt;&#x2F;groupId&gt;</span><br><span class="line">              &lt;artifactId&gt;easypoi-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">              &lt;version&gt;4.2.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="二、添加样式实现类"><a href="#二、添加样式实现类" class="headerlink" title="二、添加样式实现类"></a>二、添加样式实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.params.ExcelExportEntity;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.params.ExcelForEachParams;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.export.styler.IExcelExportStyler;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 自定义表头样式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/8/4 11:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppExcelExportStylerImpl</span> <span class="keyword">implements</span> <span class="title">IExcelExportStyler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> STRING_FORMAT = (<span class="keyword">short</span>) BuiltinFormats.getBuiltinFormat(<span class="string">"TEXT"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> FONT_SIZE_TEN = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> FONT_SIZE_ELEVEN = <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> FONT_SIZE_TWELVE = <span class="number">12</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大标题样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CellStyle headerStyle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每列标题样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CellStyle titleStyle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据行样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> CellStyle styles;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppExcelExportStylerImpl</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.init(workbook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workbook</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.headerStyle = initHeaderStyle(workbook);</span><br><span class="line">        <span class="keyword">this</span>.titleStyle = initTitleStyle(workbook);</span><br><span class="line">        <span class="keyword">this</span>.styles = initStyles(workbook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 大标题样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getHeaderStyle</span><span class="params">(<span class="keyword">short</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> headerStyle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每列标题样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> color</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getTitleStyle</span><span class="params">(<span class="keyword">short</span> color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> titleStyle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据行样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parity 可以用来表示奇偶行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 数据内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 样式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getStyles</span><span class="params">(<span class="keyword">boolean</span> parity, ExcelExportEntity entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> styles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取样式方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataRow 数据行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj     对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data    数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getStyles</span><span class="params">(Cell cell, <span class="keyword">int</span> dataRow, ExcelExportEntity entity, Object obj, Object    data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getStyles(<span class="keyword">true</span>, entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板使用的样式设置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CellStyle <span class="title">getTemplateStyles</span><span class="params">(<span class="keyword">boolean</span> isSingle, ExcelForEachParams excelForEachParams)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化--大标题样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workbook</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CellStyle <span class="title">initHeaderStyle</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        CellStyle style = getBaseCellStyle(workbook);</span><br><span class="line">        style.setFont(getFont(workbook, FONT_SIZE_TWELVE, <span class="keyword">true</span>));</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化--每列标题样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workbook</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CellStyle <span class="title">initTitleStyle</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        CellStyle style = getBaseCellStyle(workbook);</span><br><span class="line">        style.setFont(getFont(workbook, FONT_SIZE_ELEVEN, <span class="keyword">false</span>));</span><br><span class="line">        <span class="comment">//背景色</span></span><br><span class="line">        style.setFillForegroundColor(IndexedColors.YELLOW.getIndex());</span><br><span class="line">        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化--数据行样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workbook</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CellStyle <span class="title">initStyles</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        CellStyle style = getBaseCellStyle(workbook);</span><br><span class="line">        style.setFont(getFont(workbook, FONT_SIZE_TEN, <span class="keyword">false</span>));</span><br><span class="line">        style.setDataFormat(STRING_FORMAT);</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> CellStyle <span class="title">getBaseCellStyle</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">        CellStyle style = workbook.createCellStyle();</span><br><span class="line">        <span class="comment">//下边框</span></span><br><span class="line">        style.setBorderBottom(BorderStyle.THIN);</span><br><span class="line">        <span class="comment">//左边框</span></span><br><span class="line">        style.setBorderLeft(BorderStyle.THIN);</span><br><span class="line">        <span class="comment">//上边框</span></span><br><span class="line">        style.setBorderTop(BorderStyle.THIN);</span><br><span class="line">        <span class="comment">//右边框</span></span><br><span class="line">        style.setBorderRight(BorderStyle.THIN);</span><br><span class="line">        <span class="comment">//水平居中</span></span><br><span class="line">        style.setAlignment(HorizontalAlignment.CENTER);</span><br><span class="line">        <span class="comment">//上下居中</span></span><br><span class="line">        style.setVerticalAlignment(VerticalAlignment.CENTER);</span><br><span class="line">        <span class="comment">//设置自动换行</span></span><br><span class="line">        style.setWrapText(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字体样式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> size   字体大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isBold 是否加粗</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Font <span class="title">getFont</span><span class="params">(Workbook workbook, <span class="keyword">short</span> size, <span class="keyword">boolean</span> isBold)</span> </span>&#123;</span><br><span class="line">        Font font = workbook.createFont();</span><br><span class="line">        <span class="comment">//字体样式</span></span><br><span class="line">        font.setFontName(<span class="string">"宋体"</span>);</span><br><span class="line">        <span class="comment">//是否加粗</span></span><br><span class="line">        font.setBold(isBold);</span><br><span class="line">        <span class="comment">//字体大小</span></span><br><span class="line">        font.setFontHeightInPoints(size);</span><br><span class="line">        <span class="keyword">return</span> font;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、EasyPoi导出设置自定义样式"><a href="#三、EasyPoi导出设置自定义样式" class="headerlink" title="三、EasyPoi导出设置自定义样式"></a>三、EasyPoi导出设置自定义样式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"> ExportParams exportParams = <span class="keyword">new</span> ExportParams(<span class="string">"表头名称"</span>, <span class="string">"sheet页名称"</span>);</span><br><span class="line"><span class="comment">// 设置自定义样式类</span></span><br><span class="line">exportParams.setStyle(AppExcelExportStylerImpl<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Workbook workbook = ExcelExportUtil.exportExcel(</span><br><span class="line">                 exportParams,</span><br><span class="line">                 ExclHQContractVO<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">exclHQContractVOList</span>)</span>;</span><br><span class="line"> <span class="comment">// 下载</span></span><br><span class="line"> EasyPoiUtils.browserDownload(response, request, workbook);</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>maven本地JAR包安装</title>
    <url>/post/2221463e.html</url>
    <content><![CDATA[<h3 id="一、maven安装"><a href="#一、maven安装" class="headerlink" title="一、maven安装"></a>一、maven安装</h3><p>在需要jar的项目的根目录执行下命令：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -DgroupId&#x3D;com.baidu.boot -DartifactId&#x3D;net-base-utils -Dversion&#x3D;2.6.8 -Dfile&#x3D;C:\Users\Desktop\net-base-utils-2.6.8-SNAPSHOT.jar -Dpackaging&#x3D;jar -DgeneratePom&#x3D;true</span><br></pre></td></tr></table></figure><a id="more"></a><ol><li><p>DgroupId：是项目组织唯一的标识符，自己随便起名</p></li><li><p>DartifactId：项目的唯一的标识符，自己可以随便起</p></li><li><p>Dversion：项目版本</p></li><li><p>Dfile：jar包路径（绝对路径）</p></li><li><p>DgeneratePom：是否生成pom文件，ture:生成，false：不生成；</p><p>执行成功后，在本地maven的仓库按照DgroupId路径查找就可以了。</p></li></ol><h3 id="二、本地项目中引入"><a href="#二、本地项目中引入" class="headerlink" title="二、本地项目中引入"></a>二、本地项目中引入</h3><p>1、在项目的resource目录下新建lib文件夹，然后将你本地的jar包copy到里面；</p><p>2、在maven的配置如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.baidu.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;net-base-utils&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.6.8&lt;&#x2F;version&gt;</span><br><span class="line">			&lt;scope&gt;system&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;systemPath&gt;$&#123;project.basedir&#125;&#x2F;src&#x2F;main&#x2F;resources&#x2F;lib&#x2F;net-base-utils-2.6.8.jar&lt;&#x2F;systemPath&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure><p>3、<scope>system</scope>问题</p><p>maven 的<scope>的scope属性可以为system，然后通过system来引用，不过不推荐使用system，因为一个项目的pom.xml如果使用了scope为system的depend后，会导致传递依赖中断，即所有其他依赖本项目的项目都无法传递依赖了。</scope></p><p>比如：假设A项目依赖了m.jar, n.jar, x.jar, 然后我们把A项目打包成了a.jar, 如果此时B项目依赖了A项目，则B项目通常自然就已经默认传递依赖了m.jar, n.jar, x.jar。</p><p>但是如果A项目的pom.xml文件出现了scope为system的depend,则B项目就只能依赖a.jar, 将无法传递依赖m.jar, n.jar, x.jar；</p><h3 id="三、最终推荐使用"><a href="#三、最终推荐使用" class="headerlink" title="三、最终推荐使用"></a>三、最终推荐使用</h3><p>推荐使用第一种方法来引用外部的jar包。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Java实现6种负载均衡算法</title>
    <url>/post/31519438.html</url>
    <content><![CDATA[<h3 id="1、完全随机算法"><a href="#1、完全随机算法" class="headerlink" title="1、完全随机算法"></a>1、完全随机算法</h3><p>缺点: 所有服务器的访问概率都是相同的。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.core.random;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载均衡算法</span></span><br><span class="line"><span class="comment"> * 完全随机算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = Arrays.asList(<span class="string">"10.180.11.126:8888"</span>,<span class="string">"10.180.11.128:8888"</span>,<span class="string">"10.180.11.130:8888"</span>);</span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number = random.nextInt(list.size());</span><br><span class="line">        <span class="keyword">return</span> list.get(number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、加权随机算法"><a href="#2、加权随机算法" class="headerlink" title="2、加权随机算法"></a>2、加权随机算法</h3><p>场景：有的服务器性能高，可以让随机到此服务器的可能性增大</p><p>缺点：权重低的服务器可能很长一段时间都访问不到3</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.core.random;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载均衡算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果某一台服务器性能比较高，设置访问的权重高一点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 加权随机算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRandomServer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">"10.180.11.126:8888"</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"10.180.11.128:8888"</span>,<span class="number">7</span>);</span><br><span class="line">        map.put(<span class="string">"10.180.11.130:8888"</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当权重设置过大时，list容易被撑爆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//根据权重，决定向list中添加几次</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; entry.getValue(); i++) &#123;</span><br><span class="line"> </span><br><span class="line">                list.add(entry.getKey());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//list的大小</span></span><br><span class="line">        <span class="keyword">int</span> weight = map.values().stream().mapToInt(p -&gt; p).sum();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> number = random.nextInt(weight);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> list.get(number);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优化后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算总权值</span></span><br><span class="line">        <span class="keyword">int</span> weight = map.values().stream().mapToInt(p -&gt; p).sum();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//随机一个随机数</span></span><br><span class="line">        <span class="keyword">int</span> index = random.nextInt(weight);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//遍历  服务  map</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//如果权重大于  索引</span></span><br><span class="line">            <span class="keyword">if</span>(entry.getValue() &gt;= index) &#123;</span><br><span class="line">                <span class="comment">// 返回这个服务</span></span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，索引 = 当前索引 - 当前服务的权重</span></span><br><span class="line">            index = index - entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//System.out.println(getServer());</span></span><br><span class="line">            System.out.println(getServer1());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、完全轮询算法"><a href="#3、完全轮询算法" class="headerlink" title="3、完全轮询算法"></a>3、完全轮询算法</h3><p>缺点：从头到尾轮询一遍，不能根据服务器性能设置权重</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.core.poll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 完全轮询算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PollServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = Arrays.asList(<span class="string">"10.180.11.126:8888"</span>,<span class="string">"10.180.11.128:8888"</span>,<span class="string">"10.180.11.130:8888"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == list.size()) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(index++);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line"> </span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、加权轮询算法"><a href="#4、加权轮询算法" class="headerlink" title="4、加权轮询算法"></a>4、加权轮询算法</h3><p>优点：可以根据服务器性能设置访问权重</p><p>缺点：可能某个服务器权重大，长时间执行，遇到耗时大的请求，压力会很大</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.core.poll;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加权轮询算法</span></span><br><span class="line"><span class="comment"> * 实际中可能遇到某个服务器压力较大，长时间执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightPollServer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">"10.180.11.126:8888"</span>,<span class="number">2</span>);</span><br><span class="line">        map.put(<span class="string">"10.180.11.128:8888"</span>,<span class="number">7</span>);</span><br><span class="line">        map.put(<span class="string">"10.180.11.130:8888"</span>,<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> index;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> weight = map.values().stream().mapToInt( p -&gt; p).sum();</span><br><span class="line">        <span class="keyword">int</span> number = (index++) % weight;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(entry.getValue() &gt;= number) &#123;</span><br><span class="line">                <span class="keyword">return</span> entry.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">            number = number - entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、平滑加权轮询算法"><a href="#5、平滑加权轮询算法" class="headerlink" title="5、平滑加权轮询算法"></a>5、平滑加权轮询算法</h3><p>优点：根据权重分配服务，同时又保证权重低的服务可以被访问到</p><p>缺点：集群环境下，同一个用户访问无法分流到固定一台机器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.core.smooth;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平滑加权</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmoothWeight</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentWeight;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentWeight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentWeight</span><span class="params">(<span class="keyword">int</span> currentWeight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentWeight = currentWeight;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmoothWeight</span><span class="params">(<span class="keyword">int</span> weight, <span class="keyword">int</span> currentWeight, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.currentWeight = currentWeight;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.core.smooth;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平滑加权轮询算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmoothWeightPollServer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,SmoothWeight&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map.put(<span class="string">"10.180.11.126:8888"</span>,<span class="keyword">new</span> SmoothWeight(<span class="number">5</span>,<span class="number">5</span>,<span class="string">"10.180.11.126:8888"</span>));</span><br><span class="line">        map.put(<span class="string">"10.180.11.128:8888"</span>,<span class="keyword">new</span> SmoothWeight(<span class="number">2</span>,<span class="number">2</span>,<span class="string">"10.180.11.128:8888"</span>));</span><br><span class="line">        map.put(<span class="string">"10.180.11.130:8888"</span>,<span class="keyword">new</span> SmoothWeight(<span class="number">4</span>,<span class="number">4</span>,<span class="string">"10.180.11.130:8888"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        SmoothWeight maxSmoothWeight = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> weight = map.values().stream().mapToInt(SmoothWeight :: getWeight).sum();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,SmoothWeight&gt; entry : map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">            SmoothWeight currentSmoothWeight = entry.getValue();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(maxSmoothWeight == <span class="keyword">null</span> || currentSmoothWeight.getCurrentWeight() &gt; maxSmoothWeight.getCurrentWeight()) &#123;</span><br><span class="line">                maxSmoothWeight = currentSmoothWeight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> maxSmoothWeight != <span class="keyword">null</span>;</span><br><span class="line">        maxSmoothWeight.setCurrentWeight(maxSmoothWeight.getCurrentWeight() - weight);</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,SmoothWeight&gt; entry : map.entrySet()) &#123;</span><br><span class="line"> </span><br><span class="line">            SmoothWeight currentSmoothWeight = entry.getValue();</span><br><span class="line"> </span><br><span class="line">            currentSmoothWeight.setCurrentWeight(currentSmoothWeight.getCurrentWeight() + currentSmoothWeight.getWeight());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> maxSmoothWeight.getAddress();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、哈希负载算法"><a href="#6、哈希负载算法" class="headerlink" title="6、哈希负载算法"></a>6、哈希负载算法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.core.hash;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.SortedMap;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash负载算法</span></span><br><span class="line"><span class="comment"> * 在一个集群环境下，让同一个用户的访问，分流到固定的一台机器上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashServer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; list = Arrays.asList(<span class="string">"10.180.11.126:8888"</span>,<span class="string">"10.180.11.128:8888"</span>,<span class="string">"10.180.11.130:8888"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">(String client)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nodeCount = <span class="number">40</span>;</span><br><span class="line"> </span><br><span class="line">        TreeMap&lt;Integer,String&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(String s : list) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeCount; i++) &#123;</span><br><span class="line">                treeMap.put((s + <span class="string">"address:"</span> + i).hashCode(), s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        SortedMap&lt;Integer,String&gt; sortedMap = treeMap.tailMap(client.hashCode());</span><br><span class="line"> </span><br><span class="line">        Integer firstHash = (sortedMap.size() &gt; <span class="number">0</span>) ? sortedMap.firstKey() : treeMap.firstKey();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> treeMap.get(firstHash);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getServer(<span class="string">"用户："</span> + i + <span class="string">"访问"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>为什么我们做分布式使用Redis</title>
    <url>/post/f7431ca1.html</url>
    <content><![CDATA[<p>绝大部分写业务的程序员，在实际开发中使用 Redis 的时候，只会 Set Value 和 Get Value 两个操作，对 Redis 整体缺乏一个认知。这里对 Redis 常见问题做一个总结，解决大家的知识盲点。</p><h2 id="1、为什么使用-Redis"><a href="#1、为什么使用-Redis" class="headerlink" title="1、为什么使用 Redis"></a>1、为什么使用 Redis</h2><p>在项目中使用 Redis，主要考虑两个角度：性能和并发。如果只是为了分布式锁这些其他功能，还有其他中间件 Zookpeer 等代替，并非一定要使用 Redis。</p><a id="more"></a><h3 id="性能："><a href="#性能：" class="headerlink" title="性能："></a>性能：</h3><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的 SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。</p><p>特别是在秒杀系统，在同一时间，几乎所有人都在点，都在下单。。。执行的是同一操作———向数据库查数据。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20200814112433.png" alt=""></p><p>根据交互效果的不同，响应时间没有固定标准。在理想状态下，我们的页面跳转需要在瞬间解决，对于页内操作则需要在刹那间解决。</p><h3 id="并发："><a href="#并发：" class="headerlink" title="并发："></a>并发：</h3><p>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用 Redis 做一个缓冲操作，让请求先访问到 Redis，而不是直接访问数据库。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20200814112445.png" alt=""></p><h3 id="使用-Redis-的常见问题"><a href="#使用-Redis-的常见问题" class="headerlink" title="使用 Redis 的常见问题"></a>使用 Redis 的常见问题</h3><ul><li><p>缓存和数据库双写一致性问题</p></li><li><p>缓存雪崩问题</p></li><li><p>缓存击穿问题</p></li><li><p>缓存的并发竞争问题</p></li></ul><h2 id="2、单线程的-Redis-为什么这么快"><a href="#2、单线程的-Redis-为什么这么快" class="headerlink" title="2、单线程的 Redis 为什么这么快"></a>2、单线程的 Redis 为什么这么快</h2><p>这个问题是对 Redis 内部机制的一个考察。很多人都不知道 Redis 是单线程工作模型。</p><h3 id="原因主要是以下三点："><a href="#原因主要是以下三点：" class="headerlink" title="原因主要是以下三点："></a>原因主要是以下三点：</h3><p>纯内存操作</p><p>单线程操作，避免了频繁的上下文切换</p><p>采用了非阻塞 I/O 多路复用机制</p><p>仔细说一说 I/O 多路复用机制，打一个比方：小名在 A 城开了一家快餐店店，负责同城快餐服务。小明因为资金限制，雇佣了一批配送员，然后小曲发现资金不够了，只够买一辆车送快递。</p><h3 id="经营方式一"><a href="#经营方式一" class="headerlink" title="经营方式一"></a>经营方式一</h3><p>客户每下一份订单，小明就让一个配送员盯着，然后让人开车去送。慢慢的小曲就发现了这种经营方式存在下述问题：</p><p>时间都花在了抢车上了，大部分配送员都处在闲置状态，抢到车才能去送。</p><p>随着下单的增多，配送员也越来越多，小明发现快递店里越来越挤，没办法雇佣新的配送员了。</p><p>配送员之间的协调很花时间。</p><p>综合上述缺点，小明痛定思痛，提出了经营方式二。</p><h3 id="经营方式二"><a href="#经营方式二" class="headerlink" title="经营方式二"></a>经营方式二</h3><p>小明只雇佣一个配送员。当客户下单，小明按送达地点标注好，依次放在一个地方。最后，让配送员依次开着车去送，送好了就回来拿下一个。上述两种经营方式对比，很明显第二种效率更高。</p><p>在上述比喻中：</p><p>每个配送员→每个线程</p><p>每个订单→每个 Socket(I/O 流)</p><p>订单的送达地点→Socket 的不同状态</p><p>客户送餐请求→来自客户端的请求</p><p>小明的经营方式→服务端运行的代码</p><p>一辆车→CPU 的核数</p><p>于是有了如下结论：</p><p>经营方式一就是传统的并发模型，每个 I/O 流(订单)都有一个新的线程(配送员)管理。</p><p>经营方式二就是 I/O 多路复用。只有单个线程(一个配送员)，通过跟踪每个 I/O 流的状态(每个配送员的送达地点)，来管理多个 I/O 流。</p><p>下面类比到真实的 Redis 线程模型，如图所示：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20200814112453.png" alt=""></p><p>Redis-client 在操作的时候，会产生具有不同事件类型的 Socket。在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p><h2 id="3、Redis-的数据类型及使用场景"><a href="#3、Redis-的数据类型及使用场景" class="headerlink" title="3、Redis 的数据类型及使用场景"></a>3、Redis 的数据类型及使用场景</h2><p>一个合格的程序员，这五种类型都会用到。</p><p>String</p><p>最常规的 set/get 操作，Value 可以是 String 也可以是数字。一般做一些复杂的计数功能的缓存。</p><p>Hash</p><p>这里 Value 存放的是结构化的对象，比较方便的就是操作其中的某个字段。我在做单点登录的时候，就是用这种数据结构存储用户信息，以 CookieId 作为 Key，设置 30 分钟为缓存过期时间，能很好的模拟出类似 Session 的效果。</p><p>List</p><p>使用 List 的数据结构，可以做简单的消息队列的功能。另外，可以利用 lrange 命令，做基于 Redis 的分页功能，性能极佳，用户体验好。</p><p>Set</p><p>因为 Set 堆放的是一堆不重复值的集合。所以可以做全局去重的功能。我们的系统一般都是集群部署，使用 JVM 自带的 Set 比较麻烦。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p><p>Sorted Set</p><p>Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。Sorted Set 可以用来做延时任务。</p><h2 id="4、如何解决-Redis-的并发竞争-Key-问题"><a href="#4、如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="4、如何解决 Redis 的并发竞争 Key 问题"></a>4、如何解决 Redis 的并发竞争 Key 问题</h2><p>这个问题大致就是，同时有多个子系统去 Set 一个 Key。这个时候要注意什么呢？大家基本都是推荐用 Redis 事务机制。</p><p>但是我并不推荐使用 Redis 的事务机制。因为我们的生产环境，基本都是 Redis 集群环境，做了数据分片操作。你一个事务中有涉及到多个 Key 操作的时候，这多个 Key 不一定都存储在同一个 redis-server 上。因此，Redis 的事务机制，十分鸡肋。</p><h3 id="如果对这个-Key-操作，不要求顺序"><a href="#如果对这个-Key-操作，不要求顺序" class="headerlink" title="如果对这个 Key 操作，不要求顺序"></a>如果对这个 Key 操作，不要求顺序</h3><p>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做 set 操作即可，比较简单。</p><h3 id="如果对这个-Key-操作，要求顺序"><a href="#如果对这个-Key-操作，要求顺序" class="headerlink" title="如果对这个 Key 操作，要求顺序"></a>如果对这个 Key 操作，要求顺序</h3><p>假设有一个 key1，系统 A 需要将 key1 设置为 valueA，系统 B 需要将 key1 设置为 valueB，系统 C 需要将 key1 设置为 valueC。</p><p>期望按照 key1 的 value 值按照 valueA &gt; valueB &gt; valueC 的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。</p><h3 id="假设时间戳如下："><a href="#假设时间戳如下：" class="headerlink" title="假设时间戳如下："></a>假设时间戳如下：</h3><p>系统 A key 1 {valueA 3:00}<br>系统 B key 1 {valueB 3:05}<br>系统 C key 1 {valueC 3:10}</p><p>那么，假设系统 B 先抢到锁，将 key1 设置为{valueB 3:05}。接下来系统 A 抢到锁，发现自己的 valueA 的时间戳早于缓存中的时间戳，那就不做 set 操作了，以此类推。其他方法，比如利用队列，将 set 方法变成串行访问也可以。</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>Redis 在国内各大公司都能看到其身影，比如我们熟悉的新浪，阿里，腾讯，百度，美团，小米等。学习 Redis，这几方面尤其重要：Redis 客户端、Redis 高级功能、Redis 持久化和开发运维常用问题探讨、Redis 复制的原理和优化策略、Redis 分布式解决方案等。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>idea插件分享记录</title>
    <url>/post/a8bfc85a.html</url>
    <content><![CDATA[<blockquote><p>IDEA插件分享与记录</p></blockquote><a id="more"></a><ol><li><p>CamelCase – 快速转成驼峰格式，安装好后，选中要修改的名称，按快捷键shift+alt+u 插件；</p></li><li><p>generate all setter – Alt+Enter就会出来 generate all setter选项,自动生成set方法；</p></li><li><p>Auto filling java call arguments – 调用一个函数，使用 Alt+Enter 组合键，调出 “Auto fill call parameters” 自动使用该函数定义的参数名填充；</p></li><li><p>string-manipulation – 插件使用 Alt+m 进行使用；</p></li><li><p>SequenceDiagram – 方法调用时序图；</p></li><li><p>better-mybatis-generator、Easy Code – 代码生成工具；</p></li><li><p>MybatisLogFormat – 提取SQL并将参数填充到SQL中到控制台；</p></li><li><p>extra-icons – 各种文件图标；</p></li><li><p>atom-material-icons – 文件图标(现在使用)；</p></li><li><p>dark-purple-theme – 深紫色主题(现在使用)；</p></li><li><p>Idea汉化插件 – Chinese (Simplified) Language Pack；</p></li><li><p>Idea代码格式化插件(阿里巴巴规范插件) – Eclipse Code Formatter, <a href="https://github.com/alibaba/p3c/tree/master/p3c-formatter" target="_blank" rel="noopener">样式xml文件地址</a> ；</p></li><li><p>搜索接口工具: Restfultool\Restfultoolkit(Idea更新到2020后,Restfultoolkit无法显示接口信息) 目前使用 Restfultool 就可以；</p></li><li><p>Cloud Toolkit: 一键部署神器-阿里云出品；</p></li><li><p>jd-gui 反编译工具：idea全局替换正则表达式如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">第一种：/.  ?[<span class="number">1</span><span class="number">-9</span>]\d* ./</span><br><span class="line">第二种：/.  -?[<span class="number">1</span><span class="number">-9</span>]\d* ./</span><br></pre></td></tr></table></figure></li></ol><h4 id="Idea插件"><a href="#Idea插件" class="headerlink" title="Idea插件"></a>Idea插件</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/%E5%85%A8%E9%83%A8%E7%9A%84%E6%8F%92%E4%BB%B6%E5%A4%87%E4%BB%BD.png" alt="Idea插件记录"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>linux下docker安装、Portainer图形化部署介绍</title>
    <url>/post/40d21fb3.html</url>
    <content><![CDATA[<blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p></blockquote><a id="more"></a><h3 id="一、Docker安装"><a href="#一、Docker安装" class="headerlink" title="一、Docker安装"></a>一、Docker安装</h3><p>​ 1. 更新yum源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y update</span><br></pre></td></tr></table></figure><p>​ 2. 安装epel源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y epel-release </span><br><span class="line">​```shell</span><br><span class="line">​	3. 清除缓存</span><br><span class="line">​```shell</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure><p>​ 4. 安装Docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-io -y</span><br></pre></td></tr></table></figure><p>​ 5. 运行Docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>​ 6. 检查安装结果</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><h3 id="二、Portainer-UI-安装"><a href="#二、Portainer-UI-安装" class="headerlink" title="二、Portainer  UI  安装"></a>二、Portainer UI 安装</h3><p>​ 1. 下载镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.io/portainer/portainer</span><br></pre></td></tr></table></figure><p>​ 2. 运行启动Portainer UI</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name portainer  docker.io/portainer/portainer</span><br></pre></td></tr></table></figure><p>如果9000端口别占用的话，可以换成其他端口。</p><h3 id="三、开启Docker远程访问"><a href="#三、开启Docker远程访问" class="headerlink" title="三、开启Docker远程访问"></a>三、开启Docker远程访问</h3><pre><code>1.  默认的Docker是不支持远程访问的，需要加点配置，开启Docker的远程访问，修改服务器的docker.service文件
  修改以ExecStart开头的行（centos 7）：</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改Docker服务文件，需要先切换到root用户</span></span><br><span class="line">vim /lib/systemd/system/docker.service</span><br><span class="line"><span class="meta">#</span><span class="bash">注释掉<span class="string">"ExecStart"</span>这一行，并添加下面这一行信息</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure><p>​ 2. 重新加载配置文件以及重启docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">重新加载配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span><span class="bash">重启服务</span></span><br><span class="line">systemctl restart docker.service</span><br><span class="line"><span class="meta">#</span><span class="bash">查看配置的端口号（2375）是否开启（防火墙必须放开docker远程端口，如果找不到netstat命令，可以先安装一下这个工具，具体百度。</span></span><br><span class="line">netstat -ntulp |grep 2375</span><br></pre></td></tr></table></figure><p>​ 3. 测试连接是否正常返回</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl http://localhost:2375/version</span><br></pre></td></tr></table></figure><p>​ 4. 访问 <strong><a href="http://IP地址:9000/" target="_blank" rel="noopener">http://IP地址:9000/</a></strong> 即可看到Portainer UI界面</p><h3 id="四、Idea连接Docker"><a href="#四、Idea连接Docker" class="headerlink" title="四、Idea连接Docker"></a>四、Idea连接Docker</h3><h4 id="1、使用idea的docker插件连接docker，下载过docker插件了。"><a href="#1、使用idea的docker插件连接docker，下载过docker插件了。" class="headerlink" title="1、使用idea的docker插件连接docker，下载过docker插件了。"></a>1、使用idea的docker插件连接docker，下载过docker插件了。</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311111835.png" alt=""></p><h4 id="2、点击idea的设置选项（file-–-gt-setting-gt-docker）-新建连接"><a href="#2、点击idea的设置选项（file-–-gt-setting-gt-docker）-新建连接" class="headerlink" title="2、点击idea的设置选项（file –&gt; setting -&gt; docker）,新建连接"></a>2、点击idea的设置选项（file –&gt; setting -&gt; docker）,新建连接</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112013.png" alt=""></p><h4 id="3、镜像的拉取"><a href="#3、镜像的拉取" class="headerlink" title="3、镜像的拉取"></a>3、镜像的拉取</h4><p>idea可以通过可视化的方式拉取镜像，不用自己去敲命令<br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112211.png" alt=""><br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112025.png" alt=""><br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112033.png" alt=""><br>有时候会出现拉取的时间超时的情况，可以配置一下国内的镜像获取阿里云的加速器<br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112118.png" alt=""></p><h4 id="4、容器的创建与运行"><a href="#4、容器的创建与运行" class="headerlink" title="4、容器的创建与运行"></a>4、容器的创建与运行</h4><h5 id="a-创建并且运行docker容器"><a href="#a-创建并且运行docker容器" class="headerlink" title="a.创建并且运行docker容器"></a>a.创建并且运行docker容器</h5><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112121.png" alt=""><br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112123.png" alt=""></p><h5 id="b-创建成功之后可以看到新创建的容器，也可以在服务器-虚拟机-上用docker命令查看"><a href="#b-创建成功之后可以看到新创建的容器，也可以在服务器-虚拟机-上用docker命令查看" class="headerlink" title="b.创建成功之后可以看到新创建的容器，也可以在服务器(虚拟机)上用docker命令查看"></a>b.创建成功之后可以看到新创建的容器，也可以在服务器(虚拟机)上用docker命令查看</h5><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112207.png" alt=""></p><h5 id="c-重启容器、停止容器和删除容器等操作"><a href="#c-重启容器、停止容器和删除容器等操作" class="headerlink" title="c.重启容器、停止容器和删除容器等操作"></a>c.重启容器、停止容器和删除容器等操作</h5><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210311112145.png" alt=""></p><h3 id="五、Docker基本命令"><a href="#五、Docker基本命令" class="headerlink" title="五、Docker基本命令"></a>五、Docker基本命令</h3><ol><li><p>启动docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>停止docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure></li><li><p>重启docker</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>开机启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure></li><li><p>查看已经运行的镜像</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure></li><li><p>彻底卸载干净docker并且安装docker 指定版本</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-selinux \</span><br><span class="line">docker-engine-selinux \</span><br><span class="line">docker-engine</span><br><span class="line"></span><br><span class="line">rm -rf /etc/systemd/system/docker.service.d</span><br><span class="line"></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"></span><br><span class="line">rm -rf /var/run/docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">过滤一下还有没有没卸载掉的docker</span></span><br><span class="line">rpm -qa|grep docker</span><br></pre></td></tr></table></figure><h3 id="六、容器管理工具"><a href="#六、容器管理工具" class="headerlink" title="六、容器管理工具"></a>六、容器管理工具</h3><p><a href="https://www.cnblogs.com/zhangxingeng/p/11753959.html#toc_6" target="_blank" rel="noopener">《Rancher 2.x》</a><br><a href="https://gitee.com/rancher/rancher" target="_blank" rel="noopener">《Rancher码云存储库》</a><br><a href="https://docs.rancher.cn/rancher2/" target="_blank" rel="noopener">《Rancher官方网站》</a></p></li></ol><blockquote><ol><li>Rancher不仅能够管理应用容器，更重要的一点是能够管理K8s集群。</li><li>Rancher2.x底层基于k8s调度引擎，通过Rancher的封装，用户可以在不熟悉k8s概念的情况下轻松的通过Rancher来部署容器到k8s集群当中。</li></ol></blockquote><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210318103536.png" alt="Rancher和K8s的初步对比"></p><h3 id="七、安装-redis"><a href="#七、安装-redis" class="headerlink" title="七、安装 redis"></a>七、安装 redis</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull redis:latest</span><br><span class="line">docker run -itd --name redis-6379 -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h3 id="八、增加阿里云镜像加速"><a href="#八、增加阿里云镜像加速" class="headerlink" title="八、增加阿里云镜像加速"></a>八、增加阿里云镜像加速</h3><p>“registry-mirrors”:[<br>“<a href="https://ig73arpt.mirror.aliyuncs.com&quot;" target="_blank" rel="noopener">https://ig73arpt.mirror.aliyuncs.com&quot;</a><br>]</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20220712172017023.png" alt="image-20220712172017023"></p><h3 id="九、安装-mysql"><a href="#九、安装-mysql" class="headerlink" title="九、安装 mysql"></a>九、安装 mysql</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line">docker run -itd -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root mysql</span><br></pre></td></tr></table></figure><h3 id="十、安装-zk"><a href="#十、安装-zk" class="headerlink" title="十、安装 zk"></a>十、安装 zk</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull docker.io/zookeeper</span><br><span class="line"></span><br><span class="line">docker run --privileged=true -d --name zookeeper --publish 2181:2181  -d zookeeper:latest</span><br></pre></td></tr></table></figure><h3 id="十一、安装-kafka"><a href="#十一、安装-kafka" class="headerlink" title="十一、安装 kafka"></a>十一、安装 kafka</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull wurstmeister/kafka</span><br><span class="line"></span><br><span class="line">docker run -d --name kafka --publish 9092:9092 --link zookeeper --env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 --env KAFKA_ADVERTISED_HOST_NAME=localhost --env KAFKA_ADVERTISED_PORT=9092  wurstmeister/kafka</span><br></pre></td></tr></table></figure><h3 id="十二、安装-mongodb"><a href="#十二、安装-mongodb" class="headerlink" title="十二、安装 mongodb"></a>十二、安装 mongodb</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name mongodb -v ~/docker/mongo:/data/db -p 27017:27017 -d mongo</span><br></pre></td></tr></table></figure><h3 id="十三、参考推荐"><a href="#十三、参考推荐" class="headerlink" title="十三、参考推荐"></a>十三、参考推荐</h3><p><a href="https://blog.csdn.net/caidingnu/article/details/109279904" target="_blank" rel="noopener">《IDEA使用Docker插件构建镜像》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Portainer</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现PDF首页转缩略图</title>
    <url>/post/9be4f81b.html</url>
    <content><![CDATA[<blockquote><p>PDF首页转缩略图 ~ 请开始您的表演~</p></blockquote><a id="more"></a><h3 id="一、maven安装"><a href="#一、maven安装" class="headerlink" title="一、maven安装"></a>一、maven安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.icepdf.os&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;icepdf-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.2.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="二、Java代码实现"><a href="#二、Java代码实现" class="headerlink" title="二、Java代码实现"></a>二、Java代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.icepdf.core.pobjects.Document;</span><br><span class="line"><span class="keyword">import</span> org.icepdf.core.pobjects.Page;</span><br><span class="line"><span class="keyword">import</span> org.icepdf.core.util.GraphicsRenderingHints;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.IIOImage;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageWriter;</span><br><span class="line"><span class="keyword">import</span> javax.imageio.stream.ImageOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CapturePdfFirstPageUtil</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成一本书的缩略图</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inputFile  需要生成缩略图的书籍的完整路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputFile 生成缩略图的放置路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateBookIamge</span><span class="params">(String inputFile, String outputFile)</span> </span>&#123;</span><br><span class="line">        Document document = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">float</span> rotation = <span class="number">0f</span>;</span><br><span class="line">            <span class="comment">// 缩略图显示倍数，1表示不缩放，0.5表示缩小到50%</span></span><br><span class="line">            <span class="keyword">float</span> zoom = <span class="number">0.8f</span>;</span><br><span class="line"></span><br><span class="line">            document = <span class="keyword">new</span> Document();</span><br><span class="line">            document.setFile(inputFile);</span><br><span class="line">            <span class="comment">// maxPages = document.getPageTree().getNumberOfPages();</span></span><br><span class="line"></span><br><span class="line">            BufferedImage p_w_picpath = (BufferedImage) document.getPageImage(<span class="number">0</span>, GraphicsRenderingHints.SCREEN,</span><br><span class="line">                    Page.BOUNDARY_CROPBOX, rotation, zoom);</span><br><span class="line"></span><br><span class="line">            Iterator iter = ImageIO.getImageWritersBySuffix(<span class="string">"jpg"</span>);</span><br><span class="line">            ImageWriter writer = (ImageWriter) iter.next();</span><br><span class="line"></span><br><span class="line">            FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(outputFile));</span><br><span class="line">            ImageOutputStream outImage = ImageIO.createImageOutputStream(out);</span><br><span class="line"></span><br><span class="line">            writer.setOutput(outImage);</span><br><span class="line">            writer.write(<span class="keyword">new</span> IIOImage(p_w_picpath, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"生成书的缩略图失败 : "</span> + inputFile);</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CapturePdfFirstPageUtil.generateBookIamge(<span class="string">"C:\\Users\\Downloads\\我是帅子男一号.pdf"</span>, <span class="string">"C:\\Users\\Desktop\\帅子男一号.jpg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>SpringBoot打包解决xx.jar中没有主清单属性问题</title>
    <url>/post/a4e7c890.html</url>
    <content><![CDATA[<blockquote><p>SpringBoot项目打jar包部署的时候遇到一个问题，xxx.jar包中没有主清单属性问题解决记录。</p></blockquote><a id="more"></a><h4 id="一、问题解析"><a href="#一、问题解析" class="headerlink" title="一、问题解析"></a>一、问题解析</h4><p>​ 有问题的jar包文件中少了Spring-Boot-Version、Main-Class、Start-Class、Spring-Boot-Classes、Spring-Boot-Lib五个Springboot相关的属性。</p><ol><li>​ Main-Class：属性值代表了Spring Boot中启动jar包的程序，值为 org.springframework.boot.loader.JarLauncher，这个就是Springboot启动项目的类</li><li>Start-Class：属性值代表了Spring Boot程序的入口类，即XXXApplication类</li><li>Spring-Boot-Classes：属性值代表了类路径，所有编译后的class文件，以及配置文件，都存储在该路径下</li><li>Spring-Boot-Lib：属性值代表了表示依赖的jar包存储的位置</li></ol><p>以上这些属性是Springboot打包插件默认生成，缺少这些属性项目无法运行。</p><h4 id="二、添加maven打包插件"><a href="#二、添加maven打包插件" class="headerlink" title="二、添加maven打包插件"></a>二、添加maven打包插件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 启动类包名 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.shuaizi.DockerApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 在mvn package 之后，再次打包成为一个 可执行的jar/war，同时保留mvn package生成的jar/war为.origin 创建一个自动可执行的jar或war文件。它可以替换常规的artifact，或者用一个单独的classifier附属在maven构建的生命周期中。--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>linux常用命令总结</title>
    <url>/post/1d063ae7.html</url>
    <content><![CDATA[<blockquote><p>工作中linux常用命令总结，祝愿每一个程序员天天无bug ~ ~</p></blockquote><a id="more"></a><ol><li><p>根据 关键词 查看日志 并返回关键词所在行</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat  log.log | grep "train"　　# 返回log.log中包含train的所有行</span><br><span class="line">grep -i "train" log.log  或者 grep -a  "train" log.log  　# 返回log.log中包含train的所有行；使用 -i 关闭大小写敏感</span><br><span class="line">grep 'XXX' service.log -C2  # 使用 -C2 来多展示日志下面的两行，这里的 C 是大写的；使用 -v 搜索不包含某个内容的数据（取反）</span><br></pre></td></tr></table></figure></li><li><p>关键词前后行信息打印</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat xx.log | grep -C 5 '关键字' 显示file文件里匹配“关键字”字串那行以及上下5行</span><br><span class="line">cat xx.log | grep -B 5 '关键字' 显示“关键字”及前5行</span><br><span class="line">cat xx.log | grep -A 5 '关键字' 显示“关键字”及后5行</span><br></pre></td></tr></table></figure></li><li><p>实时过滤打印的参数</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tail -f  文件名 | grep -i "关键词"</span><br></pre></td></tr></table></figure></li><li><p>Sed 命令打印模糊查询</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sed -n "/关键词/p" 文件名</span><br></pre></td></tr></table></figure></li><li><p>查看端口号进程 PID</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof -i:端口号</span><br></pre></td></tr></table></figure></li><li><p>指定配置文件启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">单个配置文件: nohup java -jar vTest.jar  --spring.config.location=/opt/vTest-conf/application.yml &gt;  /opt/home/nohup.out 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line">多个配置文件: nohup java -jar vTest.jar --spring.config.location=/home/jar/config/application.yml,/home/jar/config/application-dev.yml &gt;  /home/jar/api-nohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></li><li><p>检查Jar进程的 PID</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep member.root.weChat.jar</span><br></pre></td></tr></table></figure></li><li><p>运行Jar命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar service-qq-app.jar &amp;</span><br><span class="line">nohup java -jar service-qq-app.jar &gt;  /home/jar/api-nohup.out 2&gt;&amp;1 &amp; #指定打印日志文件</span><br></pre></td></tr></table></figure></li><li><p>Linux下测试IP端口号连通性</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令wget（推荐使用）</span></span><br><span class="line">wget 192.168.10.253:9000</span><br></pre></td></tr></table></figure></li><li><p>查看某个时间段的日志</p><p>有时，需要查看某个时间段的日志，比如凌晨2点15分系统出现报警，上班后我们想看看这段时间的日志，看能不能找到点线索，方法如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 导出02:14到02:16分的日志</span></span><br><span class="line">awk '/2022-06-24T02:14/,/2022-06-24T02:1[6-9]/' app.log &gt; app0215.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用sed也是可以的</span></span><br><span class="line">sed -n '/2022-06-24T02:14/,/2022-06-24T02:1[6-9]/p' app.log &gt; app0215.log</span><br></pre></td></tr></table></figure><p>注：awk与sed实际并不解析时间，它们只是按正则匹配，匹配到第一个正则时，开始输出行，直到遇到第二个正则关闭，所以如果你的日志中没有能匹配第二个正则的行，将导致一直输出到尾行！所以一般需要将第二个正则变宽松点，如上面的/2022-06-24T02:1[6-9]/，以避免出现这种情况</p></li><li><p>查看最后10条错误</p><p>更多情况是，上班时发现系统有报警，于是想立马看看刚刚发生了什么，即查找最近的异常日志，如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 最容易想到的是tail，但有可能最后1000行日志全是正常日志</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tail -n 1000 app.log | less</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后10条异常, tac会反向读取日志行，然后用grep找到10个异常日志，再用tac又反向一次就正向了  </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tac app.log | grep -n -m10 ERROR | tac</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://segmentfault.com/a/1190000042033198" target="_blank" rel="noopener">《拒绝蛮力，高效查看Linux日志文件！》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>多线程场景下使用ArrayList，这几点一定要注意！</title>
    <url>/post/25419109.html</url>
    <content><![CDATA[<blockquote><p>ArrayList 不是线程安全的，这点很多人都知道，但是线程不安全的原因及表现，怎么在多线程情况下使用ArrayList，可能不是很清楚，这里总结一下。</p></blockquote><a id="more"></a><h3 id="一、线程不安全的两种体现"><a href="#一、线程不安全的两种体现" class="headerlink" title="一、线程不安全的两种体现"></a>一、线程不安全的两种体现</h3><p>查看 ArrayList 的 add 操作源码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line">      ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">      <span class="comment">// 将元素添加进列表的元素数组里面</span></span><br><span class="line">      elementData[size++] = e;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-数组越界异常-ArrayIndexOutOfBoundsException"><a href="#1-数组越界异常-ArrayIndexOutOfBoundsException" class="headerlink" title="1. 数组越界异常 ArrayIndexOutOfBoundsException"></a>1. 数组越界异常 ArrayIndexOutOfBoundsException</h4><p>由于ArrayList添加元素是如上面分两步进行，可以看出第一个不安全的隐患，在多个线程进行add操作时可能会导致elementData数组越界。</p><p>具体逻辑如下：</p><ol><li>列表大小为9，即size=9</li><li>线程A开始进入add方法，这时它获取到size的值为9，调用ensureCapacityInternal方法进行容量判断。</li><li>线程B此时也进入add方法，它获取到size的值也为9，也开始调用ensureCapacityInternal方法。</li><li>线程A发现需求大小为10，而elementData的大小就为10，可以容纳。于是它不再扩容，返回。</li><li>线程B也发现需求大小为10，也可以容纳，返回。</li><li>线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10。</li><li>线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException.</li></ol><h4 id="2-元素值覆盖和为空问题"><a href="#2-元素值覆盖和为空问题" class="headerlink" title="2. 元素值覆盖和为空问题"></a>2. 元素值覆盖和为空问题</h4><p>elementData[size++] = e 设置值的操作同样会导致线程不安全。从这儿可以看出，这步操作也不是一个原子操作，它由如下两步操作构成：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elementData[size] = e;</span><br><span class="line">size = size + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在单线程执行这两条代码时没有任何问题，但是当多线程环境下执行时，可能就会发生一个线程的值覆盖另一个线程添加的值，具体逻辑如下：</p><ol><li>列表大小为0，即size=0</li><li>线程A开始添加一个元素，值为A。此时它执行第一条操作，将A放在了elementData下标为0的位置上。</li><li>接着线程B刚好也要开始添加一个值为B的元素，且走到了第一步操作。此时线程B获取到size的值依然为0，于是它将B也放在了elementData下标为0的位置上。</li><li>线程A开始将size的值增加为1</li><li>线程B开始将size的值增加为2</li></ol><p>这样线程AB执行完毕后，理想中情况为size为2，elementData下标0的位置为A，下标1的位置为B。而实际情况变成了size为2，elementData下标为0的位置变成了B，下标1的位置上什么都没有。并且后续除非使用set方法修改此位置的值，否则将一直为null，因为size为2，添加元素时会从下标为2的位置上开始。</p><h3 id="二、代码验证示例"><a href="#二、代码验证示例" class="headerlink" title="二、代码验证示例"></a>二、代码验证示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://mp.weixin.qq.com/s/LLldnqyCQKEutwmNXXDSnA</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ArrayList 不是线程安全的，这点很多人都知道，但是线程不安全的原因及表现，怎么在多线程情况下使用ArrayList，可能不是很清楚，这里总结一下。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/2/1 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListSafeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 线程A将1-1000添加到列表</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程B将1001-2000添加到列表</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1001</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">                list.add(i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印所有结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个元素为："</span> + list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程中，两种情况出现如下：</p><ol><li><p>元素值覆盖和为空问题</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210201171141.png" alt=""></p></li><li><p>报数组越界异常 ArrayIndexOutOfBoundsException错误</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210201171152.png" alt=""></p></li></ol><h3 id="三、ArrayList线程安全处理"><a href="#三、ArrayList线程安全处理" class="headerlink" title="三、ArrayList线程安全处理"></a>三、ArrayList线程安全处理</h3><ol><li><p><strong>Collections.synchronizedList</strong></p><p>最常用的方法是<strong>通过 Collections 的 synchronizedList 方法</strong>将 ArrayList 转换成线程安全的容器后再使用。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; list = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br></pre></td></tr></table></figure></li><li><p><strong>为list.add()方法加锁</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(list.get()) &#123;</span><br><span class="line">	  list.get().add(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>CopyOnWriteArrayList</strong></p><p>使用线程安全的 CopyOnWriteArrayList 代替线程不安全的 ArrayList。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure></li><li><p><strong>使用ThreadLocal</strong></p><p>使用ThreadLocal变量确保线程封闭性(封闭线程往往是比较安全的， 但由于使用ThreadLocal封装变量，相当于把变量丢进执行线程中去，每new一个新的线程，变量也会new一次，一定程度上会造成性能[内存]损耗，但其执行完毕就销毁的机制使得ThreadLocal变成比较优化的并发解决方案)。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocal&lt;List&lt;Object&gt;&gt; threadList = <span class="keyword">new</span> ThreadLocal&lt;List&lt;Object&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">protected</span> List&lt;Object&gt; <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">         &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li></ol><p>最后如果在代码的例子里使用以上四种方法的话，就不会报错，正常使用。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MultiThread</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将拦截器托管给IOC容器？</title>
    <url>/post/cb1b036e.html</url>
    <content><![CDATA[<blockquote><p>如何将拦截器托管给IOC容器 ~</p></blockquote><a id="more"></a><h2 id="一、第一种"><a href="#一、第一种" class="headerlink" title="一、第一种"></a>一、第一种</h2><p>在拦截器上使用 @Component ，同时在 WebConfiguration 中使用 @Autowired 注解将拦截器注入。</p><p><strong>拦截器代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置类代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LoginInterceptor loginInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(loginInterceptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、第二种"><a href="#二、第二种" class="headerlink" title="二、第二种"></a>二、第二种</h2><p>在 WebConfiguration 将拦截器注成bean，拦截器无需增加 @Component 注解，在 WebConfiguration 类中使用 @Bean 注解将拦截器注成bean。</p><p><strong>拦截器代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置类代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">loginInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor( loginInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、第三种"><a href="#三、第三种" class="headerlink" title="三、第三种"></a>三、第三种</h2><p>通过构造器处理思路是在 WebConfiguration 类中注入需要的验证 token 的业务类，然后在初始化拦截器的时候将业务类通过构造器带入拦截器中，这样就不用把拦截器注成Spring Bean对象了。</p><p><strong>拦截器代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TokenUtil tokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginInterceptor</span><span class="params">(TokenUtil tokenUtil)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tokenUtil = tokenUtil;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>配置类代码：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfiguration</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenUtil tokenUtil;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> LoginInterceptor(tokenUtil));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>网上关于拦截器的代码基本都是通过new一个拦截器进行配置的，这时候就会出现无法注入其他bean的情况。很多人想当然地直接在拦截器加 @Component 注解使其成为一个bean对象。这是一种错误的做法。</p><p>我们需要保证的是 在WebMvc配置类中添加的拦截器是Spring 的一个bean对象 ，也就是说我们需要将拦截器注成一个bean，同时将这个bean添加的WebMvc配置类中。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>SpringBoot官方提供的Starter</title>
    <url>/post/ea1b33e9.html</url>
    <content><![CDATA[<blockquote><p>SpringBoot官方提供的Starter介绍 ~</p></blockquote><a id="more"></a><h4 id="1、application-starters（应用级）"><a href="#1、application-starters（应用级）" class="headerlink" title="1、application starters（应用级）"></a>1、application starters（应用级）</h4><table><thead><tr><th align="center">Starter 名称</th><th align="center">Starter 描述</th></tr></thead><tbody><tr><td align="center">spring-boot-starter</td><td align="center">核心 Starter，包括自动配置、日志及 YAML 支持等</td></tr><tr><td align="center">spring-boot-starter-activemq</td><td align="center">集成 Apache ActiveMQ，基于 JMS 的消息队列</td></tr><tr><td align="center">spring-boot-starter-artemis</td><td align="center">集成 Apache Artemis，基于 JMS 的消息队列</td></tr><tr><td align="center">spring-boot-starter-amqp</td><td align="center">集成 Spring AMQP 和 Rabbit MQ 的消息队列</td></tr><tr><td align="center">spring-boot-starter-aop</td><td align="center">集成 Spring AOP 和 AspectJ 面向切面编程</td></tr><tr><td align="center">spring-boot-starter-batch</td><td align="center">集成 Spring Batch（批处理）</td></tr><tr><td align="center">spring-boot-starter-cache</td><td align="center">集成 Spring Cache（缓存）</td></tr><tr><td align="center">spring-boot-starter-data-cassandra</td><td align="center">集成 Cassandra（分布式数据库） 和 Spring Data Cassandra</td></tr><tr><td align="center">spring-boot-starter-data-cassandra-reactive</td><td align="center">集成 Cassandra（分布式数据库） 和 Spring Data Cassandra Reactive</td></tr><tr><td align="center">spring-boot-starter-data-couchbase</td><td align="center">集成 Couchbase（文档型数据库） 和 Spring Data Couchbase</td></tr><tr><td align="center">spring-boot-starter-data-couchbase-reactive</td><td align="center">集成 Couchbase（文档型数据库） 和 Spring Data Couchbase Reactive</td></tr><tr><td align="center">spring-boot-starter-data-elasticsearch</td><td align="center">集成 Elasticsearch（搜索引擎）和 Spring Data Elasticsearch</td></tr><tr><td align="center">spring-boot-starter-data-solr</td><td align="center">集成 Apache Solr（搜索引擎）结合 Spring Data Solr</td></tr><tr><td align="center">spring-boot-starter-data-jdbc</td><td align="center">集成 Spring Data JDBC</td></tr><tr><td align="center">spring-boot-starter-data-jpa</td><td align="center">集成 Spring Data JPA 结合 Hibernate</td></tr><tr><td align="center">spring-boot-starter-data-ldap</td><td align="center">集成 Spring Data LDAP</td></tr><tr><td align="center">spring-boot-starter-data-mongodb</td><td align="center">集成 MongoDB（文档型数据库）和 Spring Data MongoDB</td></tr><tr><td align="center">spring-boot-starter-data-mongodb-reactive</td><td align="center">集成 MongoDB（文档型数据库）和 Spring Data MongoDB Reactive</td></tr><tr><td align="center">spring-boot-starter-data-neo4j</td><td align="center">集成 Neo4j（图形数据库）和 Spring Data Neo4j</td></tr><tr><td align="center">spring-boot-starter-data-r2dbc</td><td align="center">集成 Spring Data R2DBC</td></tr><tr><td align="center">spring-boot-starter-data-redis</td><td align="center">集成 Redis（内存数据库）结合 Spring Data Redis 和 Lettuce 客户端</td></tr><tr><td align="center">spring-boot-starter-data-redis-reactive</td><td align="center">集成 Redis（内存数据库）结合 Spring Data Redis reactive 和 Lettuce 客户端</td></tr><tr><td align="center">spring-boot-starter-data-rest</td><td align="center">集成 Spring Data REST 暴露 Spring Data repositories 输出 REST 资源</td></tr><tr><td align="center">spring-boot-starter-thymeleaf</td><td align="center">集成 Thymeleaf 视图构建 MVC web 应用</td></tr><tr><td align="center">spring-boot-starter-freemarker</td><td align="center">集成 FreeMarker 视图构建 MVC web 应用</td></tr><tr><td align="center">spring-boot-starter-groovy-templates</td><td align="center">集成 Groovy 模板视图构建 MVC web 应用</td></tr><tr><td align="center">spring-boot-starter-hateoas</td><td align="center">集成 Spring MVC 和 Spring HATEOAS 构建超媒体 RESTful Web 应用程序</td></tr><tr><td align="center">spring-boot-starter-integration</td><td align="center">集成 Spring Integration</td></tr><tr><td align="center">spring-boot-starter-jdbc</td><td align="center">集成 JDBC 结合 HikariCP 连接池</td></tr><tr><td align="center">spring-boot-starter-jersey</td><td align="center">集成 JAX-RS 和 Jersey 构建 RESTful web 应用，是 spring-boot-starter-web 的一个替代 Starter</td></tr><tr><td align="center">spring-boot-starter-jooq</td><td align="center">集成 jOOQ 访问 SQL 数据库，是 spring-boot-starter-data-jpa 或者 spring-boot-starter-jdbc 的替代 Starter</td></tr><tr><td align="center">spring-boot-starter-json</td><td align="center">用于读写 JSON</td></tr><tr><td align="center">spring-boot-starter-jta-atomikos</td><td align="center">集成 Atomikos 实现 JTA 事务</td></tr><tr><td align="center">spring-boot-starter-jta-bitronix</td><td align="center">集成 Bitronix 实现 JTA 事务（ 从 2.3.0 开始标识为 <strong>Deprecated</strong>）</td></tr><tr><td align="center">spring-boot-starter-mail</td><td align="center">集成 Java Mail 和 Spring 框架的邮件发送功能</td></tr><tr><td align="center">spring-boot-starter-mustache</td><td align="center">集成 Mustache 视图构建 web 应用</td></tr><tr><td align="center">spring-boot-starter-security</td><td align="center">集成 Spring Security</td></tr><tr><td align="center">spring-boot-starter-oauth2-client</td><td align="center">集成 Spring Security’s OAuth2/OpenID 连接客户端功能</td></tr><tr><td align="center">spring-boot-starter-oauth2-resource-server</td><td align="center">集成 Spring Security’s OAuth2 资源服务器功能</td></tr><tr><td align="center">spring-boot-starter-quartz</td><td align="center">集成 Quartz 任务调度</td></tr><tr><td align="center">spring-boot-starter-rsocket</td><td align="center">构建 RSocket 客户端和服务端</td></tr><tr><td align="center">spring-boot-starter-test</td><td align="center">集成 JUnit Jupiter, Hamcrest 和 Mockito 测试 Spring Boot 应用和类库</td></tr><tr><td align="center">spring-boot-starter-validation</td><td align="center">集成 Java Bean Validation 结合 Hibernate Validator</td></tr><tr><td align="center">spring-boot-starter-web</td><td align="center">集成 Spring MVC 构建 RESTful web 应用，使用 Tomcat 作为默认内嵌容器</td></tr><tr><td align="center">spring-boot-starter-web-services</td><td align="center">集成 Spring Web Services</td></tr><tr><td align="center">spring-boot-starter-webflux</td><td align="center">集成 Spring Reactive Web 构建 WebFlux 应用</td></tr><tr><td align="center">spring-boot-starter-websocket</td><td align="center">集成 Spring WebSocket 构建 WebSocket 应用</td></tr></tbody></table><h4 id="2、production-starters（生产级）"><a href="#2、production-starters（生产级）" class="headerlink" title="2、production starters（生产级）"></a>2、production starters（生产级）</h4><p>下面生产级 Starters 能被用于线上/生产功能：</p><table><thead><tr><th align="center">Starter 名称</th><th align="center">Starter 描述</th></tr></thead><tbody><tr><td align="center">spring-boot-starter-actuator</td><td align="center">集成 Spring Boot Actuator，提供生产功能以帮助监控和管理应用程序</td></tr></tbody></table><h4 id="3、technical-starters（技术级）"><a href="#3、technical-starters（技术级）" class="headerlink" title="3、technical starters（技术级）"></a>3、technical starters（技术级）</h4><p>Spring Boot 还包括下面的技术类 Starters，用于帮助你排除或者替换指定的框架或技术：</p><table><thead><tr><th align="center">Starter 名称</th><th align="center">Starter 描述</th></tr></thead><tbody><tr><td align="center">spring-boot-starter-jetty</td><td align="center">集成 Jetty 作为内嵌的 servlet 容器，可用于替代 spring-boot-starter-tomcat</td></tr><tr><td align="center">spring-boot-starter-log4j2</td><td align="center">集成 Log4j2 日志框架，可用于替代 spring-boot-starter-logging</td></tr><tr><td align="center">spring-boot-starter-logging</td><td align="center">集成 Logback 日志框架，这个也是默认的日志 Starter</td></tr><tr><td align="center">spring-boot-starter-reactor-netty</td><td align="center">集成 Netty 作为内嵌的响应式 HTTP 服务器</td></tr><tr><td align="center">spring-boot-starter-tomcat</td><td align="center">集成 Tomcat 作为内嵌的 servlet 容器，这也是默认的 servlet 容器 starter 被集成 spring-boot-starter-web 里面</td></tr><tr><td align="center">spring-boot-starter-undertow</td><td align="center">集成 Undertow 作为内嵌的 servlet 容器，可用于替代 spring-boot-starter-tomcat</td></tr></tbody></table><p>最新请参考：</p><blockquote><p><a href="https://docs.spring.io/spring-boot/docs/" target="_blank" rel="noopener">《Spring官方文档查阅》</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&mid=2247490787&idx=1&sn=f9eb0b28ab7b29bbf77381be85c7a5b2&chksm=eb5399d5dc2410c37a7fd15b845ce53bcdb67f8308af75d7296cdc2b813aefe1723a8a888094&scene=21#wechat_redirect" target="_blank" rel="noopener">《年轻人的第一个自定义 Spring Boot Starter！》</a></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Redis缓存和MySQL数据一致性方案</title>
    <url>/post/58a4e3a.html</url>
    <content><![CDATA[<blockquote><p>Redis缓存和MySQL数据一致性方案详解 ~</p></blockquote><a id="more"></a><h2 id="需求起因"><a href="#需求起因" class="headerlink" title="需求起因"></a><strong>需求起因</strong></h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210203113618.jpeg" alt=""></p><p>这个业务场景，主要是解决读数据从Redis缓存，一般都是按照下图的流程来进行业务操作。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210203113611.jpeg" alt=""></p><p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现 <strong>缓存(Redis)和数据库（MySQL）间的数据一致性问题</strong>。</p><p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p><ol><li><p>如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p></li><li><p>如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p></li></ol><p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p><p>如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。</p><h2 id="缓存和数据库一致性解决方案"><a href="#缓存和数据库一致性解决方案" class="headerlink" title="缓存和数据库一致性解决方案"></a>缓存和数据库一致性解决方案</h2><h4 id="一、采用延时双删策略"><a href="#一、采用延时双删策略" class="headerlink" title="一、采用延时双删策略"></a><strong>一、采用延时双删策略</strong></h4><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key,Object data)</span></span>&#123;</span><br><span class="line"> 	redis.delKey(key);</span><br><span class="line"> 	db.updateData(data);</span><br><span class="line"> 	Thread.sleep(<span class="number">500</span>);</span><br><span class="line"> 	redis.delKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1. 具体的步骤就是：</strong></p><p>1）先删除缓存</p><p>2）再写数据库</p><p>3）休眠500毫秒</p><p>4）再次删除缓存</p><p><strong>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</strong></p><p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p><p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p><p><strong>2.设置缓存过期时间</strong></p><p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p><p><strong>3.如何写完数据库后，再次删除缓存成功？</strong></p><p><em>上述的方案有一个缺点，那就是操作完数据库后，由于种种原因删除缓存失败，这时，可能就会出现数据不一致的情况。这里，我们需要提供一个保障重试的方案。</em></p><p>​ <strong><em>1、方案一：</em></strong></p><p>延迟双删，添加重试机制。<br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210203142333.jpeg" alt=""></p><p>​ （1）更新数据库数据；</p><p>​ （2）缓存因为种种问题删除失败；</p><p>​ （3）将需要删除的key发送至消息队列；</p><p>​ （4）自己消费消息，获得需要删除的key；</p><p>​ （5）继续重试删除操作，直到成功。</p><p>​ <font color="red"><strong>然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。</strong></font></p><p>​ <strong><em>2、方案二：</em></strong></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210203142328.jpeg" alt=""></p><p>​ （1）更新数据库数据；</p><p>​ （2）数据库会将操作信息写入binlog日志当中；</p><p>​ （3）订阅程序提取出所需要的数据以及key；</p><p>​ （4）另起一段非业务代码，获得该信息；</p><p>​ （5）尝试删除缓存操作，发现删除失败；</p><p>​ （6）将这些信息发送至消息队列；</p><p>​ （7）重新从消息队列中获得该数据，重试操作。</p><p>以上方案都是在业务中经常会碰到的场景，可以依据业务场景的复杂和对数据一致性的要求来选择具体的方案。</p><hr><h4 id="二、异步更新缓存-基于订阅binlog的同步机制"><a href="#二、异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="二、异步更新缓存(基于订阅binlog的同步机制)"></a><strong>二、异步更新缓存(基于订阅binlog的同步机制)</strong></h4><p>​ <strong>1.技术整体思路：</strong></p><p>​ MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p><p>​ <strong>1）读Redis</strong>：热数据基本都在Redis</p><p>​ <strong>2）写MySQL</strong>:增删改都是操作MySQL</p><p>​ <strong>3）更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</p><p>​ <strong>2.Redis更新</strong></p><p>​ <strong>1）数据操作主要分为两大块：</strong></p><ul><li>一个是全量(将全部数据一次写入到redis)</li><li>一个是增量（实时更新）</li></ul><p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p><p>​ <strong>2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p><p>​ 这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p><p>​ 其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p><p>​ 这里可以结合使用 <strong>Canal ( 阿里的一款开源框架 )</strong>，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p><blockquote><p>相关的中间件有：</p><ol><li><strong>canal</strong>：是阿里巴巴旗下的一款开源项目，纯Java开发,基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL。</li><li><strong>otter</strong>：也是阿里开源的一个分布式数据库同步系统，尤其是在跨机房数据库同步方面，有很强大的功能。它是基于数据库增量日志解析，实时将数据同步到本机房或跨机房的mysql/oracle数据库。</li></ol><p><strong>以上两者的区别在于</strong>：</p><p><strong>otter</strong>目前嵌入式依赖canal，部署为同一个jvm，目前设计为不产生<code>Relay Log</code>。 <a href="https://blog.csdn.net/weixin_32639437/article/details/113333981" target="_blank" rel="noopener">MySql的日志文件有哪些？</a></p><p><strong>otter</strong>目前允许自定义同步逻辑，解决各类需求。</p></blockquote><p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。</p><p>​ <strong>3.该方案优缺点</strong></p><p>​ 该方案优点：能保证一致；该方案缺点：数据库中间件的成本较高</p><hr><h4 id="三、如何保证缓存和数据库一致性？"><a href="#三、如何保证缓存和数据库一致性？" class="headerlink" title="三、如何保证缓存和数据库一致性？"></a>三、如何保证缓存和数据库一致性？</h4><p>没有办法做到绝对的一致性，这是由CAP理论决定的，缓存系统适用的场景就是非强一致性的场景，所以，我们得委曲求全，可以去做到BASE理论中说的最终一致性。<br>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p><p><strong>如果条件允许的情况下最好推荐大家使用开源的中间件去保证缓存和数据库的一致性；</strong></p><p>以上就是Redis和MySQL数据一致性详解，相关的MySQL数据库主从同步一致性可以参考：</p><p><a href="https://www.cnblogs.com/syncnavigator/p/10189655.html" target="_blank" rel="noopener">《高并发架构系列：数据库主从同步的3种一致性方案实现，优劣比较》</a></p><p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">《<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析》</a></a></p><p><a href="https://juejin.cn/post/6965876741160042532" target="_blank" rel="noopener">《关于缓存一致性问题，我是这么回答的！》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存模型</title>
    <url>/post/c2d38e6e.html</url>
    <content><![CDATA[<blockquote><p>JVM的内存模型是java语言绕不开的一个话题。要进行java的性能调优，首先就要了解其内存模型。本篇文章简单介绍JVM内存模型的概念，结构和对应的参数设置 ~</p></blockquote><a id="more"></a><h3 id="一、JVM内存结构"><a href="#一、JVM内存结构" class="headerlink" title="一、JVM内存结构"></a>一、JVM内存结构</h3><p>JVM的内存空间分为3大部分，分别是堆内存、方法区和栈内存。其中栈内存可以再细分为java虚拟机栈和本地方法栈。堆内存可以划分为新生代和老年代。新生代中还可以再次划分为Eden区、From Survivor区和To Survivor区。划分出来的各个区，分别保存不同的数据，并且在一般情况下，其采取的内存回收策略也是不同的。</p><h3 id="二、JVM内存区域划分"><a href="#二、JVM内存区域划分" class="headerlink" title="二、JVM内存区域划分"></a>二、JVM内存区域划分</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/49b9965bd1dbbeb7532bc0462cb40c22.png" alt="JVM内存区域划分"></p><h4 id="1-程序计数器-Program-Counter-Register"><a href="#1-程序计数器-Program-Counter-Register" class="headerlink" title="1.程序计数器 (Program Counter Register)"></a><strong>1.程序计数器 (Program Counter Register)</strong></h4><p>​ 程序计数器，也有称作为PC寄存器；</p><ol><li>是一块很小的内存空间。线程私有的，每条线程都要有一个独立的程序计数器。</li><li>唯一一个没有内存溢出区域。</li><li>执行 Java 方法时，程序计数器记录的是字节码指令的地址；执行本地方法时，为空。</li></ol><h4 id="2-虚拟机栈-VM-Stack"><a href="#2-虚拟机栈-VM-Stack" class="headerlink" title="2. 虚拟机栈 (VM Stack)"></a><strong>2. 虚拟机栈 (VM Stack)</strong></h4><p>​ 虚拟机栈（Java Vitual Machine Stack），也称作Java栈，也就是我们常常所说的栈。</p><ol><li>Java 虚拟机栈是线程私有， 生命周期与线程相同， 创建线程的时候就会 创建一个 java 虚拟机栈 。</li><li>虚拟机执行 java 程序的时候， 每个方法都会创建一个栈帧， 栈帧存放在 java虚拟机栈中， 通过压栈出栈的方式进行方法调用。<br>栈帧又分为一下几个区域： 局部变量表、 操作数栈、 动态连接、 方法出口等。</li><li>每一个方法从调用直至执行完成的过程，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</li><li>描述 java 方法执行的内存模型。</li></ol><h4 id="3-本地方法栈-Native-Method-Stack"><a href="#3-本地方法栈-Native-Method-Stack" class="headerlink" title="3. 本地方法栈 (Native Method Stack)"></a><strong>3. 本地方法栈 (Native Method Stack)</strong></h4><ol><li>本地方法栈（Native Method Stacks） 与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码） 服务， 而本地方法栈则是为虚拟机使用到的 Native 方法服务 。</li><li>本地方法栈深度溢出或者栈扩展失败时，也会分别抛出 StackOverflowError 和 OutOfMemoryError异常。</li></ol><h4 id="4-方法区-Method-Area"><a href="#4-方法区-Method-Area" class="headerlink" title="4. 方法区(Method Area)"></a><strong>4. 方法区(Method Area)</strong></h4><ol><li>方法区也称“永久代”， 它用于存储被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，永久代是一片连续的堆空间。</li><li>运行时常量池(Runtime Constant Pool)是方法区的一部分，编译期生成的各种字面量与符号引用也在其中</li><li>随着 JDK8 的到来， 撤销永久代，引入元空间。</li></ol><h4 id="5-堆-Heap"><a href="#5-堆-Heap" class="headerlink" title="5. 堆(Heap)"></a>5. <strong>堆(Heap)</strong></h4><ol><li><p>Java 堆（Java Heap） 是 Java 虚拟机所管理的内存中最大的一块。</p></li><li><p>堆是被所有线程共享的区域， 是在虚拟机启动时创建的。 堆里面存放的都是对象的实例（new出来的对象都存在堆中） 。</p></li><li><p>此内存区域的唯一目的就是存放对象实例（new 的对象） ， 几乎所有的对象实例都在这里分配内存，虚拟机规范规定，创建的对象和数组都应当保存在堆内存中。</p></li><li><p>垃圾收集最重要的内存区域。</p></li><li><p>一般大小可扩展，通过 -Xms 和 -Xmx 设定最小值和最大值，无法扩展时抛出 OutOfMemoryError 异常</p><blockquote><p><strong>静态变量存放在 JVM 运行时的哪块内存？</strong></p><p>HotSpot VM（称为默认虚拟机），<u>JDK 6</u> 及之前版本静态变量存放在<u>永久代(Permanent Generation）</u>，使用永久代实现的方法区)中；<br><u>JDK 7 开始</u>，<u>静态变量</u>改存放到 java.lang.Class 对象的末尾，即<u>（堆 Heap）</u>中。虚拟机规范中，是把方法区描述为堆的一个逻辑部分，以上的差异只是实现细节的不同。</p></blockquote><p>我们平常所说的垃圾回收， 主要回收的就是堆区。 更细一点划分新生代又可划分为 Eden 区和 2 个 Survivor 区（FromSurvivor 和 To Survivor），由颜⾊可以看出，<strong>Jdk1.8之前，堆内存被分为新⽣代，⽼年代，永久代；Jdk 1.8及以后堆内存被分成了新⽣代和⽼年代。新⽣代的区域⼜分为eden区，S0区，S1区，默认⽐例是8:1:1，元空间可以理解为直接的物理内存。</strong>如下图 。</p></li></ol><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210203174728.png" alt="不同JDK版本下堆内存划分"><br><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20201012235443705.jpg" alt="堆内存模型划分"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>GC垃圾回收</title>
    <url>/post/fca96bce.html</url>
    <content><![CDATA[<blockquote><p>GC垃圾回收学习与梳理 ~</p></blockquote><a id="more"></a><h3 id="一、什么是垃圾"><a href="#一、什么是垃圾" class="headerlink" title="一、什么是垃圾"></a>一、什么是垃圾</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/img_1.png" alt=""></p><h3 id="二、垃圾回收"><a href="#二、垃圾回收" class="headerlink" title="二、垃圾回收"></a>二、垃圾回收</h3><p>在垃圾回收过程中如何判断一个对象是否是垃圾，有两种算法。</p><ol><li><p>一种是<strong>引用记数法</strong></p><p>引用记数法是早期垃圾回收器中使用的算法，每一个对象维护一个该对象被引用的记数，每引用一次，记数加1，每减少引用1次，引用减1，当引用为0时，表示该对象不再被引用，可以作为垃圾被清除。但是引用记数法有一个最致命的问题，就是无法解决循环引用的问题。</p></li><li><p>一种是<strong>根可达算法</strong></p><p>根可达算法是通过从GCRoots出发，找出内存中的引用链，那么链中的对象表示可达，即不能作为被垃圾回收的。引用链之外的对象即可作为垃圾回收。Java中使用的是可达性分析法。</p></li></ol><h3 id="三、GCRoots-有哪些？"><a href="#三、GCRoots-有哪些？" class="headerlink" title="三、GCRoots 有哪些？"></a>三、GCRoots 有哪些？</h3><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li></ol><ol start="2"><li>方法区中类静态属性引用的对象；</li></ol><ol start="3"><li>方法区中常量引用的对象；</li></ol><ol start="4"><li>本地方法栈中JNI（即一般说的native方法）中引用的对象；</li></ol><blockquote><p>为了解决引用计数法的循环引用问题，Java使用了可达性分析的方法。所谓<code>GCroots</code>，就是一组必须活跃的引用。<br>基本思路就是通过一系列名为”GCRoots”的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GCRoots没有任何引用链相连时，则说明此对象不可用。也即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，没有被遍历到的就自然被判定为死亡。</p></blockquote><h3 id="三、常见的垃圾回收算法"><a href="#三、常见的垃圾回收算法" class="headerlink" title="三、常见的垃圾回收算法"></a>三、常见的垃圾回收算法</h3><ol><li><p><strong>标记清除</strong> - 位置不连续, 产生碎片</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20210119133912534.png" style="zoom:47%"></li><li><p><strong>拷贝算法</strong> - 没有碎片，浪费空间</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20210119135321186.png" style="zoom:50%"></li><li><p><strong>标记压缩</strong> - 没有碎片，效率偏低</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20210119135527995.png" style="zoom:49%"></li><li><p><strong>分代收集算法</strong></p><p><strong>分代收集算法就是目前虚拟机使用的回收算法。</strong>在不同年代使用不同的算法，从而使用最合适的算法，<strong>新生代</strong>存活率低，可以使用<strong>复制算法</strong>。而<strong>老年代</strong>对象存活率高，没有额外空间对它进行分配担保，所以只能使用<strong>标记清除或者标记整理算法</strong>。</p></li></ol><h3 id="四、堆内存逻辑分区"><a href="#四、堆内存逻辑分区" class="headerlink" title="四、堆内存逻辑分区"></a>四、堆内存逻辑分区</h3><p>JVM将堆内存分为了三部分：新生代(Young Generation)，老年代(Old Generation)，永久代(Permanent Generation)。其中新生代又分为三部分：伊甸园区(Eden)，和两个幸存区S0和S1。</p><blockquote><p>注：<code>JDK1.8</code>之后，Java官方的<code>HotSpot JVM</code>去掉了永久代，取而代之的是元数据区<code>Metaspace</code>。<code>Metaspace</code>使用的是本地内存，而不是堆内存，也就是说在默认情况下<code>Metaspace</code>的大小只与本地内存的大小有关。因此<code>JDK1.8</code>之后，就见不到<code>java.lang.OutOfMemoryError: PermGen space</code>这种由于永久代空间不足导致的内存溢出的问题了。</p></blockquote><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210507144124.png" alt="堆内存逻辑分区"></p><h3 id="五、GC-何时被触发"><a href="#五、GC-何时被触发" class="headerlink" title="五、GC 何时被触发"></a>五、GC 何时被触发</h3><h4 id="什么情况下会出现-Young-GC？"><a href="#什么情况下会出现-Young-GC？" class="headerlink" title="什么情况下会出现 Young GC？"></a>什么情况下会出现 Young GC？</h4><ul><li>对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 。</li></ul><h4 id="什么情况下回出现-Full-GC？"><a href="#什么情况下回出现-Full-GC？" class="headerlink" title="什么情况下回出现 Full GC？"></a>什么情况下回出现 Full GC？</h4><ul><li>在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。</li><li>大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。</li><li>显式调用 <code>System.gc()</code> 方法时。</li></ul><h3 id="六、GC-相关的概念"><a href="#六、GC-相关的概念" class="headerlink" title="六、GC 相关的概念"></a>六、GC 相关的概念</h3><ul><li><p><strong>MinorGC/YoungGC/YGC</strong>：对新生代堆进行<code>gc</code>。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小，一般回收速度也比较快。</p></li><li><p><strong>MajorGC/FullGC/FGC</strong>：指发生在老年代的 GC，出现了 MajorGC，经常会伴随至少一次的 MinorGC，全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发<code>fgc</code>，有时10天或一周左右会有一次。</p></li><li><p><strong>一般垃圾回收的过程：</strong></p><ol><li><strong>新生成的对象首先放到<code>Eden</code>区，当<code>Eden</code>区满了会触发<code>YGC</code></strong></li><li><strong><code>YGC</code>回收之后，<code>Eden</code>中大多数的对象会被回收，活着的进入<code>S0</code></strong></li><li><strong>再次<code>YGC</code>，活着的对象<code>eden + S0 -&gt; S1</code></strong></li><li><strong>再次<code>YGC</code>，<code>eden + S1 -&gt; S0</code></strong>（ <em>第2、3步，对象会在<code>S0</code>和<code>S1</code>之间反复交换，年龄也会越来越大，当对象达到年龄上限时，会被晋升到老年代。这个年龄上限默认是15，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置</em> ）</li><li><strong>年龄足够 -&gt; 老年代</strong> （<em>年轻代对象年龄达到了上限15，被转移到了老年代</em>）</li><li><strong>大对象的话，年轻代装不下 -&gt; 老年代</strong>（ <em>大对象直接晋升，大对象会跨过年轻代直接分配到老年代。可以通过<code>-XX:PretenureSizeThreshold</code>参数设置对象大小。如果参数被设置成<code>5MB</code>，超过<code>5MB</code>的大对象会直接分配到老年代。这样做的目的，是为了避免大对象在Eden区及两个Survivor区之间大量的内存复制，大对象的内存复制耗时比普通对象要高很多</em>）</li><li><strong>动态对象年龄判定</strong>（<em>如果在<code>Survivor</code>空间中相同年龄对象大小的总和大于<code>Survivor</code>空间的一半，年龄大于或等于该年龄的对象会直接进入老年代，而不用等到<code>MaxTenuringThreshold</code>中设置的年龄上限，会直接进入老年代</em>）</li><li><strong>老年代满了<code>FGC/Full GC</code></strong></li></ol></li><li><p><a href="https://www.modb.pro/db/26526" target="_blank" rel="noopener">《小白是怎么搞懂GC全过程？》</a></p></li></ul><ul><li><p><code>JVM</code>调优指什么? GC Tuning (Generation)</p><ol><li>尽量减少<code>FGC</code></li></ol></li></ul><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210429170508.png" alt="图解GC流程" style="zoom:50%"><h3 id="七、常见的垃圾回收器"><a href="#七、常见的垃圾回收器" class="headerlink" title="七、常见的垃圾回收器"></a>七、常见的垃圾回收器</h3><blockquote><p>垃圾回收器的发展路线，是随着内存越来越大的过程而演进，从分代算法演化到不分代算法。<br>1 、Serial算法 几十兆<br>2、Parallel算法 几个G<br>3、CMS 几十个G - 承上启下，开始并发回收 -三色标记；</p><p>JDK诞生 Serial追随 提高效率，诞生了PS，为了配合CMS，诞生了PN，CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，但是CMS毛病较多，因此目前任何一个JDK版本默认是CMS，并发垃圾回收是因为无法忍受STW。</p></blockquote><p>​ 目前JAVA用到以下10种垃圾回收器：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20210120194154785.png" alt="JAVA的10种垃圾回收器"></p><ol><li><p><strong>Serial</strong> 年轻代 串行回收；</p></li><li><p><strong>ParallelScavenge</strong> 年轻代 并行回收； <strong>JDK1.8</strong> 默认的垃圾回收器是：<strong>ParallelScavenge+ParallelOld</strong></p></li><li><p><strong>ParNew</strong> 年轻代 配合CMS的并行回收；</p></li><li><p><strong>SerialOld</strong>；</p></li><li><p><strong>ParallelOld</strong>；</p></li><li><p><strong>ConcurrentMarkSweep</strong>；</p></li><li><p><strong>CMS</strong></p><p>是老年代的，并发的， 在垃圾回收的时候，可以和应用程序同时运行，降低STW的时间(200毫秒)；Stop-The-World机制简称STW，是在执行垃圾收集算法时，<a href="http://www.jb51.net/list/list_207_1.htm" target="_blank" rel="noopener">Java</a>应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。<br>CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定<br>CMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收<br>算法：三色标记 + Incremental Update</p></li><li><p><strong>G1</strong>；(降低STW的时间10毫秒) – <code>04</code>年正式提出，<code>12</code>开始正式支持，在<code>17</code>年作为<code>JDK9</code>默认的垃圾处理器。<br>算法：三色标记 + SATB</p></li><li><p><strong>ZGC</strong>；<em>目前史上最厉害的回收器，在<code>JDK11</code>中引入；</em> (降低STW的时间1毫秒) PK C++，比C++还要强；<br>算法：ColoredPointers + LoadBarrier</p></li><li><p><strong>Shenandoah</strong><br>算法：ColoredPointers + WriteBarrier</p></li><li><p><strong>Eplison</strong></p></li></ol><h3 id="八、GC-日志"><a href="#八、GC-日志" class="headerlink" title="八、GC  日志"></a>八、GC 日志</h3><p><code>GC</code>日志是替换的不是追加的。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过以下的命JVM令参数来设置GC日志的输出：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出GC日志</span></span><br><span class="line">-XX:+PrintGC</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出GC的详细日志</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出GC的时间戳（以基准时间的形式）</span></span><br><span class="line">-XX:+PrintGCTimeStamps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）</span></span><br><span class="line">-XX:+PrintGCDateStamps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在进行GC的前后打印出堆的信息</span></span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line"><span class="meta">#</span><span class="bash"> 日志文件的输出路径</span></span><br><span class="line">-Xloggc:…/logs/gc.log</span><br></pre></td></tr></table></figure><blockquote><p>GC日志分析工具：<a href="http://gceasy.io/" target="_blank" rel="noopener">GCeasy</a>、GCViewer</p></blockquote><h3 id="九、优秀资料"><a href="#九、优秀资料" class="headerlink" title="九、优秀资料"></a>九、优秀资料</h3><p><a href="https://mp.weixin.qq.com/s/I1fp89Ib2Na1-vjmjSpsjQ" target="_blank" rel="noopener">《线上服务的FGC问题排查，看这篇就够了！》</a><br><a href="https://www.toutiao.com/a6881508437667086856/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1620365664&app=news_article_social&utm_source=weixin&utm_medium=toutiao_ios&use_new_style=1&req_id=202105071334230102120351953309B306&share_token=8A4BF30E-510F-417C-9D9F-346D77EEC9E7&group_id=6881508437667086856" target="_blank" rel="noopener">《JVM常见线上问题 → CPU 100%、内存泄露 问题排查》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>开源推荐</title>
    <url>/post/6662203c.html</url>
    <content><![CDATA[<blockquote><p>开源推荐项目记载，懂得分享，才会成功，加油 ~</p></blockquote><a id="more"></a> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/2265276667.png"><h2 id="①开源技术"><a href="#①开源技术" class="headerlink" title="①开源技术"></a>①开源技术</h2><ol><li><strong><code>SpringBlade</code></strong> 完整的线上解决方案(企业开发必备) <a href="https://github.com/chillzhuang/SpringBlade" target="_blank" rel="noopener">https://github.com/chillzhuang/SpringBlade</a></li><li><strong><code>Pig</code></strong> 宇宙最强微服务认证授权脚手架(架构师必备) <a href="https://github.com/pigxcloud/pig" target="_blank" rel="noopener">https://github.com/pigxcloud/pig</a></li><li><strong><code>lyb-geek</code></strong> <a href="https://github.com/lyb-geek/springboot-learning" target="_blank" rel="noopener">https://github.com/lyb-geek/springboot-learning</a></li><li><strong><code>spring-boot-demo</code></strong> 深度学习并实战 spring boot 的项目: <a href="https://github.com/xkcoding/spring-boot-demo" target="_blank" rel="noopener">https://github.com/xkcoding/spring-boot-demo</a></li><li><strong><code>知了一笑</code></strong> <a href="https://gitee.com/cicadasmile" target="_blank" rel="noopener">https://gitee.com/cicadasmile</a></li><li><strong><code>OCP&amp;cp</code></strong> <a href="https://gitee.com/owenwangwen/open-capacity-platform" target="_blank" rel="noopener">https://gitee.com/owenwangwen/open-capacity-platform</a></li><li><strong><code>开源oschina 打造springboot框架的极致细腻的脚手架</code></strong> <a href="https://gitee.com/bdj/SpringBoot_v2" target="_blank" rel="noopener">https://gitee.com/bdj/SpringBoot_v2</a></li><li><strong><code>小柒2012 文档总结以及秒杀架构项目</code></strong> <a href="https://gitee.com/52itstyle/spring-boot-seckill" target="_blank" rel="noopener">https://gitee.com/52itstyle/spring-boot-seckill</a></li><li><strong><code>zhengqingya-SpringBoot整合案例</code></strong> <a href="https://gitee.com/zhengqingya/java-workspace.git" target="_blank" rel="noopener">https://gitee.com/zhengqingya/java-workspace.git</a></li><li><strong><code>Stylefeng开源技术 后台管理系统整合案例</code></strong> <a href="https://gitee.com/stylefeng" target="_blank" rel="noopener">https://gitee.com/stylefeng</a></li><li><strong><code>微服务化开发平台 cloud-platform</code></strong> <a href="https://gitee.com/geek_qi/cloud-platform" target="_blank" rel="noopener">https://gitee.com/geek_qi/cloud-platform</a></li><li><strong><code>陌溪 蘑菇博客</code></strong> <a href="https://gitee.com/moxi159753/mogu_blog_v2" target="_blank" rel="noopener">https://gitee.com/moxi159753/mogu_blog_v2</a></li></ol><h2 id="②面试文档"><a href="#②面试文档" class="headerlink" title="②面试文档"></a>②面试文档</h2><ol><li><strong><code>面试必备各种文档</code></strong> <a href="https://github.com/frank-lam/fullstack-tutorial" target="_blank" rel="noopener">https://github.com/frank-lam/fullstack-tutorial</a></li><li><strong><code>面试必备Awesome-Collector</code></strong> <a href="https://github.com/P-P-X/awesome-collector" target="_blank" rel="noopener">https://github.com/P-P-X/awesome-collector</a></li><li><strong><code>陌溪的学习笔记</code></strong> <a href="https://gitee.com/moxi159753/LearningNotes" target="_blank" rel="noopener">https://gitee.com/moxi159753/LearningNotes</a></li><li><strong><code>CS-Notes</code></strong> <a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">https://github.com/CyC2018/CS-Notes</a></li><li><strong><code>互联网 Java 工程师进阶知识完全扫盲</code></strong> <a href="https://github.com/doocs/advanced-java" target="_blank" rel="noopener">https://github.com/doocs/advanced-java</a></li><li><strong><code>小浩算法是一套针对小白的完整的算法训练流程！</code></strong> <a href="https://github.com/geekxh/hello-algorithm" target="_blank" rel="noopener">https://github.com/geekxh/hello-algorithm</a></li><li><strong><code>秒杀系统设计与实现.互联网工程师进阶与分析</code></strong> <a href="https://github.com/qiurunze123/miaosha" target="_blank" rel="noopener">https://github.com/qiurunze123/miaosha</a></li><li><strong><code>JavaFamily</code></strong> <a href="https://github.com/AobingJava/JavaFamily" target="_blank" rel="noopener">https://github.com/AobingJava/JavaFamily</a></li></ol><h2 id="③支付相关"><a href="#③支付相关" class="headerlink" title="③支付相关"></a>③支付相关</h2><ol><li><strong><code>IJPay 支付 SDK 让支付触手可及</code></strong> <a href="https://gitee.com/javen205/IJPay" target="_blank" rel="noopener">https://gitee.com/javen205/IJPay</a></li><li><strong><code>小柒2012 Spring-boot-pay</code></strong> 支付 SDK 让支付触手可及：<a href="https://gitee.com/52itstyle/spring-boot-pay" target="_blank" rel="noopener">https://gitee.com/52itstyle/spring-boot-pay</a></li><li><strong><code>Jeepay</code></strong> <a href="https://gitee.com/jeequan/jeepay" target="_blank" rel="noopener">https://gitee.com/jeequan/jeepay</a></li></ol><h2 id="④登录相关"><a href="#④登录相关" class="headerlink" title="④登录相关"></a>④登录相关</h2><ol><li><strong><code>JustAuth第三方登录</code></strong> 史上最全的整合第三方登录的开源库 <a href="https://gitee.com/yadong.zhang/JustAuth" target="_blank" rel="noopener">https://gitee.com/yadong.zhang/JustAuth</a></li></ol><h2 id="⑤框架相关"><a href="#⑤框架相关" class="headerlink" title="⑤框架相关"></a>⑤框架相关</h2><ol><li><strong><code>Mica SpringBoot 微服务高效开发工具集</code></strong> <a href="https://gitee.com/596392912/mica" target="_blank" rel="noopener">https://gitee.com/596392912/mica</a></li><li>★<strong><code>microservices-platform</code></strong> <a href="https://gitee.com/zlt2000/microservices-platform" target="_blank" rel="noopener">https://gitee.com/zlt2000/microservices-platform</a></li><li>★<strong><code>SpringBlade</code></strong> <a href="https://gitee.com/smallc/SpringBlade" target="_blank" rel="noopener">https://gitee.com/smallc/SpringBlade</a></li><li><strong><code>MateCloud</code></strong> <a href="https://gitee.com/matevip/matecloud" target="_blank" rel="noopener">https://gitee.com/matevip/matecloud</a></li><li><strong><code>jeecg-boot</code></strong> <a href="https://github.com/jeecgboot/jeecg-boot" target="_blank" rel="noopener">https://github.com/jeecgboot/jeecg-boot</a></li><li><strong><code>凤凰架构</code></strong> <a href="http://icyfenix.cn/" target="_blank" rel="noopener">http://icyfenix.cn/</a></li></ol><h2 id="⑥电子书"><a href="#⑥电子书" class="headerlink" title="⑥电子书"></a>⑥电子书</h2><ol><li><strong><code>Itdevbooks</code></strong> <a href="https://github.com/itdevbooks/pdf" target="_blank" rel="noopener">https://github.com/itdevbooks/pdf</a></li></ol><h2 id="⑦小工具"><a href="#⑦小工具" class="headerlink" title="⑦小工具"></a>⑦小工具</h2><ol><li><strong><code>Web开发者助手FeHelper</code></strong> <a href="https://www.baidufe.com/fehelper/index/index.html" target="_blank" rel="noopener">https://www.baidufe.com/fehelper/index/index.html</a></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>OpenSource</category>
      </categories>
      <tags>
        <tag>OpenSource</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池原理</title>
    <url>/post/52aa52dd.html</url>
    <content><![CDATA[<blockquote><p>Java线程池详解与原理介绍，记录 ~ ~</p></blockquote><a id="more"></a><h3 id="一、线程池的优势"><a href="#一、线程池的优势" class="headerlink" title="一、线程池的优势"></a>一、线程池的优势</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>当我们需要一个新的线程执行任务时，可能会直接创建一个</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">	<span class="comment">// do something</span></span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>在业务量较少的情况，这样也没什么太大问题。</p><p><strong>如果任务频繁的话</strong></p><ol><li><p>频繁的创建和销毁线程是十分消耗性能的，甚至可能创建和销毁线程所用时间大于任务本身执行所用时间。</p></li><li><p>如果业务量非常大，可能会占用过多的资源，导致整个服务由于资源不足而宕机。</p><p><u>这里就可以引入线程池。 线程池，就是维护了若干个线程，当需要执行任务时，直接调用其中某一个线程来执行即可。</u></p></li></ol><h4 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a><strong>线程池的优点</strong></h4><ol><li>降低性能消耗：重复利用已创建的线程，节省了频繁创建和销毁带来的性能损耗。</li><li>提示任务效率：任务来了分配一个线程就可以立即干活，而不用等待线程重新创建。</li><li>更好的管控：线程池可以控制线程数，避免过多消耗服务器资源，亦更方便调优和监控。</li></ol><h3 id="二、线程池参数解释"><a href="#二、线程池参数解释" class="headerlink" title="二、线程池参数解释"></a>二、线程池参数解释</h3><p>先看看线程池核心构造方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,  // 维护线程的最小核心线程数量.</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize, // 维护线程的最大线程数量.</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime, // 非核心线程的空闲时间.</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit, // 非核心线程的空闲时间的时间单位.</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue, // 任务队列.</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory, // 线程工厂用于创建新线程.</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler // 拒绝策略.</span></span></span><br><span class="line"><span class="function"><span class="params">                             )</span> </span>&#123;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单介绍下参数</p><ol><li><strong>corePoolSize</strong>（维护线程的最小核心线程数量）：当向线程池提交一个任务时，若线程池已创建的线程数小于corePoolSize，即便此时存在空闲线程，也会通过创建一个新线程来执行该任务，直到已创建的线程数大于或等于corePoolSize时，（除了利用提交新任务来创建和启动线程（按需构造），也可以通过 prestartCoreThread() 或 prestartAllCoreThreads() 方法来提前启动线程池中的基本线程。）</li><li><strong>maximumPoolSize</strong>（线程池维护线程的最大数量）：线程池所允许的最大线程个数。当队列满了，且已创建的线程数小于maximumPoolSize，则线程池会创建新的线程来执行任务。另外，对于无界队列，可忽略该参数。</li><li><strong>keepAliveTime</strong>（非核心线程的空闲时间）当线程池中线程数大于核心线程数时，线程会根据keepAliveTime的值进行活性检查，线程的空闲时间如果超过线程存活时间，那么这个线程就会被销毁，直到线程池中的线程数小于等于核心线程数。</li><li><strong>unit</strong> 线程池维护线程所允许的空闲时间的单位</li><li><strong>workQueue</strong> 任务队列（线程安全的阻塞队列）：用于传输和保存等待执行任务的阻塞队列。<ol><li>线程池里的 <code>BlockingQueue</code>，<strong>阻塞队列</strong>，事实上在消费者生产者问题里的管程法实现，我们的策略也是类似阻塞队列的，用它来做一个缓存池的作用。</li><li><strong>阻塞队列</strong>：任意时刻，不管并发有多高，永远保证<strong>只有一个线程能够进行队列的入队或出队操作</strong>。也就意味着他是能够保证线程安全的。</li><li>阻塞队列分为有界和无界队列，理论上来说一个是队列的size有固定，另一个是无界的。对于有界队列来说，如果队列存满，只能出队了，入队操作就只能阻塞。</li><li>在 <code>java</code>并发包里，阻塞队列的实现有很多：<ol><li><strong><code>ArrayBlockingQueue</code></strong>：由数组结构组成的有界阻塞队列；</li><li><strong><code>LinkedBlockingQueue</code></strong>：由链表结构组成的有界阻塞队列（大小默认值为<code>Integer.MAX_VALUE</code>）；</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列；</li><li><code>DelayQueue</code>：使用优先级队列实现的延迟无界阻塞队列；</li><li><code>SynchronousQueue</code>：不存储元素的阻塞队列，相当于只有一个元素；</li><li><code>LinkedTransferQueue</code>：链表组成的无界阻塞队列；</li><li><code>LinkedBlockingDeque</code>：链表组成的双向阻塞队列。</li></ol></li></ol></li><li><strong>threadFactory</strong>（线程工厂） 用于创建新线程。threadFactory创建的线程也是采用new Thread()方式，threadFactory创建的线程名都具有统一的风格：pool-m-thread-n（m为线程池的编号，n为线程池内的线程编号）。</li><li><strong>RejectedExecutionHandler handler</strong>（线程拒绝策略）：当线程池和队列都满了，再加入线程会执行此策略。<br>A. <code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常<strong>（默认）</strong>。<br>B. <code>ThreadPoolExecutor.DiscardPolicy</code>：丢弃任务，但是不抛出异常。<br>C. <code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新提交被拒绝的任务<br>D. <code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程（提交任务的线程）处理该任务</li></ol><h3 id="三、线程池执行原理"><a href="#三、线程池执行原理" class="headerlink" title="三、线程池执行原理"></a>三、线程池执行原理</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210420095431.png" alt=""></p><p>当一个任务通过execute(Runnable)方法添加到线程池时：</p><ol><li><p>如果此时线程池中的数量小于<code>corePoolSize</code>，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</p></li><li><p>如果此时线程池中的数量等于 <code>corePoolSize</code>，但是缓冲队列 <code>workQueue</code>未满，那么任务被放入缓冲队列。</p></li><li><p>如果此时线程池中的数量大于<code>corePoolSize</code>，缓冲队列 <code>workQueue</code>满，并且线程池中的数量小于<code>maximumPoolSize</code>，建新的线程来处理被添加的任务。</p></li><li><p>如果此时线程池中的数量大于<code>corePoolSize</code>，缓冲队列 <code>workQueue</code>满，并且线程池中的数量等于<code>maximumPoolSize</code>，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程<code>corePoolSize</code>、任务队列<code>workQueue</code>、最大线程<code>maximumPoolSize</code>，如果三者都满了，使用<code>handler</code>拒绝策略处理被拒绝的任务。</p></li></ol><p>当线程池中的线程数量大于 <code>corePoolSize</code>时，如果某线程空闲时间超过<code>keepAliveTime</code>，线程将被终止。这样，线程池可以动态的调整池中的线程数。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210823111652.png" alt=""></p><h3 id="四、线程池大小配置"><a href="#四、线程池大小配置" class="headerlink" title="四、线程池大小配置"></a>四、线程池大小配置</h3><h4 id="1、问题影响"><a href="#1、问题影响" class="headerlink" title="1、问题影响"></a>1、问题影响</h4><ul><li>如果设置的线程池数量太小，同一时间有大量任务/请求，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，CPU没有得到充分利用。</li><li>如果设置线程数量太大，大量线程可能会同时在争取 CPU 资源，会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。</li></ul><h4 id="2、最佳实践"><a href="#2、最佳实践" class="headerlink" title="2、最佳实践"></a>2、最佳实践</h4><p>适用面较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)</strong>： 任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)</strong>： 任务应用会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，可以多配置一些线程，具体的计算方法是 2N。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MultiThread</tag>
      </tags>
  </entry>
  <entry>
    <title>生成二维码工具</title>
    <url>/post/aeb006ac.html</url>
    <content><![CDATA[<blockquote><p>生成二维码，如此简单易用 ~</p></blockquote><a id="more"></a><h5 id="一、maven仓库引用"><a href="#一、maven仓库引用" class="headerlink" title="一、maven仓库引用"></a>一、maven仓库引用</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 生成二维码 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.google.zxing/javase --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="二、工具类记录"><a href="#二、工具类记录" class="headerlink" title="二、工具类记录"></a>二、工具类记录</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shuaizi.watermark.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.zxing.*;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.BufferedImageLuminanceSource;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.client.j2se.MatrixToImageWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.BitMatrix;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.common.HybridBinarizer;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.QRCodeWriter;</span><br><span class="line"><span class="keyword">import</span> com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.swing.filechooser.FileSystemView;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.FileSystems;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维码、条形码工具类</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 资料: https://wangmaoxiong.blog.csdn.net/article/details/83856391?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.control</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/12/25 20:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QRBarCodeUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * CODE_WIDTH：二维码宽度，单位像素</span></span><br><span class="line"><span class="comment">     * CODE_HEIGHT：二维码高度，单位像素</span></span><br><span class="line"><span class="comment">     * FRONT_COLOR：二维码前景色，0x000000 表示黑色</span></span><br><span class="line"><span class="comment">     * BACKGROUND_COLOR：二维码背景色，0xFFFFFF 表示白色</span></span><br><span class="line"><span class="comment">     * 演示用 16 进制表示，和前端页面 CSS 的取色是一样的，注意前后景颜色应该对比明显，如常见的黑白</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CODE_WIDTH = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CODE_HEIGHT = <span class="number">400</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRONT_COLOR = <span class="number">0x000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BACKGROUND_COLOR = <span class="number">0xFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成二维码 并 保存为图片：write(RenderedImage im,String formatName,File output)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codeContent        :二维码参数内容，如果是一个网页地址，如 https://www.baidu.com/ 则 微信扫一扫会直接进入此地址</span></span><br><span class="line"><span class="comment">     *                           如果是一些参数，如 1541656080837，则微信扫一扫会直接回显这些参数值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codeImgFileSaveDir :二维码图片保存的目录,如 D:/codes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName           :二维码图片文件名称，带格式,如 123.png</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createCodeToFile</span><span class="params">(String codeContent, File codeImgFileSaveDir, String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/** 参数检验*/</span></span><br><span class="line">            <span class="keyword">if</span> (codeContent == <span class="keyword">null</span> || <span class="string">""</span>.equals(codeContent.trim())) &#123;</span><br><span class="line">                System.out.println(<span class="string">"二维码内容为空，不进行操作..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            codeContent = codeContent.trim();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (codeImgFileSaveDir == <span class="keyword">null</span> || codeImgFileSaveDir.isFile()) &#123;</span><br><span class="line">                codeImgFileSaveDir = FileSystemView.getFileSystemView().getHomeDirectory();</span><br><span class="line">                System.out.println(<span class="string">"二维码图片存在目录为空，默认放在桌面..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!codeImgFileSaveDir.exists()) &#123;</span><br><span class="line">                codeImgFileSaveDir.mkdirs();</span><br><span class="line">                System.out.println(<span class="string">"二维码图片存在目录不存在，开始创建..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fileName == <span class="keyword">null</span> || <span class="string">""</span>.equals(fileName)) &#123;</span><br><span class="line">                fileName = <span class="keyword">new</span> Date().getTime() + <span class="string">".png"</span>;</span><br><span class="line">                System.out.println(<span class="string">"二维码图片文件名为空，随机生成 png 格式图片..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**com.google.zxing.EncodeHintType：编码提示类型,枚举类型</span></span><br><span class="line"><span class="comment">             * EncodeHintType.CHARACTER_SET：设置字符编码类型</span></span><br><span class="line"><span class="comment">             * EncodeHintType.ERROR_CORRECTION：设置误差校正</span></span><br><span class="line"><span class="comment">             *      ErrorCorrectionLevel：误差校正等级，L = ~7% correction、M = ~15% correction、Q = ~25% correction、H = ~30% correction</span></span><br><span class="line"><span class="comment">             *      不设置时，默认为 L 等级，等级不一样，生成的图案不同，但扫描的结果是一样的</span></span><br><span class="line"><span class="comment">             * EncodeHintType.MARGIN：设置二维码边距，单位像素，值越小，二维码距离四周越近</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            Map&lt;EncodeHintType, Object&gt; hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">            hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"UTF-8"</span>);</span><br><span class="line">            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);</span><br><span class="line">            hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * MultiFormatWriter:多格式写入，这是一个工厂类，里面重载了两个 encode 方法，用于写入条形码或二维码</span></span><br><span class="line"><span class="comment">             *      encode(String contents,BarcodeFormat format,int width, int height,Map&lt;EncodeHintType,?&gt; hints)</span></span><br><span class="line"><span class="comment">             *      contents:条形码/二维码内容</span></span><br><span class="line"><span class="comment">             *      format：编码类型，如 条形码，二维码 等</span></span><br><span class="line"><span class="comment">             *      width：码的宽度</span></span><br><span class="line"><span class="comment">             *      height：码的高度</span></span><br><span class="line"><span class="comment">             *      hints：码内容的编码类型</span></span><br><span class="line"><span class="comment">             * BarcodeFormat：枚举该程序包已知的条形码格式，即创建何种码，如 1 维的条形码，2 维的二维码 等</span></span><br><span class="line"><span class="comment">             * BitMatrix：位(比特)矩阵或叫2D矩阵，也就是需要的二维码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            MultiFormatWriter multiFormatWriter = <span class="keyword">new</span> MultiFormatWriter();</span><br><span class="line">            BitMatrix bitMatrix = multiFormatWriter.encode(codeContent, BarcodeFormat.QR_CODE, CODE_WIDTH, CODE_HEIGHT, hints);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**java.awt.image.BufferedImage：具有图像数据的可访问缓冲图像，实现了 RenderedImage 接口</span></span><br><span class="line"><span class="comment">             * BitMatrix 的 get(int x, int y) 获取比特矩阵内容，指定位置有值，则返回true，将其设置为前景色，否则设置为背景色</span></span><br><span class="line"><span class="comment">             * BufferedImage 的 setRGB(int x, int y, int rgb) 方法设置图像像素</span></span><br><span class="line"><span class="comment">             *      x：像素位置的横坐标，即列</span></span><br><span class="line"><span class="comment">             *      y：像素位置的纵坐标，即行</span></span><br><span class="line"><span class="comment">             *      rgb：像素的值，采用 16 进制,如 0xFFFFFF 白色</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(CODE_WIDTH, CODE_HEIGHT, BufferedImage.TYPE_INT_BGR);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; CODE_WIDTH; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; CODE_HEIGHT; y++) &#123;</span><br><span class="line">                    bufferedImage.setRGB(x, y, bitMatrix.get(x, y) ? FRONT_COLOR : BACKGROUND_COLOR);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**javax.imageio.ImageIO java 扩展的图像IO</span></span><br><span class="line"><span class="comment">             * write(RenderedImage im,String formatName,File output)</span></span><br><span class="line"><span class="comment">             *      im：待写入的图像</span></span><br><span class="line"><span class="comment">             *      formatName：图像写入的格式</span></span><br><span class="line"><span class="comment">             *      output：写入的图像文件，文件不存在时会自动创建</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 即将保存的二维码图片文件*/</span></span><br><span class="line">            File codeImgFile = <span class="keyword">new</span> File(codeImgFileSaveDir, fileName);</span><br><span class="line">            ImageIO.write(bufferedImage, <span class="string">"png"</span>, codeImgFile);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"二维码图片生成成功："</span> + codeImgFile.getPath());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成二维码 并 输出到输出流————通常用于输出到网页上进行显示</span></span><br><span class="line"><span class="comment">     * 输出到网页与输出到磁盘上的文件中，区别在于最后一句 ImageIO.write</span></span><br><span class="line"><span class="comment">     * write(RenderedImage im,String formatName,File output)：写到文件中</span></span><br><span class="line"><span class="comment">     * write(RenderedImage im,String formatName,OutputStream output)：输出到输出流中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> codeContent  ：二维码内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> outputStream ：输出流，比如 HttpServletResponse 的 getOutputStream</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createCodeToOutputStream</span><span class="params">(String codeContent, OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/** 参数检验*/</span></span><br><span class="line">            <span class="keyword">if</span> (codeContent == <span class="keyword">null</span> || <span class="string">""</span>.equals(codeContent.trim())) &#123;</span><br><span class="line">                System.out.println(<span class="string">"二维码内容为空，不进行操作..."</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            codeContent = codeContent.trim();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**com.google.zxing.EncodeHintType：编码提示类型,枚举类型</span></span><br><span class="line"><span class="comment">             * EncodeHintType.CHARACTER_SET：设置字符编码类型</span></span><br><span class="line"><span class="comment">             * EncodeHintType.ERROR_CORRECTION：设置误差校正</span></span><br><span class="line"><span class="comment">             *      ErrorCorrectionLevel：误差校正等级，L = ~7% correction、M = ~15% correction、Q = ~25% correction、H = ~30% correction</span></span><br><span class="line"><span class="comment">             *      不设置时，默认为 L 等级，等级不一样，生成的图案不同，但扫描的结果是一样的</span></span><br><span class="line"><span class="comment">             * EncodeHintType.MARGIN：设置二维码边距，单位像素，值越小，二维码距离四周越近</span></span><br><span class="line"><span class="comment">             * */</span></span><br><span class="line">            Map&lt;EncodeHintType, Object&gt; hints = <span class="keyword">new</span> HashMap();</span><br><span class="line">            hints.put(EncodeHintType.CHARACTER_SET, <span class="string">"UTF-8"</span>);</span><br><span class="line">            hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);</span><br><span class="line">            hints.put(EncodeHintType.MARGIN, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * MultiFormatWriter:多格式写入，这是一个工厂类，里面重载了两个 encode 方法，用于写入条形码或二维码</span></span><br><span class="line"><span class="comment">             *      encode(String contents,BarcodeFormat format,int width, int height,Map&lt;EncodeHintType,?&gt; hints)</span></span><br><span class="line"><span class="comment">             *      contents:条形码/二维码内容</span></span><br><span class="line"><span class="comment">             *      format：编码类型，如 条形码，二维码 等</span></span><br><span class="line"><span class="comment">             *      width：码的宽度</span></span><br><span class="line"><span class="comment">             *      height：码的高度</span></span><br><span class="line"><span class="comment">             *      hints：码内容的编码类型</span></span><br><span class="line"><span class="comment">             * BarcodeFormat：枚举该程序包已知的条形码格式，即创建何种码，如 1 维的条形码，2 维的二维码 等</span></span><br><span class="line"><span class="comment">             * BitMatrix：位(比特)矩阵或叫2D矩阵，也就是需要的二维码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            MultiFormatWriter multiFormatWriter = <span class="keyword">new</span> MultiFormatWriter();</span><br><span class="line">            BitMatrix bitMatrix = multiFormatWriter.encode(codeContent, BarcodeFormat.QR_CODE, CODE_WIDTH, CODE_HEIGHT, hints);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**java.awt.image.BufferedImage：具有图像数据的可访问缓冲图像，实现了 RenderedImage 接口</span></span><br><span class="line"><span class="comment">             * BitMatrix 的 get(int x, int y) 获取比特矩阵内容，指定位置有值，则返回true，将其设置为前景色，否则设置为背景色</span></span><br><span class="line"><span class="comment">             * BufferedImage 的 setRGB(int x, int y, int rgb) 方法设置图像像素</span></span><br><span class="line"><span class="comment">             *      x：像素位置的横坐标，即列</span></span><br><span class="line"><span class="comment">             *      y：像素位置的纵坐标，即行</span></span><br><span class="line"><span class="comment">             *      rgb：像素的值，采用 16 进制,如 0xFFFFFF 白色</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            BufferedImage bufferedImage = <span class="keyword">new</span> BufferedImage(CODE_WIDTH, CODE_HEIGHT, BufferedImage.TYPE_INT_BGR);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; CODE_WIDTH; x++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; CODE_HEIGHT; y++) &#123;</span><br><span class="line">                    bufferedImage.setRGB(x, y, bitMatrix.get(x, y) ? FRONT_COLOR : BACKGROUND_COLOR);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 区别就是以一句，输出到输出流中，如果第三个参数是 File，则输出到文件中</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ImageIO.write(bufferedImage, <span class="string">"png"</span>, outputStream);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"二维码图片生成到输出流成功..."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据本地二维码图片————————解析二维码内容</span></span><br><span class="line"><span class="comment">     * （注：图片必须是二维码图片，但也可以是微信用户二维码名片，上面有名称、头像也是可以的）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file 本地二维码图片文件,如 E:\\logs\\2.jpg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseQRCodeByFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        String resultStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span> || file.isDirectory() || !file.exists()) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**ImageIO 的 BufferedImage read(URL input) 方法用于读取网络图片文件转为内存缓冲图像</span></span><br><span class="line"><span class="comment">             * 同理还有：read(File input)、read(InputStream input)、、read(ImageInputStream stream)</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            BufferedImage bufferedImage = ImageIO.read(file);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * com.google.zxing.client.j2se.BufferedImageLuminanceSource：缓冲图像亮度源</span></span><br><span class="line"><span class="comment">             * 将 java.awt.image.BufferedImage 转为 zxing 的 缓冲图像亮度源</span></span><br><span class="line"><span class="comment">             * 关键就是下面这几句：HybridBinarizer 用于读取二维码图像数据，BinaryBitmap 二进制位图</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            BufferedImageLuminanceSource source = <span class="keyword">new</span> BufferedImageLuminanceSource(bufferedImage);</span><br><span class="line">            BinaryBitmap bitmap = <span class="keyword">new</span> BinaryBitmap(<span class="keyword">new</span> HybridBinarizer(source));</span><br><span class="line">            Hashtable hints = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            hints.put(DecodeHintType.CHARACTER_SET, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果图片不是二维码图片，则 decode 抛异常：com.google.zxing.NotFoundException</span></span><br><span class="line"><span class="comment">             * MultiFormatWriter 的 encode 用于对内容进行编码成 2D 矩阵</span></span><br><span class="line"><span class="comment">             * MultiFormatReader 的 decode 用于读取二进制位图数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Result result = <span class="keyword">new</span> MultiFormatReader().decode(bitmap, hints);</span><br><span class="line">            resultStr = result.getText();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"-----图片非二维码图片："</span> + file.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据网络二维码图片————————解析二维码内容</span></span><br><span class="line"><span class="comment">     * （区别仅仅在于 ImageIO.read(url); 这一个重载的方法）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 二维码图片网络地址，如 https://res.wx.qq.com/mpres/htmledition/images/mp_qrcode3a7b38.gif</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseQRCodeByUrl</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String resultStr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resultStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**ImageIO 的 BufferedImage read(URL input) 方法用于读取网络图片文件转为内存缓冲图像</span></span><br><span class="line"><span class="comment">             * 同理还有：read(File input)、read(InputStream input)、、read(ImageInputStream stream)</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果图片网络地址错误，比如不能访问，则 read 抛异常：javax.imageio.IIOException: Can't get input stream from URL!</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            BufferedImage bufferedImage = ImageIO.read(url);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * com.google.zxing.client.j2se.BufferedImageLuminanceSource：缓冲图像亮度源</span></span><br><span class="line"><span class="comment">             * 将 java.awt.image.BufferedImage 转为 zxing 的 缓冲图像亮度源</span></span><br><span class="line"><span class="comment">             * 关键就是下面这几句：HybridBinarizer 用于读取二维码图像数据，BinaryBitmap 二进制位图</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            BufferedImageLuminanceSource source = <span class="keyword">new</span> BufferedImageLuminanceSource(bufferedImage);</span><br><span class="line">            BinaryBitmap bitmap = <span class="keyword">new</span> BinaryBitmap(<span class="keyword">new</span> HybridBinarizer(source));</span><br><span class="line">            Hashtable hints = <span class="keyword">new</span> Hashtable();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果内容包含中文，则解码的字符集格式应该和编码时一致</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            hints.put(DecodeHintType.CHARACTER_SET, <span class="string">"UTF-8"</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果图片不是二维码图片，则 decode 抛异常：com.google.zxing.NotFoundException</span></span><br><span class="line"><span class="comment">             * MultiFormatWriter 的 encode 用于对内容进行编码成 2D 矩阵</span></span><br><span class="line"><span class="comment">             * MultiFormatReader 的 decode 用于读取二进制位图数据</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Result result = <span class="keyword">new</span> MultiFormatReader().decode(bitmap, hints);</span><br><span class="line">            resultStr = result.getText();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"-----二维码图片地址错误："</span> + url);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"-----图片非二维码图片："</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成二维码工具</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> text     文本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> width    宽度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> height   高度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filePath 文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2020/12/25 20:30</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateQRCodeImage</span><span class="params">(String text, <span class="keyword">int</span> width, <span class="keyword">int</span> height, String filePath)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> WriterException, IOException </span>&#123;</span><br><span class="line">        QRCodeWriter qrCodeWriter = <span class="keyword">new</span> QRCodeWriter();</span><br><span class="line">        BitMatrix bitMatrix = qrCodeWriter.encode(text, BarcodeFormat.QR_CODE, width, height);</span><br><span class="line">        Path path = FileSystems.getDefault().getPath(filePath);</span><br><span class="line">        MatrixToImageWriter.writeToPath(bitMatrix, <span class="string">"PNG"</span>, path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</span><br><span class="line">        File localFile = <span class="keyword">new</span> File(<span class="string">"E:\\logs\\1.png"</span>);</span><br><span class="line">        String file = parseQRCodeByFile(localFile);</span><br><span class="line">        System.out.println(localFile + <span class="string">" 二维码内容："</span> + file);</span><br><span class="line"></span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">"https://res.wx.qq.com/mpres/htmledition/images/mp_qrcode3a7b38.gif"</span>);</span><br><span class="line">        String code = parseQRCodeByUrl(url);</span><br><span class="line">        System.out.println(url + <span class="string">" 二维码内容："</span> + code);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            generateQRCodeImage(<span class="string">"Hello World"</span>, <span class="number">350</span>, <span class="number">350</span>, <span class="string">"C:\\Users\\Desktop\\QRTest.png"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (WriterException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>MySql乐观锁和悲观锁详解</title>
    <url>/post/c3c9656a.html</url>
    <content><![CDATA[<blockquote><p>在面试的时候，都会被问到乐观锁和悲观锁的问题，如果不清楚其概念和用法的情况下 ，相信很多的同学感觉很懵逼，今天咱们就小学一下 ~</p></blockquote><a id="more"></a><h3 id="一、乐观锁"><a href="#一、乐观锁" class="headerlink" title="一、乐观锁"></a>一、乐观锁</h3><p>乐观锁指的是认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。一般的实现乐观锁的方式就是第一种是<u>使用版本号Version</u>，第二种是使用<u>时间戳Timestamp（时间戳精度）</u>。</p><blockquote><p>如何解决？</p><p>乐观锁的实现不依靠数据库提供的锁机制，需要我们自已开发者去实现，实现方式一般是记录数据版本，一种是通过版本号，一种是通过时间戳。给表加一个版本号或时间戳的字段，读取数据时，将版本号一同读出，数据更新时，将版本号加1。当我们提交数据更新时，判断当前的版本号与第一次读取出来的版本号是否相等。如果相等，则予以更新，否则认为数据过期，拒绝更新，让用户重新操作。</p></blockquote><p><font color="red"><strong>优势劣势：</strong></font></p><p>乐观锁在并发控制的时候，相信事务之间的数据竞争(datarace)的概率是比较小的， 因此尽可能直接走下去，直到最终提交的时候才去锁定，所以<u>不会产生任何锁和死锁</u>。乐观锁虽然没有依赖数据库提供的锁机制，也可以保证数据一致性。</p><h3 id="二、悲观锁"><a href="#二、悲观锁" class="headerlink" title="二、悲观锁"></a>二、悲观锁</h3><p>悲观锁指的是外界对数据修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。 悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><blockquote><p>如何解决？</p><p>悲观锁的实现方式有两种：共享锁（读锁）和排它锁（写锁）</p><p><strong>共享锁（读锁）：</strong>由非更新（读取）操作创建的锁。其他用户可以并发读取数据，但任何事务都不能获取数据上的排它锁，直到已释放所有共享锁。共享锁(S锁)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A， 不能修改A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><p><strong>实现方式：</strong>是在sql后加LOCK IN SHARE MODE，比如SELECT … LOCK IN SHARE MODE，即在符合条件的rows上都加了共享锁，这样的话，其他session可以读取这些记录，也可以继续添加共享锁，但是无法修改这些记录直到你这个加锁的session执行完成(否则直接锁等待超时)，<em>也就是读取完后才能让其他线程修改</em>。</p><hr><p><strong>排它锁（写锁、独占锁）：</strong>又称为写锁、独占锁，是一种基本的锁类型。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再<strong>读取和修改</strong>A。</p><p><strong>实现方式：</strong>是在sql后面加FOR UPDATE，比如SELECT … FOR UPDATE ，即在符合条件的rows上都加了排它锁，其他session也就无法在这些记录上添加任何的S锁或X锁。如果不存在一致性非锁定读的话，那么其他session是无法读取和修改这些记录的，但是innodb有非锁定读(快照读并不需要加锁)，for update之后并不会阻塞其他session的快照读取操作，除了select …lock in share mode和select … for update这种显示加锁的查询操作。</p><p><u>注意：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用auto commit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</u></p><p>数据库中，悲观锁的流程： 对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会释放锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p></blockquote><p><font color="red"><strong>优势劣势：</strong></font></p><p>悲观并发控制实际上是<u>“先取锁再访问”</u>的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有<u>增加产生死锁的机会</u>；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数。</p><h3 id="三、总结归纳"><a href="#三、总结归纳" class="headerlink" title="三、总结归纳"></a>三、总结归纳</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20210411225806824.png" alt=""></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySql</category>
        <category>lock</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL调优之explain执行计划详解</title>
    <url>/post/f40ffcc5.html</url>
    <content><![CDATA[<blockquote><p>explain执行计划记录 ~</p></blockquote><a id="more"></a><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>explain显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。</p><p>使用方法，在select语句前加上explain就可以了(MySQL 5.6开始，不仅仅支持select )</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210422181311.png" alt=""></p><h3 id="各列含义"><a href="#各列含义" class="headerlink" title="各列含义"></a>各列含义</h3><h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>标识select，id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。</p><h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><p>用来表示查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><p>常用的值：</p><ul><li><code>SIMPLE</code>:简单 SELECT (不使用 UNION 或子查询)</li><li><code>PRIMARY</code>:最外面的 SELECT</li><li><code>UNION</code>:UNION 中的第二个和随后的 SELECT 语句</li><li><code>DEPENDENT UNION</code>: UNION 中的第二个或后面的 SELECT 语句,取决于外面的查询</li><li><code>UNION RESULT</code>: UNION 的结果</li><li><code>SUBQUERY</code>:子查询中的第一个 SELECT</li><li><code>DEPENDENT SUBQUERY</code>:子查询中的第一个 SELECT ,取决于外面的查询</li><li><code>DERIVED</code>:导出表(派生表)的 SELECT ( FROM 子句的子查询)</li><li><code>UNCACHEABLE SUBQUERY</code>：子查询中的第一个 select 语句，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li><li><code>UNCACHEABLE UNION</code>：满足此查询是 UNION 中的第二个或者随后的查询，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中</li></ul><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><ol><li>输出的行所引用的表。</li><li>显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为 null，如果显示为尖括号括起来的<derived n>就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的&lt;union M,N&gt;，与<derived n>类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。</derived></derived></li></ol><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><ul><li>依次从好到差：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>fulltext</code> &gt; <code>ref_or_null</code> &gt; <code>unique_subquery</code> &gt; <code>index_subquery</code> &gt; <code>range</code> &gt; <code>index_merge</code> &gt; <code>index</code> &gt; <code>ALL</code></li><li>除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引</li><li>最常用的从好到差依次是：<code>system</code> &gt; <code>const</code> &gt; <code>eq_ref</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>all</code></li><li><strong>一般来说，得保证查询至少达到<code>range</code>级别，最好能达到<code>ref</code></strong>。</li><li><code>system</code> ：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计</li><li><code>const</code> ：表示通过索引一次就找到了，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量。</li><li><code>eq_ref</code> ：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。使用这种索引，MySQL知道最多只返回一条符合条件的记录。</li><li><code>ref</code> ：它是一种索引访问（有时也叫做索引查找），它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体。把它叫做ref是因为索引要跟某个参考值相比较。此类索引访问只有当使用非唯一性索引或者唯一索引的非唯一性前缀时才会发生。</li><li><code>range</code> ：范围扫描就是一个有限制的索引扫描，key列显示使用了哪个索引，一般就是在你的where语句中出现between、&lt; 、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。</li><li><code>index</code> ：这个跟全表扫描一样，只是MySQL扫描表时按索引次序进行而不是行。它的主要优点是避免了排序；最大优点是要承担按索引次序读取整个表的开销。如果在EXTRA列中看到using index,说明MySQL正在使用覆盖索引，它比按索引次序全表扫描的开销要少的多。</li><li><code>all</code> ：全表扫描，将遍历全表以找到匹配的行</li></ul><h4 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h4><p>查询可能使用到的索引都会在这里列出来。</p><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。</p><h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><p>用于处理查询的索引长度，单位为字节，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。</p><h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>显示使用哪个列或常数与key一起从表中选择行。</p><h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><p>根据表统计信息或者索引选用情况，大致估算出找到所需的记录所需要读取的行数，这里是执行计划中估算的扫描行数，不是精确值。</p><h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h4><p>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。</p><h4 id="extra"><a href="#extra" class="headerlink" title="extra"></a>extra</h4><ol><li><code>Using filesort</code>（九死一生）：<ul><li>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”。</li></ul></li><li><code>Using temporary</code>（十死无生）：<ul><li>使用了用临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li></ul></li><li><code>Using index</code>（发财了）：<ul><li>表示相应的select操作中使用了覆盖索引（Covering Index），避免访问了表的数据行，效率不错。如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表明索引用来读取数据而非执行查找动作。</li></ul></li><li><code>Using where</code> ：<ul><li>表明使用了where过滤</li></ul></li><li><code>Using join buffer</code> ：<ul><li>表明使用了连接缓存,比如说在查询的时候，多表join的次数非常多，那么将配置文件中的缓冲区的join buffer调大一些。</li><li>表示 SQL 操作使用了关联查询或者子查询，且需要进行嵌套循环计算。</li></ul></li><li><code>impossible where</code> ：<ul><li>where子句的值总是false，不能用来获取任何元组</li></ul></li><li><code>select tables optimized away</code> ：<ul><li>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li></ul></li><li><code>distinct</code> ：<ul><li>优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作</li></ul></li><li><code>Using index condition</code> ：<ul><li>表示已经使用了索引下推。</li><li>表示 SQL 操作命中了索引，但不是所有的列数据都在索引树上，还需要访问实际的行记录。</li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Sql</category>
      </categories>
      <tags>
        <tag>Sql</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql的Sql语句的执行顺序</title>
    <url>/post/2ea7f979.html</url>
    <content><![CDATA[<blockquote><p>MySql的Sql语句的执行顺序 ~</p></blockquote><a id="more"></a><h3 id="SQL查询中用到的关键词"><a href="#SQL查询中用到的关键词" class="headerlink" title="SQL查询中用到的关键词"></a>SQL查询中用到的关键词</h3><p>​ select、distinct、from、join、on、where、group by、having、sum、count、max、avg、order by、limit</p><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><table><thead><tr><th align="center"><strong>顺序</strong></th><th align="center"><strong>关键词</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>from</strong></td><td align="center">需要从哪个数据表检索数据</td></tr><tr><td align="center">2</td><td align="center"><strong>on</strong></td><td align="center">关联条件</td></tr><tr><td align="center">3</td><td align="center"><strong>join</strong></td><td align="center">对需要关联查询的表进行关联</td></tr><tr><td align="center">4</td><td align="center"><strong>where</strong></td><td align="center">过滤表中数据的条件</td></tr><tr><td align="center">5</td><td align="center"><strong>group by</strong></td><td align="center">开始使用select中的别名，后面的语句中都可以使用别名</td></tr><tr><td align="center">6</td><td align="center"><strong>sum、count、max、avg</strong></td><td align="center">计算聚合函数</td></tr><tr><td align="center">7</td><td align="center"><strong>having</strong></td><td align="center">对上面已经分组的数据进行过滤的条件</td></tr><tr><td align="center">8</td><td align="center"><strong>select</strong></td><td align="center">查看结果集中的哪个列或列的计算结果</td></tr><tr><td align="center">9</td><td align="center"><strong>distinct</strong></td><td align="center">对结果集重复值去重</td></tr><tr><td align="center">10</td><td align="center"><strong>order by</strong></td><td align="center">按照什么样的顺序来查看返回的数据</td></tr><tr><td align="center">11</td><td align="center"><strong>limit</strong></td><td align="center">截取出目标页数据</td></tr></tbody></table><h3 id="具体含义"><a href="#具体含义" class="headerlink" title="具体含义"></a>具体含义</h3><ul><li><p><strong>from</strong>：需要从哪个数据表检索数据</p></li><li><p><strong>join</strong>：对需要关联查询的表进行关联</p><p>关联查询时，数据库会选择一个驱动表，然后用此表的记录去关联其他表<br>​ left join一般以左表为驱动表（right join一般为右表）,inner join一般以结果集少的表为驱动表,left join某些情况下会被查询优化器优化为inner join</p><ul><li>驱动表选择原则：在对最终结果集没影响的前提下，优先选择结果集最少的那张表作为驱动表</li><li>在<strong>使用索引关联</strong>的情况下，有<code>Index Nested-Loop join</code>和<code>Batched Key Access join</code>两种算法</li><li>在<strong>未使用索引关联</strong>的情况下，有<code>Simple Nested-Loop join</code>和<code>Block Nested-Loop join</code>两种算法</li><li><code>Simple Nested-Loop join</code>（SNLJ，简单嵌套循环连接）算法：根据on条件，从驱动表取一条数据，然后全表扫面被驱动表，将符合条件的记录放入最终结果集中。这样驱动表的每条记录都伴随着被驱动表的一次全表扫描<ul><li>匹配次数：外层表行数*内层表行数</li></ul></li><li><code>Index Nested-Loop Join</code>（INLJ，索引嵌套循环连接）算法：索引嵌套循环连接是基于索引进行连接的算法，索引是基于内层表的，通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录进行比较， 从而利用索引的查询减少了对内层表的匹配次数<ul><li>匹配次数：外层表行数*内层表索引高度</li></ul></li><li><code>Block Nested-Loop Join</code>（BNLJ，缓存块嵌套循环连接）算法：缓存块嵌套循环连接通过一次性缓存多条数据，把参与查询的列缓存到Join Buffer 里，然后拿join buffer里的数据批量与内层表的数据进行匹配，从而减少了内层循环的次数（遍历一次内层表就可以批量匹配一次Join Buffer里面的外层表数据）。<br>当不使用<code>Index Nested-Loop Join</code>的时候，默认使用<code>Block Nested-Loop Join</code></li><li><code>Batched Key Access join</code>（BKAJ）算法：和SNLJ算法类似，但用于被join表上有索引可以利用，那么在行提交给被join的表之前，对这些行按照索引字段进行排序，因此减少了随机IO，排序这才是两者最大的区别，但是如果被join的表没用索引呢？那就使用BNLJ了</li><li>什么是<code>Join Buffer</code>?<ul><li><code>Join Buffer</code>会缓存所有参与查询的列而不是只有Join的列。</li><li>可以通过调整<code>join_buffer_size</code>缓存大小</li><li><code>join_buffer_size</code>的默认值是256K，<code>join_buffer_size</code>的最大值在<code>MySQL 5.1.22</code>版本前是<code>4G</code>，而之后的版本才能在64位操作系统下申请大于<code>4G</code>的<code>Join Buffer</code>空间。</li><li>使用<code>Block Nested-Loop Join</code>算法需要开启优化器管理配置的<code>optimizer_switch</code>的设置<code>block_nested_loop</code>为<code>on</code>，默认为开启。</li></ul></li><li>在选择Join算法时，会有优先级，理论上会优先判断能否使用INLJ、BNLJ：<br>Index Nested-LoopJoin &gt; Block Nested-Loop Join &gt; Simple Nested-Loop Join</li><li>注：可以使用explain查找驱动表，结果的第一张表即为驱动表，但执行计划在真正执行时可能发生改变</li></ul></li><li><p><strong>on</strong>：关联条件</p></li><li><p><strong>where</strong>：过滤表中数据的条件</p><ul><li>执行顺序：自下而上、从右到左</li><li>注：对数据库记录生效，无法对聚合结果生效，可以过滤掉最大数量记录的条件必须写在where子句末尾，不能使用聚合函数（sum、count、max、avg）</li></ul></li><li><p><strong>group by</strong>：如何将上面过滤出的数据分组</p><ul><li>执行顺序：从左往右</li><li>注：尽量在group by之前使用where过滤，避免之后使用having过滤</li></ul></li><li><p><strong>avg</strong>：求平均值</p></li><li><p><strong>having</strong>：对上面已经分组的数据进行过滤的条件</p><ul><li><p>注：对聚合结果过滤，因此很耗资源，可以使用聚合函数</p></li><li><p>例：筛选统计人口数量大于100W的地区</p><p>select region, sum(population), sum(area) from bbc group by region having sum(population)&gt;1000000，不能用where筛选超过100W的地区，因为不存在这样的一条记录</p></li></ul></li><li><p><strong>select</strong>：查看结果集中的哪个列或列的计算结果</p></li><li><p><strong>distinct</strong>：对结果集重复值去重</p></li><li><p><strong>order by</strong>：按照什么样的顺序来查看返回的数据</p><ul><li>执行顺序：从左到右</li><li>注：很耗资源</li></ul></li><li><p><strong>limit</strong>：截取出目标页数据</p></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.cnblogs.com/yyjie/p/7788428.html" target="_blank" rel="noopener">《关于SQL和MySQL的语句执行顺序》</a><br><a href="https://www.cnblogs.com/loong-hon/p/13470263.html" target="_blank" rel="noopener">《SQL语句执行顺序 》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>MySql主从同步延迟</title>
    <url>/post/2b202fe.html</url>
    <content><![CDATA[<blockquote><p>MySql主从同步延迟问题以及解决方案 ~</p></blockquote><a id="more"></a><h3 id="一、数据库主从同步原理"><a href="#一、数据库主从同步原理" class="headerlink" title="一、数据库主从同步原理"></a>一、数据库主从同步原理</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210419135600.jpeg" alt=""></p><p>分为四步走：</p><ol><li><p><u>主库对所有DDL和DML产生的日志写进binlog；</u></p></li><li><p><u>主库生成一个 log dump 线程，用来给从库I/O线程读取binlog；</u></p></li><li><p><u>从库的I/O Thread去请求主库的binlog，并将得到的binlog日志写到relay log文件中；</u></p></li><li><p><u>从库的SQL Thread会读取relay log文件中的日志解析成具体操作，将主库的DDL和DML操作事件重放。</u></p></li></ol><blockquote><p>SQL语言共分为以下几大类：查询语言DQL，控制语言DCL，操纵语言DML，定义语言DDL。事务控制TCL.</p><p><strong>DQL（Data QUERY Languages）语句</strong>：即数据库定义语句，用来查询SELECT子句，FROM子句，WHERE子句组成的查询块，比如：select–from–where–grouop by–having–order by–limit</p><p><strong>DDL（Data Definition Languages）语句</strong>：即数据库定义语句，用来创建数据库中的表、索引、视图、存储过程、触发器等，常用的语句关键字有：CREATE,ALTER,DROP,TRUNCATE,COMMENT,RENAME。增删改表的结构</p><p><strong>DML（Data Manipulation Language）语句</strong>：即数据操纵语句，用来查询、添加、更新、删除等，常用的语句关键字有：SELECT,INSERT,UPDATE,DELETE,MERGE,CALL,EXPLAIN PLAN,LOCK TABLE,包括通用性的增删改查。增删改表的数据</p><p><strong>DCL（Data Control Language）语句</strong>：即数据控制语句，用于授权/撤销数据库及其字段的权限（DCL is short name of Data Control Language which includes commands such as GRANT and mostly concerned with rights, permissions and other controls of the database system.）。常用的语句关键字有：GRANT,REVOKE。</p><p><strong>TCL（Transaction Control Language）语句</strong>：事务控制语句，用于控制事务，常用的语句关键字有：COMMIT,ROLLBACK,SAVEPOINT,SET TRANSACTION。</p></blockquote><h3 id="二、主从同步延迟产生原因"><a href="#二、主从同步延迟产生原因" class="headerlink" title="二、主从同步延迟产生原因"></a>二、主从同步延迟产生原因</h3><ol><li><p>MySQL的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高。Slave的SQL Thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序的，成本高很多。</p></li><li><p>由于SQL Thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL Thread所能处理的速度，或者当slave中有大型query语句产生了锁等待那么延时就产生了。</p></li></ol><p>常见原因：Master负载过高、Slave负载过高、网络延迟、机器性能太低、MySQL配置不合理。</p><h3 id="三、判断主从延迟的方法"><a href="#三、判断主从延迟的方法" class="headerlink" title="三、判断主从延迟的方法"></a>三、判断主从延迟的方法</h3><p>通过监控 show slave status 命令输出的Seconds_Behind_Master参数的值来判断：</p><p>NULL，表示io_thread或是sql_thread有任何一个发生故障；</p><p><strong>0 该值为零，表示主从复制良好；</strong></p><p>正值，表示主从已经出现延时，数字越大表示从库延迟越严重。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210419135651.png" alt=""></p><h3 id="四、如何避免主从同步延迟"><a href="#四、如何避免主从同步延迟" class="headerlink" title="四、如何避免主从同步延迟"></a>四、如何避免主从同步延迟</h3><h4 id="①架构方面"><a href="#①架构方面" class="headerlink" title="①架构方面"></a>①架构方面</h4><ol><li><p>业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。</p></li><li><p>单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。</p></li><li><p>服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。</p></li><li><p>不同业务的mysql物理上放在不同机器，分散压力。</p></li><li><p>使用比主库更好的硬件设备作为slave总结，mysql压力小，延迟自然会变小。</p></li></ol><h4 id="②硬件方面"><a href="#②硬件方面" class="headerlink" title="②硬件方面"></a>②硬件方面</h4><ol><li><p>采用好服务器，比如4u比2u性能明显好，2u比1u性能明显好。</p></li><li><p>存储用ssd或者盘阵或者san，提升随机写的性能。</p></li><li><p>主从间保证处在同一个交换机下面，并且是万兆环境。</p><p>总结，硬件强劲，延迟自然会变小。一句话，缩小延迟的解决方案就是花钱和花时间。</p></li></ol><h4 id="③软件方面"><a href="#③软件方面" class="headerlink" title="③软件方面"></a>③软件方面</h4><ol><li><p>sync_binlog在slave端设置为0</p></li><li><p>–logs-slave-updates 从服务器从主服务器接收到的更新不记入它的二进制日志。</p></li><li><p>直接禁用slave端的binlog</p></li><li><p>slave端，如果使用的存储引擎是innodb，innodb_flush_log_at_trx_commit =2</p></li><li><p>升级MySQL版本到5.7，使用并行复制</p></li><li><p>优化网络</p></li><li><p>强制将读请求路由到主库处理。既然你从库的数据过期了，那就直接从主库读取，这种方案虽然会增加主库的压力，实现起来比较简单。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比如 Sharding-JDBC 就是采用的这种方案。通过使用 Sharding-JDBC 的 HintManager 分片键值管理器，我们可以强制使用主库。</span></span><br><span class="line"><span class="comment">// 继续JDBC操作对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</span></span><br><span class="line">HintManager hintManager = HintManager.getInstance();</span><br><span class="line">hintManager.setMasterRouteOnly();</span><br></pre></td></tr></table></figure></li><li><p>延迟读取。<br>对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p></li></ol><blockquote><p><strong>优酷的解决方案</strong>：数据库分片技术，而抛弃了由于数据量的越来越多导致复制延迟的问题。按照user_id进行分片，这样必须有一个全局的表来管理用户与shard的关系,根据user_id可以得到share_id，然后根据share_id去指定的分片查询指定的数据</p><p><strong>淘宝的解决方案</strong>：修改源码，对应的机制是Transfer机制，此处通过对Binlog日志重做采用多线程实现，从而提高slave的QPS</p><p><strong>实际上，延迟读取这种方案没办法完全避免主从延迟，只能说可以减少出现延迟的概率而已，实际项目中一般不会使用。总的来说，要想不出现延迟问题，一般还是要强制将那些必须获取最新数据的读请求都交给主库处理。如果你的项目的大部分业务场景对数据准确性要求不是那么高的话，这种方案还是可以选择的。</strong></p></blockquote><h3 id="五、解决数据丢失的问题"><a href="#五、解决数据丢失的问题" class="headerlink" title="五、解决数据丢失的问题"></a>五、解决数据丢失的问题</h3><p>主库宕机后，数据可能丢失；</p><ol><li><p><strong>半同步复制</strong></p><p>从MySQL5.5开始，MySQL已经支持半同步复制了，半同步复制介于异步复制和同步复制之间，主库在执行完事务后不立刻返回结果给客户端，需要等待至少一个从库接收到并写到relay log中才返回结果给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一个TCP/IP往返耗时的延迟。</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210419142347.png" style="zoom:80%"></li><li><p><strong>主库配置 sync_binlog=1，innodb_flush_log_at_trx_commit=1</strong></p><p>sync_binlog的默认值是0，MySQL不会将binlog同步到磁盘，其值表示每写多少binlog同步一次磁盘。</p><p>innodb_flush_log_at_trx_commit为1表示每一次事务提交或事务外的指令都需要把日志flush到磁盘。</p></li></ol><blockquote><p>注意:将以上两个值同时设置为1时，写入性能会受到一定限制，只有对数据安全性要求很高的场景才建议使用，比如涉及到钱的订单支付业务，而且系统I/O能力必须可以支撑！</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql的那些日志文件</title>
    <url>/post/15e0b332.html</url>
    <content><![CDATA[<blockquote><p>MySQL的那些日志文件，文章末尾有彩蛋哦 ~ ~</p></blockquote><a id="more"></a><p><code>MySQL</code>中有六种日志文件，分别是：<strong>重做日志（redo log）</strong>、<strong>回滚日志（undo log）</strong>、<strong>二进制日志（bin log）</strong>、<strong>错误日志（error log）</strong>、<strong>慢查询日志（slow query log）</strong>、<strong>一般查询日志（general log）</strong>、<strong>中继日志（relay log）</strong>。其中<strong>重做日志（redo log）</strong>和<strong>回滚日志（undo log）</strong>与事务操作息息相关，<strong>二进制日志（bin log）</strong>也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210426161729.png" alt="Mysql架构"></p><h3 id="一、二进制日志（bin-log）"><a href="#一、二进制日志（bin-log）" class="headerlink" title="一、二进制日志（bin log）"></a>一、二进制日志（bin log）</h3><p><strong><font face="楷体" color="#FF0000" size="4">二进制日志：binary log。简称binLog。记录了对Mysql数据库执行更改的所有操作，但是不包括SELECT 和 SHOW这类操作。</font></strong></p><p><code>binlog</code> 我们可以理解位存储着对数据库执行的所有更新语句SQL语句。主要的两个作用：复制和恢复数据。</p><p><strong>主从复制</strong>：在 Master 端开启 <code>binlog</code>，然后将 <code>binlog</code>推送到各个 Slave 从端，Slave 端重放 <code>binlog</code> 从而达到主从数据一致。</p><p><strong>数据恢复</strong>：通过使用 mysqlbinlog 工具来恢复数据。</p><h3 id="二、回滚日志（undo-log）"><a href="#二、回滚日志（undo-log）" class="headerlink" title="二、回滚日志（undo log）"></a>二、回滚日志（undo log）</h3><p><strong><font face="楷体" color="#FF0000" size="4">保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC）。</font></strong></p><p>undo log主要有两个作用：<strong>回滚</strong>和<strong>多版本控制(MVCC)</strong></p><p>在数据修改的时候，不仅记录了<code>redo log</code>，还记录<code>undo log</code>，如果因为某些原因导致事务失败或回滚了，可以用<code>undo log</code>进行回滚</p><p><code>undo log</code>主要存储的也是逻辑日志，比如我们要<code>insert</code>一条数据了，那<code>undo log</code>会记录的一条对应的<code>delete</code>日志。我们要<code>update</code>一条记录时，它会记录一条对应<strong>相反</strong>的update记录。</p><p>这也应该容易理解，毕竟回滚嘛，跟需要修改的操作相反就好，这样就能达到回滚的目的。因为支持回滚操作，所以我们就能保证：“<strong>一个事务包含多个操作，这些操作要么全部执行，要么全都不执行</strong>”。【原子性】</p><p>因为<code>undo log</code>存储着修改之前的数据，相当于一个<strong>前版本</strong>，MVCC实现的是读写不阻塞，读的时候只要返回前一个版本的数据就行了。</p><h3 id="三、重做日志（redo-log）"><a href="#三、重做日志（redo-log）" class="headerlink" title="三、重做日志（redo log）"></a>三、重做日志（redo log）</h3><p><strong><font face="楷体" color="#FF0000" size="4">确保事务的持久性，防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。</font></strong></p><p>什么时候产生：<br>　　 事务开始之后就产生redo log，redo log的落盘并不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入redo log文件中。<br>什么时候释放：<br>　　 当对应事务的脏页写入到磁盘之后，redo log的使命也就完成了，重做日志占用的空间就可以重用（被覆盖）。</p><p><code>redo log</code>的存在为了：当我们修改的时候，写完内存了，但数据还没真正写到磁盘的时候。此时我们的数据库挂了，我们可以根据<code>redo log</code>来对数据进行恢复。因为<code>redo log</code>是顺序IO，所以<strong>写入的速度很快</strong>，并且<code>redo log</code>记载的是物理变化（xxxx页做了xxx修改），文件的体积很小，<strong>恢复速度很快</strong>。</p><blockquote><p><code>Mysql</code>不是每次数据更改都立刻写到磁盘，而是会先将修改后的结果暂存在内存中,当一段时间后，再一次性将多个修改写到磁盘上，减少磁盘io成本，同时提高操作速度。这种<strong>先写日志再写磁盘</strong>的技术就是 MySQL的<code>LWAL(write-ahead logging)技术</code>保证事务。</p></blockquote><h3 id="四、错误日志（error-log）"><a href="#四、错误日志（error-log）" class="headerlink" title="四、错误日志（error log）"></a>四、错误日志（error log）</h3><p>主要记录MySQL服务实例每次启动、停止的详细信息，以及MySQL实例运行过程中产生的警告或者错误信息。例如连接MySQL连接失败、查询命令错误、SQL执行流程等等。</p><h3 id="五、慢查询日志（slow-query-log）"><a href="#五、慢查询日志（slow-query-log）" class="headerlink" title="五、慢查询日志（slow query log）"></a>五、慢查询日志（slow query log）</h3><p>慢查询日志是定位SQL语句查询快与慢而记录的一种日志文件。当某一条SQL语句查询时间超过一个固定的阈值，这条SQL语句将被定义为慢查询的SQL语句，被记录在慢查询日志文件中。使用MySQL慢查询日志可以有效的跟踪 执行时间过长 或者 没有使用索引的查询语句。</p><ul><li>是否开启慢查询与慢查询日志文件。</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql root@127.0.0.1:(none)&gt; show variables like '%slow%';</span><br><span class="line">+<span class="comment">---------------------------+-------------------------------+</span></span><br><span class="line">| Variable_name             | Value                         |</span><br><span class="line">+<span class="comment">---------------------------+-------------------------------+</span></span><br><span class="line">| slow_query_log            | ON                            |</span><br><span class="line">| slow_query_log_file       | /var/lib/mysql/mysql.slow.log |</span><br><span class="line">+<span class="comment">---------------------------+-------------------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span></span><br><span class="line"><span class="built_in">Time</span>: <span class="number">0.014</span>s</span><br></pre></td></tr></table></figure><ul><li>慢查询时间阈值</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql root@127.0.0.1:(none)&gt; show variables like '%long_query_time%';</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| Variable_name   | Value    |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">| long_query_time | 3.000000 |</span><br><span class="line">+<span class="comment">-----------------+----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span></span><br><span class="line"><span class="built_in">Time</span>: <span class="number">0.013</span></span><br></pre></td></tr></table></figure><h3 id="六、彩蛋"><a href="#六、彩蛋" class="headerlink" title="六、彩蛋"></a>六、彩蛋</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210426161645.png" alt="Mysql执行更新语句流程"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySql回表、索引覆盖、索引下推</title>
    <url>/post/6e14acb7.html</url>
    <content><![CDATA[<blockquote><p>面试官问到你 MySql回表、索引覆盖、索引下推 ，如果一脸懵逼的话，就进来稍作休息，学习一下 ~</p></blockquote><a id="more"></a><h3 id="什么是回表？"><a href="#什么是回表？" class="headerlink" title="什么是回表？"></a>什么是回表？</h3><p>先通过数据库索引扫描出数据所在的行，再通过行主键id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树。</p><p>举个例子：</p><p>表tbl有a,b,c三个字段，其中a是主键，b上建了索引，然后编写sql语句</p><hr><p>SELECT * FROM tbl WHERE a =1</p><p>这样不会产生回表，因为所有的数据在a的索引树中均能找到</p><hr><p>SELECT * FROM tbl WHERE b = 1</p><p>这样就会产生回表，因为where条件是b字段，那么会去b的索引树里查找数据，但b的索引里面只有a,b两个字段的值，没有c，那么这个查询为了取到c字段，就要取出主键a的值，然后去a的索引树去找c字段的数据。查了两个索引树，这就叫回表。</p><hr><h3 id="怎么避免回表？"><a href="#怎么避免回表？" class="headerlink" title="怎么避免回表？"></a>怎么避免回表？</h3><p>将需要的字段放在索引中去。查询的时候就能避免回表。</p><p><font color="red"><strong>不是必须的字段就不要出现在SELECT里面。或者b,c建联合索引。但具体情况要具体分析，索引字段多了，存储和插入数据时的消耗会更大，这是个平衡问题。</strong></font></p><h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>索引覆盖就是查这个索引能查到你所需要的所有数据，不需要去另外的数据结构去查。其实就是不用回表（和回表相反）。</p><p><strong>覆盖索引</strong>又称之为<strong>索引覆盖</strong>，即select的数据列只从索引中就能得到，不必读取数据行，也就是只需扫描索引就可以得到查询结果。</p><p><u>常见索引覆盖的方法是：将被查询的字段，建立到联合索引里去。</u></p><blockquote><p>索引覆盖查询只需要扫描索引而无需回表，不仅能够极大地提高性能，而且减少I/O提高效率。</p></blockquote><p>当一个查询使用了覆盖索引，在查询分析器EXPLAIN的Extra列可以看到“<em>Using index</em>”。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>5.6之前的版本是没有索引下推这个优化的，5.6版本添加了索引下推这个优化。</p><blockquote><p>索引下推： <strong>数据库检索数据过程中为减少回表次数而做的优化</strong></p><p>索引下推：具体是在复合索引的查询中，针对特定的过滤条件而进行减少回表次数而做的优化。</p><p>索引下推：在<strong>非主键索引</strong>上的优化，可以有效减少回表的次数，大大提升了查询的效率。</p></blockquote><p>explain解析结果可以看出Extra的值为 <strong>“Using index condition”</strong> ，表示已经使用了索引下推。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210414145314.png" alt="MySql查询过程"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis五种数据结构</title>
    <url>/post/55f0c398.html</url>
    <content><![CDATA[<blockquote><p>Redis五种数据结构介绍 ~</p></blockquote><a id="more"></a><p>在 Redis 中一共有5种数据结构，依次学习记录一下底层的数据结构：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210428162648.png" alt=""></p><h3 id="1、String（字符串类型）"><a href="#1、String（字符串类型）" class="headerlink" title="1、String（字符串类型）"></a>1、String（字符串类型）</h3><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><p>是redis中最基本的数据类型，一个key对应一个value。Redis 里的字符串是动态字符串，会根据实际情况动态调整。如果长度不够则自动扩容。至于如何扩容，方法大致如下：当 length 小于 1M 的时候，扩容规则将目前的字符串翻倍；如果 length 大于 1M 的话，则每次只会扩容 1M，直到达到 512M。</p><h4 id="实战场景"><a href="#实战场景" class="headerlink" title="实战场景"></a>实战场景</h4><ol><li><p>缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。</p></li><li><p>计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。</p></li><li><p>session：常见方案spring session + redis实现session共享，</p></li></ol><h3 id="2、Hash-（字典）"><a href="#2、Hash-（字典）" class="headerlink" title="2、Hash （字典）"></a>2、Hash （字典）</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210428162655.png" alt=""></p><h4 id="概念介绍-1"><a href="#概念介绍-1" class="headerlink" title="概念介绍"></a>概念介绍</h4><p>散列，hash内容由field和与之关联的value组成map键值对组成 <strong>key</strong>、<strong>field</strong> 和 <strong>value</strong>是字符串类型。</p><p>Redis中的字典相当于Java的HashMap，其内部结构与HashMap也是一致的，同样是数组+链表的二维结构，在一维发生碰撞的时候，会使用碰撞的元素把链表串接起来。</p><h4 id="实战场景-1"><a href="#实战场景-1" class="headerlink" title="实战场景"></a>实战场景</h4><p>记录业务中的不同用户/不同商品/不同场景的信息：如某个用户的名称，或者用户的历史行为。</p><h3 id="3、List（链表-）"><a href="#3、List（链表-）" class="headerlink" title="3、List（链表 ）"></a>3、List（链表 ）</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210428163124.png" alt=""></p><h4 id="概念介绍-2"><a href="#概念介绍-2" class="headerlink" title="概念介绍"></a>概念介绍</h4><p><code>Redis</code> 里的 List 是一个链表，由于链表本身插入和删除比较块，但是查询的效率比较低，所以常常被用做异步队列。Redis 里的 List 设计非常牛，当数据量比较小的时候，数据结构是压缩链表，而当数据量比较多的时候就成为了快速链表。</p><h4 id="实战场景-2"><a href="#实战场景-2" class="headerlink" title="实战场景"></a>实战场景</h4><ol><li><code>timeline</code>：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。</li></ol><h3 id="4、Set-（-集合）"><a href="#4、Set-（-集合）" class="headerlink" title="4、Set （ 集合）"></a>4、Set （ 集合）</h3><h4 id="概念介绍-3"><a href="#概念介绍-3" class="headerlink" title="概念介绍"></a>概念介绍</h4><p>Redis 中的 set 是一个无序 Map，由于 Go 中没有 set 结构，所以这里只能类比 Java 中的 HashSet 概念。Redis 的 set 底层也是一个 Map 结构，不同于 Java 的是：alue 是一个 NULL。由于 set 的特性，它可以用于去重逻辑，这一点在 Java 中也经常使用。</p><h4 id="实战场景-3"><a href="#实战场景-3" class="headerlink" title="实战场景"></a>实战场景</h4><p>活动抽奖去重</p><h3 id="5、Sorted-Set-（有序集合）"><a href="#5、Sorted-Set-（有序集合）" class="headerlink" title="5、Sorted Set （有序集合）"></a>5、Sorted Set （有序集合）</h3><h4 id="概念介绍-4"><a href="#概念介绍-4" class="headerlink" title="概念介绍"></a>概念介绍</h4><p><code>Redis</code> 中的 <code>zset</code> 是一个比较特殊的数据结构（跳跃列表），也就是我们了解到的跳表，底层由于 set 的特性保证了 value 唯一，同时也给了 value 一个得分，所谓的有序其实就是根据这个得分来排序。至于跳跃表如何插入，其实内部采用了一个随机策略。</p><h4 id="实战场景-4"><a href="#实战场景-4" class="headerlink" title="实战场景"></a>实战场景</h4><p>榜单，总榜，热榜</p><h3 id="6、优秀资料"><a href="#6、优秀资料" class="headerlink" title="6、优秀资料"></a>6、优秀资料</h3><p><a href="https://www.zhihu.com/question/433475778/answer/1612399018" target="_blank" rel="noopener">《给你一个亿的keys，Redis如何统计？》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis多节点的Redlock算法</title>
    <url>/post/b2f8602.html</url>
    <content><![CDATA[<blockquote><p>Redis多节点的Redlock算法 ~</p></blockquote><a id="more"></a><h3 id="一、Redlock出现的背景"><a href="#一、Redlock出现的背景" class="headerlink" title="一、Redlock出现的背景"></a>一、Redlock出现的背景</h3><p>在单Matster-Slave的Redis系统中，正常情况下Client向Master获取锁之后同步给Slave，如果<strong>Client获取锁成功之后Master节点挂掉</strong>，并且<strong>未将该锁同步到Slave</strong>，之后在Sentinel的帮助下Slave升级为Master但是并没有之前未同步的锁的信息，此时如果有新的Client要在新Master获取锁，那么将<strong>可能出现两个Client持有同一把锁的问题</strong>。如果遇到这种情况下，就会涉及到Redlock算法。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210421231529.jpg" alt=""></p><h3 id="二、Redlock算法过程"><a href="#二、Redlock算法过程" class="headerlink" title="二、Redlock算法过程"></a>二、Redlock算法过程</h3><p>在Redis的分布式环境中，我们假设有<strong>N个完全互相独立的Redis节点</strong>，在N个Redis实例上使用与在Redis单实例下相同方法获取锁和释放锁。</p><p>现在假设有5个Redis主节点(<strong>大于3的奇数个</strong>)，这样基本保证他们不会同时都宕掉，获取锁和释放锁的过程中，客户端会执行以下操作:</p><ol><li><p>获取当前Unix时间，以毫秒为单位</p></li><li><p>依次尝试从5个实例，使用相同的key和具有唯一性的value获取锁当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间，这样可以避免客户端死等</p></li><li><p>客户端使用当前时间减去开始获取锁时间就得到获取锁使用的时间。当且仅当从半数以上的Redis节点取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功</p></li><li><p>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间 <strong>这个很重要</strong></p></li><li><p>如果因为某些原因，获取锁失败（没有在半数以上实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁，无论Redis实例是否加锁成功，因为可能服务端响应消息丢失了但是实际成功了，毕竟多释放一次也不会有问题</p></li></ol><p>上述的5个步骤是Redlock算法的重要过程！</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的淘汰策略</title>
    <url>/post/e0bb8399.html</url>
    <content><![CDATA[<blockquote><p>Redis 是否用到家，从这就能看出来，比如你 Redis 只能存 5G 数据，可是你写了 10G，那会删 5G 的数据。怎么删的，这个问题思考过么？这个就主要看Redis的淘汰策略 ~</p></blockquote><a id="more"></a><h3 id="一、内存淘汰策略"><a href="#一、内存淘汰策略" class="headerlink" title="一、内存淘汰策略"></a>一、内存淘汰策略</h3><p>Redis中通过MaxMemory参数来设定内存的使用上限，当Redis使用内存达到设定的最大值的时候，会根据配置文件中的策略选取要删除的key来删除，从 而给新的键值留出空间；目前Redis提供了8种的淘汰策略（默认的是maxmemory-policy no-enviction），<font color="red"> <strong>不同于之前的版本，Redis5.0为我们提供了八个不同的内存置换策略。很早之前提供了6种</strong> </font>在 Redis.conf 中有一行配置：</p><ol><li><p><strong>volatile-lru</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰；</p></li><li><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰；</p></li><li><p><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰；</p></li><li><p><strong>volatile-lfu</strong>：从已设置过期时间的数据集挑选使用频率最低的数据淘汰；</p></li><li><p><strong>allkeys-lru</strong>：从数据集中挑选最近最少使用的数据淘汰；<strong>（推荐）</strong></p></li><li><p><strong>allkeys-lfu</strong>：从数据集中挑选使用频率最低的数据淘汰；</p></li><li><p><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰；</p></li><li><p><strong>no-enviction</strong>：禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失；</p></li></ol><p>这八种大体上可以分为4中，<strong>LRU</strong>、<strong>LFU</strong>、<strong>Random</strong>、<strong>TTL</strong>。 当使用volatile-lru、volatile-random、volatile-ttl这三种策略时，如果没有key可以被淘汰，则和noeviction一样返回错误</p><h3 id="二、如何删除过期Key策略"><a href="#二、如何删除过期Key策略" class="headerlink" title="二、如何删除过期Key策略"></a>二、如何删除过期Key策略</h3><p>之前我们知道需要淘汰掉哪些过期Key，但是我们应该怎么去淘汰这些过期key呢？有3种删除的操作策略：</p><h4 id="1、定时删除"><a href="#1、定时删除" class="headerlink" title="1、定时删除"></a>1、定时删除</h4><p><strong>每个设置过期时间的key都需要创建一个定时器</strong>，到过期时间就会立即清除。</p><p>优点:可以立即清除过期的数据，对内存很友好。</p><p>缺点：会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</p><h4 id="2、惰性删除"><a href="#2、惰性删除" class="headerlink" title="2、惰性删除"></a>2、惰性删除</h4><p><strong>只有当访问一个key时，才会判断该key是否已过期，过期则清除</strong>。</p><p>优点：不过多占用CPU资源去做过期处理</p><p>缺点：该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</p><h4 id="3、定期删除"><a href="#3、定期删除" class="headerlink" title="3、定期删除"></a>3、定期删除</h4><p>首先：redis中，每个库（0-15）都有一个<strong>expires字典</strong>，它会保存所有设置了过期时间的key的过期时间数据。</p><p>定期过期是说的：每隔一定的时间，会扫描一定数量的库（比如0-15号库其中几个库）的expires字典中一定数量的key，并清除其中已过期的key。</p><p>定期删除是上面两种方案的折中方案，每隔一段时间来删除过期键，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响，除此之外，还有效的减少内存的浪费；但是该策略的难点在于间隔时长，这个需要根据自身业务情况来进行设置；</p><p><font color="#44448"><strong>Redis目前采用的是定期删除+惰性删除策略。</strong></font></p><blockquote><ol><li><p>为什么不用定时删除策略?</p><p>定时删除，用一个定时器来负责监视 Key，过期则自动删除。虽然内存及时释放，但是十分消耗 CPU 资源。在大并发请求下，CPU 要将时间应用在处理请求，而不是删除 Key，因此没有采用这一策略。</p></li><li><p>定期删除+惰性删除如何工作?</p><p>定期删除，Redis 默认每个 100ms 检查，有过期 Key 则删除。需要说明的是，Redis 不是每个 100ms 将所有的 Key 检查一次，而是随机抽取进行检查。如果只采用定期删除策略，会导致很多 Key 到时间没有删除。于是，惰性删除派上用场。</p><p>采用定期删除+惰性删除就没其他问题了么</p><p>不是的，如果定期删除没删除掉 Key。并且你也没及时去请求 Key，也就是说惰性删除也没生效。这样，Redis 的内存会越来越高。那么就应该采用内存淘汰机制。</p></li></ol></blockquote><h3 id="三、如何获取及设置内存淘汰策略"><a href="#三、如何获取及设置内存淘汰策略" class="headerlink" title="三、如何获取及设置内存淘汰策略"></a>三、如何获取及设置内存淘汰策略</h3><p>1、获取当前内存淘汰策略：如果默认没有更改的话就是默认的<strong>noeviction</strong>策略。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config get maxmemory-policy</span><br></pre></td></tr></table></figure><p>2、设置淘汰策略</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><h3 id="四、选择合适的淘汰策略"><a href="#四、选择合适的淘汰策略" class="headerlink" title="四、选择合适的淘汰策略"></a>四、选择合适的淘汰策略</h3><p>① <u>如果分为热数据与冷数据, 推荐使用 allkeys-lru 策略</u>；</p><p>​ 也就是说其中一部分key经常被读写. 如果不确定具体的业务特征, 那么 allkeys-lru 是一个很好的选择。</p><p>② <u>如果需要循环读写所有的key, 或者各个key的访问频率差不多, 可以使用 allkeys-random 策略</u>；</p><p>​ 即读写所有元素的概率差不多。</p><p>③ <u>如果要让 Redis 根据 TTL 来筛选需要删除的key, 请使用 volatile-ttl 策略</u>。</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210415111426.png" style="zoom:75%"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAop原理</title>
    <url>/post/a49369ea.html</url>
    <content><![CDATA[<blockquote><p>SpringAop原理 ~</p></blockquote><a id="more"></a><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Spring AOP全称为 <code>Spring Aspect-Oriented Programming</code> ，即面向切面编程，AOP不是一种技术，实际上是编程思想。凡是符合AOP思想的技术，都可以看成是AOP的实现。是运行时织入的，那么运行时织入到底是怎么实现的呢？</p><p>答案就是<strong>代理对象</strong>。代理对象又可以分为 <strong>静态代理</strong> 和 <strong>动态代理</strong>。</p><ul><li><strong>静态代理</strong>：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。</li><li><strong>动态代理</strong>：在程序运行时，运用反射机制动态创建而成。</li></ul><p>Spring AOP 使用<strong>动态代理</strong>技术在运行期间织入增强的代码，主要有两种代理机制：<code>基于JDK的动态代理</code>、<code>基于cglib的动态代理</code>。</p><p>JDK本身只提供接口的代理，而不支持类的代理。</p><blockquote><p><code>AOP</code> 思想： 基于代理思想，对原来目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象，调用增强功能的代码，从而对原有业务方法进行增强 ！</p></blockquote><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用。比如A对象要做一件事情，在没有代理前，自己来做，在对A代理后，由A的代理类B来做。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210426113023.png" alt=""></p><h4 id="一、静态代理模式"><a href="#一、静态代理模式" class="headerlink" title="一、静态代理模式"></a>一、静态代理模式</h4><p>静态代理就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在<strong>运行前</strong>就已经确定。</p><p>静态代理虽然保证了业务类只需关注逻辑本身，代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理。</p><p>再者，如果增加一个方法，除了实现类需要实现这个方法外，所有的代理类也要实现此方法。增加了代码的维护成本。那么要如何解决呢？答案是使用动态代理。</p><h4 id="二、动态代理模式"><a href="#二、动态代理模式" class="headerlink" title="二、动态代理模式"></a>二、动态代理模式</h4><p>动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是<strong>运行时</strong>才确定的。</p><p>动态代理也分为两类：基于接口的代理和基于继承的代理，两类实现的代表是：<strong>JDK代理</strong> 与 <strong>CGlib代理</strong>。</p><h5 id="（1）JDK代理模式"><a href="#（1）JDK代理模式" class="headerlink" title="（1）JDK代理模式"></a>（1）JDK代理模式</h5><p>　　JDK动态代理主要涉及java.lang.reflect包下的两个类：Proxy类和InvocationHandler接口。</p><p>　　JDK代理实现的三个要点：</p><p>　　① 通过Java.lang.reflect.Proxy类来动态生成代理类；</p><p>　　② 代理类要实现InvocationHandler接口；</p><p>　　③ JDK代理只能基于接口进行动态代理的；</p><h5 id="（2）CGLib代理模式"><a href="#（2）CGLib代理模式" class="headerlink" title="（2）CGLib代理模式"></a>（2）CGLib代理模式</h5><p>　CGLib采用非常底层的字节码技术（<code>ASM</code>一个短小精悍的字节码操作框架）来操作字节码生成新的类，可以为一个类创建子类，并在子类中采用方法去技术拦截所有的父类方法的调用，并顺势织入横切逻辑。</p><p>在实际开发中，可能需要对没有实现接口的类增强，用JDK动态代理的方式就没法实现。采用Cglib动态代理可以对没有实现接口的类产生代理，<strong>实际上是生成了目标类的子类来增强。</strong></p><p>　CGLib和JDK的原理类似，也是通过方法去反射调用目标对象的方法。</p><h3 id="Spring-如何切换使用"><a href="#Spring-如何切换使用" class="headerlink" title="Spring 如何切换使用"></a>Spring 如何切换使用</h3><p>1、<strong>若目标对象实现了接口，Spring默认使用JDK的动态代理。</strong></p><p>　　优点：因为有接口，所以使系统更加松耦合；</p><p>　　缺点：为每一个目标类创建接口；</p><p>2、<strong>若目标对象没有实现任何接口，Spring使用CGLib进行动态代理。</strong></p><p>　　优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。</p><p>　　缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。</p><p>3、<strong>若目标对象实现了接口，但是强制cglib代理，则使用cglib代理</strong>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 强制使用cglib代理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span>(proxyTargetClass = tree)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AopDemoApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(AopDemoApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Aop</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的持久化</title>
    <url>/post/195f683a.html</url>
    <content><![CDATA[<blockquote><p>Redis的持久化，RDB和AOF ~</p></blockquote><a id="more"></a><p>由于Redis是内存数据库，即断电或者重启数据丢失。所以我们为了防止这种情况，那么我们就应该去配置redis的持久化。redis 持久化分为 rdb 和 aof，接下来我们来详细看看这两种方式。</p><h3 id="一、RDB-（Redis-DataBase）"><a href="#一、RDB-（Redis-DataBase）" class="headerlink" title="一、RDB  （Redis DataBase）"></a>一、RDB （Redis DataBase）</h3><h4 id="1、基本思想"><a href="#1、基本思想" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>在指定的时间间隔内，将内存中的数据保存到磁盘中，我们称之为快照，进行恢复时，直接将快照文件读取到内存中，称为快照（snapshot）。</p><p>redis 会单独 fork 一个子进程进行持久化，子进程遍历hash table，利用copy on write（写时复制的思想），把数据保存下来，写到一个临时文件中，待持久化过程都结束了再用这个临时文件代替上次的临时文件。整个过程中，主线程是不进行任何 I/O 操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对数据的强一致性很敏感的话，rdb 方式可能比 aof机制更加高效，但是如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。</p><h4 id="2、触发机制"><a href="#2、触发机制" class="headerlink" title="2、触发机制"></a>2、触发机制</h4><ol><li><p>save 命令</p><p>当客户端向Redis server发送save命令请求进行持久化时，由于Redis是用一个主线程来处理所有,save命令会阻塞Redis server处理其他客户端的请求，直到数据同步完成。</p></li><li><p>bgsave命令</p><p>与save命令不同，bgsave是异步执行的，当执行bgsave命令之后，Redis主进程会fork 一个子进程将数据保存到rdb文件中，同步完数据之后，对原有文件进行替换，然后通知主进程表示同步完成。</p></li><li><p>自动触发</p><p>除了手动触发RDB持久化，Redis内部还存在自动触发机制，</p></li></ol><h4 id="3、RDB优缺点"><a href="#3、RDB优缺点" class="headerlink" title="3、RDB优缺点"></a>3、RDB优缺点</h4><p>优点：</p><ol><li>适合大规模的数据恢复！在恢复数据的时候比 aof 快。</li><li>由于主进程不进行 I/O 操作，修改操作比 aof 快。</li></ol><p>缺点：</p><ol><li>需要一定的时间间隔进行操作。如果redis意外宕机了，那么可能最后一次的备份数据就没有了。</li><li>每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端</li></ol><h3 id="二、AOF（Append-Only-File）"><a href="#二、AOF（Append-Only-File）" class="headerlink" title="二、AOF（Append Only File）"></a>二、AOF（Append Only File）</h3><h4 id="1、基本思想-1"><a href="#1、基本思想-1" class="headerlink" title="1、基本思想"></a>1、基本思想</h4><p>以日志的形式记录每个写操作，将 Redis执行过的指令全部记录下来（读操作不记录），只追加内容到文件中但不可以改写文件，redis再次启动的时候，会将日志文件中所有的指令 从到到尾的再次执行一遍。这个时候也是 fork子进程去做。</p><p>aof模式保存的文件是appendonly.aof 文件。我们可以 使用 vim 观看里边的内容，可以看到内容，可读性非常的好，如果我们不小心flushdb，只要新的 aof 没有被保存，我们还可以通过 移除aof文件末尾的 flushdb 就可以撤销这个操作。</p><p>如果 append.aof 文件内容格式错误，那么此时是打不开 redis的，但是我们可以通过 redis-aof-check来恢复。</p><h4 id="2、触发机制-1"><a href="#2、触发机制-1" class="headerlink" title="2、触发机制"></a>2、触发机制</h4><ol><li><p>手动触发 执行bgrewriteaof命令。</p></li><li><p>根据配置自动触发</p></li></ol><h4 id="3、AOF优缺点"><a href="#3、AOF优缺点" class="headerlink" title="3、AOF优缺点"></a>3、AOF优缺点</h4><p>优点：</p><ul><li>默认开启 每秒同步一次，就算丢失数据，那么也只会丢失最后一秒的数据</li><li>每次重启都会去 加载和执行 aof文件，所以说它的数据完整性要比 rdb好。</li></ul><p>缺点：</p><ul><li>相对于 rdb的保存方式，aof的文件大小远远大于 rdb文件（aof 文件默认采取无限增加，不过也不用担心过大，如果太大了redis也会进行重写的，不要怕，redis都想到了！），修复速度也慢</li><li>aof 的效率比 rdb高，毕竟是保存到日志文件中，涉及 I/O 了。</li></ul><h3 id="三、RDB-VS-AOF-对比"><a href="#三、RDB-VS-AOF-对比" class="headerlink" title="三、RDB  VS  AOF 对比"></a>三、RDB VS AOF 对比</h3><p>通常，如果你要想提供很高的数据保障性，那么建议你<strong>同时使用两种持久化方式</strong>。如果你可以接受灾难带来的几分钟的数据丢失，那么你可以仅使用RDB。很多用户仅使用了AOF，但是我们建议，既然RDB可以时不时的给数据做个完整的快照，并且提供更快的重启，所以最好还是也使用RDB。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Spring如何解决循环依赖</title>
    <url>/post/f98f7bc7.html</url>
    <content><![CDATA[<blockquote><p>Spring如何解决循环依赖 ~</p></blockquote><a id="more"></a><p>Spring为了解决单例的循环依赖问题，整个缓存分为三级。</p><ol><li><code>singletonObjects</code>，一级缓存，存储的是所有创建好了的单例Bean<strong>（单例池）</strong>；</li><li><code>earlySingletonObjects</code>，完成实例化，但是还未进行属性注入及初始化的对象<strong>（早期曝光对象）</strong>；</li><li><code>singletonFactories</code>，提前暴露的一个单例工厂，二级缓存中存储的就是从这个工厂中获取到的对象<strong>（早期曝光对象工厂）</strong>；</li></ol><blockquote><p><strong>具体步骤：</strong></p><ol><li>拿bean的时候先从<code>singletonObjects</code>（⼀级缓存）中获取；</li><li>如果获取不到，并且对象正在创建中，就从<code>earlySingletonObjects</code>（二级缓存）中获取；</li><li>如果还是获取不到就从<code>singletonFactories</code>（三级缓存）中获取，然后将获取到的对象放到，<code>earlySingletonObjects</code>（二级缓存）中，并且将bean对应的<code>singletonFactories</code>（三级缓存）清除。</li><li>bean初始化完毕，放到<code>singletonObjects</code>（⼀级缓存）中，将bean对应的<code>earlySingletonObjects</code>（二级缓存）清除。</li></ol></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Spring的事务是什么？与数据库的事务是否一样？</title>
    <url>/post/5c5b3589.html</url>
    <content><![CDATA[<blockquote><p>Spring的事务是什么？与数据库的事务是否一样？今天咱们就学那么一小下 ~</p></blockquote><a id="more"></a> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20210412004840680.png" alt="我们是最棒的！"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Vuex使用</title>
    <url>/post/a47b42bc.html</url>
    <content><![CDATA[<blockquote><p>vuex如何使用 ~</p></blockquote><a id="more"></a><h4 id="一、为什么要用Vuex"><a href="#一、为什么要用Vuex" class="headerlink" title="一、为什么要用Vuex"></a>一、为什么要用Vuex</h4><p>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><h5 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h5><p>单向数据流只能从一个方向来修改状态。下图是单向数据流的极简示意：</p><ul><li>State 驱动应用的数据源</li><li>View 以声明的方式将state映射到试图</li><li>Action 响应在view上的用户输入导致的状态变化</li></ul><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210419220445.png" style="zoom:33%"><p>举个栗子：如一个父组件有两个子组件，分别为1和2。父组件向子组件传递数据，两个组件都接收到了父组件传递过来的数据，在组件1中修改父组件传递过来的数据，子组件2和父组件的值不会发生变化。这就是单向的数据流，子组件不能直接改变父组件的状态。但是如果父组件改变相应的数据，两个子组件的数据也会发生相应的改变。</p><h5 id="双向数据流"><a href="#双向数据流" class="headerlink" title="双向数据流"></a>双向数据流</h5><p>由MVVM框架实现，MVVM的组成：View，ViewModel，Model。其中View 和 Model不能直接通信，要通过ViewModel来进行通信。</p><p>举个栗子：例如，当Model部分数据发生改变时，由于vue中Data Binding将底层数据和Dom层进行了绑定，ViewModel通知View层更新视图；当在视图 View数据发生变化也会同步到Model中。View和Model之间的同步完全是自动的，不需要人手动的操作DOM</p><h5 id="Vuex的使用场景"><a href="#Vuex的使用场景" class="headerlink" title="Vuex的使用场景"></a>Vuex的使用场景</h5><ul><li>购物车</li><li>数据字典</li><li>登录注册</li></ul><h4 id="二、Vuex初始化步骤"><a href="#二、Vuex初始化步骤" class="headerlink" title="二、Vuex初始化步骤"></a>二、Vuex初始化步骤</h4><p>第一步：安装Vuex</p><p><code>npm install vuex --save</code></p><p>第二步：在main.js中加入Vuex</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">"./App.vue"</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">"./router"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">"./store"</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line">Vue.prototype.$store = store</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;  <span class="comment">// 登录判断</span></span><br><span class="line">    <span class="keyword">if</span> (store.state.userInfo || to.path === <span class="string">"/login"</span>) &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next(&#123;</span><br><span class="line">            path: <span class="string">"/login"</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    store,</span><br><span class="line">    router,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">"#app"</span>)</span><br></pre></td></tr></table></figure><p>第三步：在src目录中新建store文件夹，在该文件夹下新建store.js文件。index.js中代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">"vuex"</span></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">"./state"</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">"./mutations"</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">"./getters"</span></span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">"./actions"</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">// store是一个仓库, 里面存储着我们要进行管理的变量,和对于变量所有的相关操作.</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    actions,</span><br><span class="line">    mutations</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><h4 id="三、Vuex核心概念—State"><a href="#三、Vuex核心概念—State" class="headerlink" title="三、Vuex核心概念—State"></a>三、Vuex核心概念—State</h4><p>State：意思为“状态”，是Vuex状态管理的数据源</p><p>state存放是一个对象，存放了全部的应用层级的状态，主要是存放组件之间传递的变量，类似于组件中的data</p><p>第四步：在store文件夹中新建state.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    userInfo: <span class="string">""</span>, <span class="comment">// 登录用户信息</span></span><br><span class="line">    userStatus: <span class="string">""</span>, <span class="comment">// 0 -&gt; 普通 1 -&gt; vip 2-&gt; 高级vip</span></span><br><span class="line">    vipLevel: <span class="string">""</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="state用法"><a href="#state用法" class="headerlink" title="state用法"></a>state用法</h5><ul><li><p>直接使用和计算属性使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; $store.state.userInfo &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;&#123; userInfo &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">  </span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        userInfo() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.userInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>mapState辅助函数</li></ul><p>作用：可以获取多个state的值，不用写重复的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; userStatus &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;&#123; vipLevel &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">"vuex"</span>;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      computed: &#123;</span><br><span class="line">         ...mapState([<span class="string">"userStatus"</span>, <span class="string">"vipLevel"</span>])</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="四、Vuex核心概念—Getter"><a href="#四、Vuex核心概念—Getter" class="headerlink" title="四、Vuex核心概念—Getter"></a>四、Vuex核心概念—Getter</h4><p>Getter：Getter 的作用与 filters 有一些相似，可以将 State 进行过滤后输出。</p><p>Getters相当于vue中的计算属性，通过getters进一步处理，得到我们想要的值，而且允许传参，第一个参数就是state。</p><p>并且就像计算属性一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会重新计算。</p><p>第五步：在store文件夹中新建getter.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    memberInfo(state) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (state.userStatus) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"普通会员"</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"vip会员"</span></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">`高级V<span class="subst">$&#123;state.vipLevel&#125;</span>会员`</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"普通会员"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Getter用法"><a href="#Getter用法" class="headerlink" title="Getter用法"></a>Getter用法</h5><ul><li>直接使用和计算属性使用</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; $store.getters.userInfo &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;&#123;&#123; userInfo &#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: &#123;</span><br><span class="line">        userInfo() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.userInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><ul><li>mapState辅助函数</li></ul><p>作用：可以获取多个state的值，不用写重复的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">        &lt;p&gt;&#123;&#123; memberInfo &#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">import &#123; mapGetters &#125; from "vuex";</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">   export default &#123;</span></span><br><span class="line"><span class="regexp">      computed: &#123;</span></span><br><span class="line"><span class="regexp">         ...mapGetters(["memberInfo"])</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">   &#125;;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h4 id="五、Vuex核心概念—Mutations"><a href="#五、Vuex核心概念—Mutations" class="headerlink" title="五、Vuex核心概念—Mutations"></a>五、Vuex核心概念—Mutations</h4><p>第六步：在store文件夹中新建mutations.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    login(state, v) &#123;</span><br><span class="line">        state.userInfo = v</span><br><span class="line">    &#125;,</span><br><span class="line">    setMemberInfo(state, v) &#123;</span><br><span class="line">        state.userStatus = v.userStatus</span><br><span class="line">        state.vipLevel = v.vipLevel</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="六、Vuex核心概念—Actions"><a href="#六、Vuex核心概念—Actions" class="headerlink" title="六、Vuex核心概念—Actions"></a>六、Vuex核心概念—Actions</h4><p>第七步：在store文件夹中新建actions.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">"any-promise"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    buyVip(&#123; commit &#125;, e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// mock api 交互</span></span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 修改本地state</span></span><br><span class="line">                commit(<span class="string">"setMemberInfo"</span>, &#123;</span><br><span class="line">                    userStatus: e.userStatus,</span><br><span class="line">                    vipLevel: e.vipLevel</span><br><span class="line">                &#125;)</span><br><span class="line">                resolve(<span class="string">"购买成功"</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    getFreeVip(&#123; commit, state &#125;) &#123;</span><br><span class="line">        <span class="comment">// mock api 交互</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (state.userStatus === <span class="number">0</span>) &#123;</span><br><span class="line">                    commit(<span class="string">"setMemberInfo"</span>, &#123;</span><br><span class="line">                        userStatus: <span class="number">1</span>,</span><br><span class="line">                        vipLevel: <span class="number">0</span></span><br><span class="line">                    &#125;)</span><br><span class="line">                    resolve(<span class="string">"分享成功，您已获得一个月的高级vip会员"</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolve(<span class="string">"分享成功"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>如何防止Redis脑裂导致数据丢失？</title>
    <url>/post/6bcc7fe0.html</url>
    <content><![CDATA[<blockquote><p>如何防止Redis脑裂导致数据丢失 ~</p></blockquote><a id="more"></a><h3 id="什么是脑裂"><a href="#什么是脑裂" class="headerlink" title="什么是脑裂"></a>什么是脑裂</h3><p>所谓的集群脑裂就是，由于redis master节点和redis salve节点和 <strong>Sentinel（哨兵）</strong>处于不同的网络分区，使得sentinel没有能够心跳感知到master，所以通过选举的方式提升了一个salve为master，这样就存在了两个master，就像大脑分裂了一样，这样会导致客户端还在old master那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将old master降为salve，这时再从新master同步数据，这会导致大量数据丢失。</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210415223127.png" style="zoom:33%"><h3 id="为什么会发生脑裂会导致数据丢失"><a href="#为什么会发生脑裂会导致数据丢失" class="headerlink" title="为什么会发生脑裂会导致数据丢失"></a>为什么会发生脑裂会导致数据丢失</h3><p>主从切换后，从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步。而在全量同步执行的最后阶段，原主库需要清空本地的数据，加载新主库发送的 RDB 文件，这样一来，原主库在主从切换期间保存的新写数据就丢失了。</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210415223132.png" style="zoom:33%"><h3 id="如何应对脑裂问题"><a href="#如何应对脑裂问题" class="headerlink" title="如何应对脑裂问题"></a>如何应对脑裂问题</h3><p>Redis 已经提供了两个配置项来限制主库的请求处理，分别是 min-slaves-to-write 和 min-slaves-max-lag。</p><ul><li>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量；</li><li>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）。</li></ul><blockquote><p>比如有三个从库，那么第一个参数表示最少的salve节点为3个，第二个参数表示数据复制和同步的延迟不能超过10秒</p></blockquote><p>我们可以把 min-slaves-to-write 和 min-slaves-max-lag 这两个配置项搭配起来使用，分别给它们设置一定的阈值，假设为 N 和 T。这两个配置项组合后的要求是，主库连接的从库中至少有 N 个从库，和主库进行数据复制时的 ACK 消息延迟不能超过 T 秒，否则，主库就不会再接收客户端的请求了，这样可以避免大量数据丢失。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized和Lock</title>
    <url>/post/879be548.html</url>
    <content><![CDATA[<blockquote><p>Synchronized和Lock ~</p></blockquote><a id="more"></a><h3 id="一、Synchronized"><a href="#一、Synchronized" class="headerlink" title="一、Synchronized"></a>一、Synchronized</h3><h4 id="实例用法"><a href="#实例用法" class="headerlink" title="实例用法"></a>实例用法</h4><ol><li><p>当synchronized作用在<strong>普通方法</strong>时，锁是当前实例对象；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>当synchronized作用在<strong>静态方法</strong>时，锁是当前类的class对象；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">someStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>当synchronized作用在<strong>代码块</strong>时，锁是括号括起来的对象；</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (someObject) &#123;</span><br><span class="line">        <span class="comment">// 代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><h5 id="1、锁定代码块时"><a href="#1、锁定代码块时" class="headerlink" title="1、锁定代码块时"></a>1、锁定代码块时</h5><p>底层使用指令码方式来控制锁的，是利用 <strong>monitorenter 和 monitorexit 这两个字节码指令</strong>。它们分别位于同步代码块的开始和结束位置。当 jvm 执行到 monitorenter 指令时，当前线程试图获取 monitor 对象的所有权，如果未加锁或者已经被当前线程所持有，就把锁的计数器 + 1；当执行 monitorexit 指令时，锁计数器 - 1；当锁计数器为 0 时，该锁就被释放了。如果获取 monitor 对象失败，该线程则会进入阻塞状态，直到其他线程释放锁。</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210430171745.png" style="zoom:33%"><h5 id="2、锁定方法时"><a href="#2、锁定方法时" class="headerlink" title="2、锁定方法时"></a>2、锁定方法时</h5><p>即无需通过字节码指令来控制的，它实现在<strong>方法调用和返回操作</strong>之中。JVM 可以从方法常量池中的方法表结构 (method_info Structure) 中的 <strong>ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法</strong>。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有 <code>monitor</code>（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成 (无论是正常完成还是非正常完成) 时释放 <code>monitor</code>。</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210430171745.png" style="zoom:33%"><p>两种同步方式本质上没有区别，只是方法的同步是一种隐式的方式来实现，无需通过字节码来完成。两个指令的执行是<code>JVM</code>通过调用操作系统的互斥原语<code>mutex</code>来实现，被阻塞的线程会被挂起、等待重新调度，会导致“用户态和内核态”两个态之间来回切换，对性能有较大影响。</p><p>在 <strong>JDK1.6 之前</strong>，synchronized 是一个重量级锁，性能比较差。从 JDK1.6 开始，为了减少获得锁和释放锁带来的性能消耗，synchronized 进行了优化，引入了偏向锁和轻量级锁的概念。</p><p>所以<strong>从 JDK1.6 开始</strong>，锁一共会有四种状态，锁的状态根据竞争激烈程度从低到高分别是: 无锁状态-&gt;偏向锁状态-&gt;轻量级锁状态-&gt;重量级锁状态。这几个状态会随着锁竞争的情况逐步升级。为了提高获得锁和释放锁的效率，锁可以升级但是不能降级。</p><h3 id="二、Lock"><a href="#二、Lock" class="headerlink" title="二、Lock"></a>二、Lock</h3><h4 id="实例用法-1"><a href="#实例用法-1" class="headerlink" title="实例用法"></a>实例用法</h4><p><strong>Lock 有三个实现类，一个是 ReentrantLock, 另两个是 ReentrantReadWriteLock 类中的两个静态内部类 ReadLock 和 WriteLock。</strong>一般使用ReentrantLock类做为锁。在加锁和解锁处需要通过<code>lock()</code>和<code>unlock()</code>显示指出。所以一般会在finally块中写unlock()以防死锁。</p><h4 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h4><ul><li>lock 的存储结构：一个 <strong>int 类型状态值（用于锁的状态变更）</strong>，一个<strong>双向链表</strong>（用于存储等待中的线程）</li><li>lock 获取锁的过程：本质上是通过 <strong>CAS 来获取状态值修改</strong>，如果当场没获取到，会将该线程放在线程<strong>等待链表</strong>中。</li><li>lock 释放锁的过程：修改<strong>状态值</strong>，调整等待链表。</li></ul><blockquote><p><strong>1.unsafe类</strong></p><p>Unsafe类使java拥有了像C语言的指针一样操作内存空间的能力（操作对象的内存空间即能够操作对象里面的内容；但是这个UnSafe类不太安全；如果使用不当会出现一些比较危险的事情；所以java官方并不推荐使用；并且在jdk当中也无法找到此类；只能够通过反射的方式才能够找到该类），同时也带来了指针的问题。 过渡的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。 Unsafe对象不能直接调用，只能通过反射获得。</p><p><strong>2.CAS概述和作用</strong></p><p>CAS的全称是 Compare And Swap（比较再交换）。（确切一点称之为：比较并且相同再做交换） 是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。</p><p><strong>3.CAS的作用是：CAS可以将比较和交换转换为原子操作，这个原子操作直接由处理器CPU保证。</strong> CAS可以保证共享变量赋值时的原子操作； <strong>CAS在操作时依赖三个值；内存中的值V、旧的预估值X、要修改的新值B，</strong>如果旧的预估值X等于内存中的值V，就将新的值B保存到内存中；替换这个内存中的值V；</p></blockquote><p>底层是CAS乐观锁+自旋，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。</p><blockquote><p><strong>1.定义</strong></p><p>AQS（AbstractQuenedSynchronizer ），<strong>抽象的队列式同步器</strong>。</p><p><strong>2.AQS 的核心思想</strong></p><p>如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就需要一套<strong>线程阻塞等待</strong>以及<strong>被唤醒</strong>时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁（CLH 锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性）</strong>实现的，即将暂时获取不到锁的线程加入到<strong>队列</strong>中。</p><p>AQS 是将每一条请求共享资源的<strong>线程</strong>封装成一个 CLH 锁队列的一个<strong>结点（Node）</strong>，来实现锁的分配。</p><p><strong>3.实现</strong></p><p>AQS 基于 <strong>CLH 队列</strong>，用 <strong>volatile 修饰共享变量 state</strong>，线程通过 CAS 去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p></blockquote><h3 id="三、区别"><a href="#三、区别" class="headerlink" title="三、区别"></a>三、区别</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210502193043.png" alt=""></p><h3 id="四、优秀资料"><a href="#四、优秀资料" class="headerlink" title="四、优秀资料"></a>四、优秀资料</h3><p><a href="https://zhuanlan.zhihu.com/p/477313563" target="_blank" rel="noopener">《sychronized实现原理》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>lock</category>
        <category>MultiThread</category>
      </categories>
      <tags>
        <tag>lock</tag>
      </tags>
  </entry>
  <entry>
    <title>Jvm堆溢出和栈溢出</title>
    <url>/post/79459fb9.html</url>
    <content><![CDATA[<blockquote><p>Jvm堆溢出和栈溢出介绍 ~</p></blockquote><a id="more"></a><h3 id="一、堆溢出"><a href="#一、堆溢出" class="headerlink" title="一、堆溢出"></a>一、堆溢出</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>在<code>jvm</code>运行<code>java</code>程序时，如果程序运行所需要的内存大于系统的堆最大内存(<code>-Xmx</code>)，就会出现堆溢出问题。</p><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 介绍:执行该段代码需要大于10m内存空间</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadOverflow</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">			Byte[] bytes = <span class="keyword">new</span> Byte[<span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">			list.add(bytes);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"成功"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置该程序的jvm参数信息</span></span><br><span class="line">-Xms1m -Xmx10m -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="line">初始堆内存和最大可以堆内存 Gc详细日志信息</span><br></pre></td></tr></table></figure><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>1、检查是否存在大对象的分配，最有可能的是大数组分配</p><p>2、通过<code>jmap</code>命令，把堆内存dump下来，使用mat工具分析一下，检查是否存在内存泄露的问题</p><p>3、如果没有找到明显的内存泄露，使用 <code>-Xmx</code> 加大堆内存</p><p>4、还有一点容易被忽略，检查是否有大量的自定义的 <code>Finalizable</code> 对象，也有可能是框架内部提供的，考虑其存在的必要性</p><h3 id="二、栈溢出"><a href="#二、栈溢出" class="headerlink" title="二、栈溢出"></a>二、栈溢出</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p>线程请求的栈深度大于虚拟机允许的最大深度，出现 <code>StackOverflowError</code></p><p>虚拟机在扩展栈深度时，无法申请到足够的内存空间，出现 <code>OutOfMemoryError</code></p><h4 id="报错-1"><a href="#报错-1" class="headerlink" title="报错"></a>报错</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError : unable to create <span class="keyword">new</span> <span class="keyword">native</span> Thread</span><br></pre></td></tr></table></figure><h4 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟栈内存溢出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackOverflowTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归调用自己，直到栈溢出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">"调用深度：%d，id：%s"</span>, count, UUID.randomUUID().toString()));</span><br><span class="line">        count++;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h4><p>1、通过 <code>-Xss</code>降低 一个线程堆栈的最大内存容量</p><h3 id="三、永久代-元空间溢出"><a href="#三、永久代-元空间溢出" class="headerlink" title="三、永久代/元空间溢出"></a>三、永久代/元空间溢出</h3><h4 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h4><p>永久代是 <code>HotSot</code> 虚拟机对方法区的具体实现，存放了被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等。</p><p><code>JDK8</code>后，元空间替换了永久代，元空间使用的是本地内存，还有其它细节变化：</p><p><strong>字符串常量由永久代转移到堆中、永久代相关的<code>JVM</code>参数已移除。</strong>出现永久代或元空间的溢出的原因可能有如下几种：</p><p>1、在<code>Java7</code>之前，频繁的错误使用<code>String.intern</code>方法</p><p>2、生成了大量的代理类，导致方法区被撑爆，无法卸载</p><p>3、应用长时间运行，没有重启</p><h4 id="报错-2"><a href="#报错-2" class="headerlink" title="报错"></a>报错</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space java.lang.OutOfMemoryError: Metaspace</span><br></pre></td></tr></table></figure><h4 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaspaceTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">          <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">               list.add(String.valueOf(i++).intern());</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h4><p>永久代/元空间 溢出的原因比较简单，解决方法有如下几种：</p><p>1、检查是否永久代空间或者元空间设置的过小，通过命令行设置 <code>-XX: MaxMetaSpaceSize</code> 增加 <code>metaspace</code> 大小</p><p>2、检查代码中是否存在大量的反射操作</p><p>3、dump之后通过 mat 检查是否存在大量由于反射生成的代理类</p><p>4、放大招，重启<code>JVM</code></p><p>5、为服务器分配更多的内存</p><h3 id="四、内存溢出和内存泄露"><a href="#四、内存溢出和内存泄露" class="headerlink" title="四、内存溢出和内存泄露"></a>四、内存溢出和内存泄露</h3><p><strong>内存溢出</strong>：申请内存空间,超出最大堆内存空间。<strong>程序无法申请到可用的内存</strong></p><p>情况：死循环</p><p><strong>内存泄露</strong>：其实包含内存溢出,堆内存空间被无用对象占用没有及时释放，导致占用内存，最终导致内存泄露。<strong>程序占用的内存无法释放</strong></p><p>情况：静态static修饰对象、递归</p><p>解决：减少常量的定义(具体看服务器内存情况)</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>索引失效场景以及原理</title>
    <url>/post/8aeb2b52.html</url>
    <content><![CDATA[<blockquote><p>索引失效场景以及原理 ~</p></blockquote><a id="more"></a><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、索引的优点"><a href="#1、索引的优点" class="headerlink" title="1、索引的优点"></a>1、索引的优点</h4><ul><li>大大减少了服务器需要扫描的数据量；</li><li>可以帮助服务器避免排序或减少使用临时表排序；</li><li>索引可以随机I/O变为顺序I/O；</li></ul><h4 id="2、索引的缺点"><a href="#2、索引的缺点" class="headerlink" title="2、索引的缺点"></a>2、索引的缺点</h4><ul><li>需要占用磁盘空间，因此冗余低效的索引将占用大量的磁盘空间；</li><li>降低DML性能，对于数据的任意增删改都需要调整对应的索引，甚至出现索引分裂；</li><li>索引会产生相应的碎片，产生维护开销；</li></ul><h4 id="3、适合建立索引的情况"><a href="#3、适合建立索引的情况" class="headerlink" title="3、适合建立索引的情况"></a>3、适合建立索引的情况</h4><ul><li>主键自动建立唯一索引；</li><li>继续作为查询条件的细分；</li><li>查询中与其他表关联的细分，外键关系建立索引；</li><li>单键/组合索引的选择问题，高并发下潜在创造组合索引；</li><li>查询中排序的划分，排序通过索引访问显着提高排序速度；</li><li>查询中统计或分组长度；</li></ul><h4 id="4、不适合建立索引的情况"><a href="#4、不适合建立索引的情况" class="headerlink" title="4、不适合建立索引的情况"></a>4、不适合建立索引的情况</h4><ul><li>表记录太少；</li><li>经常增删改的表；</li><li>数据重复且分布均匀的表分区，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）；</li><li>频繁更新的字段不适合创建索引（会加重IO负担）；</li><li>where条件里用不到的字段，不创建索引；</li></ul><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><ol><li>普通索引：最基本的索引，它没有任何限制</li><li>唯一索引：索引列的值必须唯一，且不能为空，如果是组合索引，则列值的组合必须唯一。</li><li>主键索引：特殊的索引，唯一的标识一条记录，不能为空，一般用primary key来约束。</li><li>联合索引：在多个字段上建立索引，能够加速查询到速度</li></ol><h3 id="索引失效场景"><a href="#索引失效场景" class="headerlink" title="索引失效场景"></a>索引失效场景</h3><ol><li><p>在查询条件中使用OR；（ <strong>注意：</strong>要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引）(<em>这也是为什么尽量少用or的原因</em>)</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210422224829.png" alt=""></p></li><li><p>最佳左前缀原则——如果是复合索引，要遵守最左前缀原则。指的是查询要从索引的最左前列开始并且不跳过索引中的列;</p></li><li><p>mysql中like查询是以%开头，索引会失效变成全表扫描，覆盖索引；</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210422224846.png" alt=""></p></li><li><p>需要类型转换;</p></li><li><p>where中索引列有运算;</p></li><li><p>where中索引列使用了函数;</p></li><li><p>如果mysql觉得全表扫描更快时（数据少）;</p></li><li><p>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引;</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210422224902.png" alt=""></p></li></ol><h3 id="查看索引的使用情况"><a href="#查看索引的使用情况" class="headerlink" title="查看索引的使用情况"></a>查看索引的使用情况</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<br><code>handler_read_key</code>:这个值越高越好，越高表示使用索引查询到的次数<br><code>handler_read_rnd_next</code>:这个值越高，说明查询低效</p></blockquote><h3 id="优秀资料"><a href="#优秀资料" class="headerlink" title="优秀资料"></a>优秀资料</h3><p><a href="https://developer.aliyun.com/article/831250" target="_blank" rel="noopener">《MySQL索引详解（一文搞懂）》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Sql</category>
      </categories>
      <tags>
        <tag>Sql</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot安装Jar到Maven本地仓库</title>
    <url>/post/64582e15.html</url>
    <content><![CDATA[<blockquote><p>SpringBoot安装Jar到Maven本地仓库 ~</p></blockquote><a id="more"></a><h3 id="一、通过maven命令将Jar打入本地仓库"><a href="#一、通过maven命令将Jar打入本地仓库" class="headerlink" title="一、通过maven命令将Jar打入本地仓库"></a>一、通过maven命令将Jar打入本地仓库</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=(jar包的位置) -DgroupId=groupId(分组) -DartifactId=artifactId(jar名称) -Dversion=version(版本号) -Dpackaging=jar</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -Dfile=C:\Users\test-core.jar -DgroupId=org.shuaizi -DartifactId=core -Dversion=1.0.0.RELEASE -DpomFile=C:\Users\Desktop\pom.xml -Dpackaging=jar</span><br></pre></td></tr></table></figure><p>其中 <code>-DpomFile=C:\Users\Desktop\pom.xml</code>是指定声明pom文件，如果不指定有可能会问题：导入的项目无法找到<code>Jar</code>里面依赖的额外的<code>Jar</code>。</p><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>分组<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jar名<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二、在本项目文件夹中引入"><a href="#二、在本项目文件夹中引入" class="headerlink" title="二、在本项目文件夹中引入"></a>二、在本项目文件夹中引入</h3><h4 id="1、在resources下面新建lib文件夹或者jar文件夹，并把jar包文件放到这个目录下"><a href="#1、在resources下面新建lib文件夹或者jar文件夹，并把jar包文件放到这个目录下" class="headerlink" title="1、在resources下面新建lib文件夹或者jar文件夹，并把jar包文件放到这个目录下"></a>1、在resources下面新建lib文件夹或者jar文件夹，并把jar包文件放到这个目录下</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210603102318.png" alt=""></p><h4 id="2、增加pom文件"><a href="#2、增加pom文件" class="headerlink" title="2、增加pom文件"></a>2、增加pom文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	    <span class="comment">&lt;!-- @author Mr.Jia @date 2021/6/3 10:18  groupId、artifactId、version 均可自定义 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ckfinder<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-lib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    		<span class="comment">&lt;!-- @author Mr.Jia @date 2021/6/3 10:19  路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/jar/json-lib-2.3-jdk15.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3、如果把项目打成jar，同时把本地jar包也引入进去"><a href="#3、如果把项目打成jar，同时把本地jar包也引入进去" class="headerlink" title="3、如果把项目打成jar，同时把本地jar包也引入进去"></a>3、如果把项目打成jar，同时把本地jar包也引入进去</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            maven打包时会将外部引入的jar包（比如在根目录下或resource文件下新加外部jar包）打包到项目jar，</span></span><br><span class="line"><span class="comment">            在服务器上项目才能运行，不加此配置，本地可以运行，</span></span><br><span class="line"><span class="comment">            因为本地可以再lib下找到外部包，但是服务器上jar中是没有的。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap底层原理详解(JDK1.8)</title>
    <url>/post/96aa5774.html</url>
    <content><![CDATA[<blockquote><p>HashMap底层原理详解(JDK1.8) ~</p></blockquote><a id="more"></a><h3 id="一、HashMap的存储过程"><a href="#一、HashMap的存储过程" class="headerlink" title="一、HashMap的存储过程"></a>一、HashMap的存储过程</h3><p><code>JDK1.8 之前</code> <code>HashMap</code> 由 <strong>数组+链表</strong> 组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突<strong>(两个对象调用的<code>hashCode</code>方法计算的哈希码值一致导致计算的数组索引值相同)</strong> 而存在的（“拉链法”解决冲突）；</p><p><code>JDK1.8 以后</code>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储，即 <strong>数组+链表+红黑树</strong>。</p><blockquote><p>数组：<br>数组具有遍历快，增删慢的特点。数组在堆中是一块连续的存储空间，遍历时数组的首地址是知道的（首地址=首地址+元素字节数 * 下标），所以遍历快（数组遍历的时间复杂度为O(1) ）；增删慢是因为，当在中间插入或删除元素时，会造成该元素后面所有元素地址的改变，所以增删慢（增删的时间复杂度为O(n) ）。</p><p>链表：<br>链表具有增删快，遍历慢的特点。链表中各元素的内存空间是不连续的，一个节点至少包含节点数据与后继节点的引用，所以在插入删除时，只需修改该位置的前驱节点与后继节点即可，链表在插入删除时的时间复杂度为O(1)。但是在遍历时，get(n)元素时，需要从第一个开始，依次拿到后面元素的地址，进行遍历，直到遍历到第n个元素（时间复杂度为O(n) ），所以效率极低。</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1.存取无序的；</p><p>2.键和值位置都可以是null，但是键位置只能是一个null；</p><p>3.键位置是唯一的，底层的数据结构控制键的；</p><p>4.<code>jdk1.8</code>前数据结构是：链表 + 数组； <code>jdk1.8</code>之后是 ： 链表 + 数组 + 红黑树；</p><p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询；</p><h4 id="Put执⾏过程"><a href="#Put执⾏过程" class="headerlink" title="Put执⾏过程"></a>Put执⾏过程</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li><p>先通过hash值计算出key映射到哪个桶；</p></li><li><p>如果桶上没有碰撞冲突，则直接插入；</p></li><li><p>如果出现碰撞冲突了，则需要处理冲突：</p><p>a：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p><p>b：否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；</p></li><li><p>如果桶中存在重复的键，则为该键替换新值value；</p></li><li><p>如果size大于阈值threshold，则进行扩容。</p></li></ol><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主要调用putVal方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。</span></span><br><span class="line"><span class="comment">    2）(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是null</span></span><br><span class="line"><span class="comment">    3）(n = tab.length) == 0 表示将数组的长度0赋值给n,然后判断n是否等于0，n等于0</span></span><br><span class="line"><span class="comment">    	由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化。</span></span><br><span class="line"><span class="comment">    	并将初始化好的数组长度赋值给n.</span></span><br><span class="line"><span class="comment">    4）执行完n = (tab = resize()).length，数组tab每个空间都是null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中</span></span><br><span class="line"><span class="comment">    2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给节点p</span></span><br><span class="line"><span class="comment">    3) (p = tab[i = (n - 1) &amp; hash]) == null 判断节点位置是否等于null，如果为null，则执行代码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的节点放入该位置的桶中</span></span><br><span class="line"><span class="comment">        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//创建一个新的节点存入到桶中</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 执行else说明tab[i]不等于null，表示这个位置已经有值了。</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        比较桶中第一个元素(数组中的结点)的hash值和key是否相等</span></span><br><span class="line"><span class="comment">        1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个hash值是否相等</span></span><br><span class="line"><span class="comment">        说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。</span></span><br><span class="line"><span class="comment">                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                    &#123;</span></span><br><span class="line"><span class="comment">                        return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的</span></span><br><span class="line"><span class="comment">        2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key 比较两个key的地址值是否相等</span></span><br><span class="line"><span class="comment">        3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	说明：两个元素哈希值相等，并且key的值也相等</span></span><br><span class="line"><span class="comment">                	将旧的元素整体对象赋值给e，用e来记录</span></span><br><span class="line"><span class="comment">                */</span> </span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等或者key不相等；判断p是否为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 说明是链表节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            	1)如果是链表的话需要遍历到最后节点然后插入</span></span><br><span class="line"><span class="comment">            	2)采用循环遍历的方式，判断链表中是否有重复的key</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	1)e = p.next 获取p的下一个元素赋值给e</span></span><br><span class="line"><span class="comment">                	2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键将该键值对插入链表中。</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    	1）创建一个新的节点插入到尾部</span></span><br><span class="line"><span class="comment">                    	 p.next = newNode(hash, key, value, null);</span></span><br><span class="line"><span class="comment">                    	 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) </span></span><br><span class="line"><span class="comment">                    	 &#123;</span></span><br><span class="line"><span class="comment">                                return new Node&lt;&gt;(hash, key, value, next);</span></span><br><span class="line"><span class="comment">                         &#125;</span></span><br><span class="line"><span class="comment">                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个节点肯定是								null</span></span><br><span class="line"><span class="comment">                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    1)节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树</span></span><br><span class="line"><span class="comment">                    2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历节点的个数。值是0表示第一个节点，1表示第二个节点。。。。7表示第八个节点，加上数组中的的一个元素，元素个数是9</span></span><br><span class="line"><span class="comment">                    	TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7</span></span><br><span class="line"><span class="comment">                    	如果binCount的值是7(加上数组中的的一个元素，元素个数是9)</span></span><br><span class="line"><span class="comment">                    	TREEIFY_THRESHOLD - 1也是7，此时转换红黑树</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插					  入的元素的key值是否相等</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                		要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了</span></span><br><span class="line"><span class="comment">                		直接执行下面的if语句去替换去 if (e != null) </span></span><br><span class="line"><span class="comment">                	*/</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                	说明新添加的元素和当前节点不相等，继续查找下一个节点。</span></span><br><span class="line"><span class="comment">                	用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line"><span class="comment">        	也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值</span></span><br><span class="line"><span class="comment">        	这里完成了put方法的修改功能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                <span class="comment">//e.value 表示旧值  value表示新值 </span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//修改记录次数</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 判断实际大小是否大于threshold阈值，如果超过则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Get执行过程"><a href="#Get执行过程" class="headerlink" title="Get执行过程"></a>Get执行过程</h4><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h5><ol><li><p>通过hash值获取该key映射到的桶</p></li><li><p>桶上的key就是要查找的key,则直接找到并返回</p></li><li><p>桶上的key不是要找的key,则查看后续的节点：</p><p>a.如果后续节点是红黑树节点，通过调用红黑树的方法根据key获取value；O(logn)</p><p>b.如果后续节点是链表节点，则通过循环遍历链表根据key获取value；O(n)</p></li></ol><h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get方法主要调用的是getNode方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空并且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        	判断数组元素是否相等</span></span><br><span class="line"><span class="comment">        	根据索引的位置检查第一个元素</span></span><br><span class="line"><span class="comment">        	注意：总是检查第一个元素</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 如果不是第一个元素，判断是否有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取节点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">getTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>).find(h, k, <span class="keyword">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;<span class="comment">//找到之后直接返回</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="comment">//递归查找</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、扩容机制"><a href="#二、扩容机制" class="headerlink" title="二、扩容机制"></a>二、扩容机制</h3><p>默认情况下，<code>HashMap</code> 初始容量是16，负载因子为 0.75。这里并没有默认阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明），即<code>threshold = capacity * loadFactor</code>。在 <code>HashMap</code> 中，桶数组的长度均是2的幂，阈值大小为桶数组长度与负载因子的乘积。当 <code>HashMap</code> 中的键值对数量超过阈值时，进行扩容。<code>HashMap</code> 的扩容机制与其他变长集合的套路不太一样，<code>HashMap</code> 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（ 如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//得到当前数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果当前数组等于null长度返回0，否则返回当前数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">// 当前阀值点 默认是12(16*0.75)</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果老的数组长度大于0</span></span><br><span class="line">    <span class="comment">// 开始计算扩容后的大小</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 修改阈值为int的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	没超过最大值，就扩充为原来的2倍</span></span><br><span class="line"><span class="comment">        	1) (newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量</span></span><br><span class="line"><span class="comment">        	2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 老阈值点大于0 直接赋值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 老阈值赋值给新的数组长度</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用默认值16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY; </span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize最大上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的阀值 默认原来是12 乘以2之后变为24</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">//创建新的哈希表</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">//newCap是新的数组长度--》32</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//判断旧数组是否等于空</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="comment">//遍历旧的哈希表的每个桶，重新计算桶里元素的新位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//原来的数据赋值为null 便于GC回收</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//判断数组是否有下一个引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//判断是否是红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//说明是红黑树来处理冲突的，则调用相关方法把树分开</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 采用链表处理冲突</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">//通过上述讲解的原理来计算节点的新位置</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        next = e.next;</span><br><span class="line">                     	<span class="comment">//这里来判断如果等于true e这个节点在resize之后不需要移动位置</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码总共做了3件事，分别是：</p><ol><li>计算新桶数组的容量 newCap 和新阈值 newThr</li><li>根据计算出的 newCap 创建新的桶数组，桶数组 table 也是在这里进行初始化的</li><li>将键值对节点重新映射到新的桶数组里。如果节点是 <code>TreeNode</code> 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li></ol><h3 id="三、常见面试题"><a href="#三、常见面试题" class="headerlink" title="三、常见面试题"></a>三、常见面试题</h3><ol><li><p><strong>面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</strong></p><p>对于key的hashCode做hash操作，无符号右移16位然后做异或运算。<br>还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。</p></li><li><p><strong>面试题：当两个对象的hashCode相等时会怎么样？</strong></p><p>会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。</p></li><li><p><strong>面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</strong></p><p>只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。</p></li><li><p><strong>面试题：如果两个键的hashcode相同，如何存储键值对？</strong></p><p>hashcode相同，通过equals比较内容是否相同。<br>相同：则新的value覆盖之前的value<br>不相同：则将新的键值对添加到哈希表中</p></li><li><p><strong>面试题：1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p><p><code>JDK 1.8</code> 以前 <code>HashMap</code> 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 <code>HashMap</code> 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 <code>HashMap</code> 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 <code>O(n)</code>，完全失去了它的优势。针对这种情况，<code>JDK 1.8</code> 中引入了 红黑树（查找时间复杂度为 <code>O(logn)</code>）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p></li></ol><h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a href="https://blog.csdn.net/qq_41822345/article/details/104436909" target="_blank" rel="noopener">《HashMap最新总结（JDK1.8）》</a><br><a href="https://www.toutiao.com/article/6727624027327693316/?group_id=6727624027327693316" target="_blank" rel="noopener">《HashMap源码分析（jdk1.8，保证你能看懂）》</a><br><a href="https://juejin.cn/post/6844904090711900168" target="_blank" rel="noopener">《一个HashMap能跟面试官扯上半个小时》</a><br><a href="http://www.tianxiaobo.com/2018/01/18/HashMap-%E6%BA%90%E7%A0%81%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90-JDK1-8/#37-%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">《HashMap 源码详细分析（JDK1.8）》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>SpringBoot静态资源记录</title>
    <url>/post/8116169e.html</url>
    <content><![CDATA[<blockquote><p>SpringBoot 静态资源（踩坑） ~</p></blockquote><a id="more"></a><h3 id="一、静态资源加载"><a href="#一、静态资源加载" class="headerlink" title="一、静态资源加载"></a>一、静态资源加载</h3><ol><li>先查看源码，通过查看<code>WebMvcAutoConfiguration</code>类找到<code>addResourceHandlers()</code>方法，如下：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">		logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Duration cachePeriod = <span class="keyword">this</span>.resourceProperties.getCache().getPeriod();</span><br><span class="line">	CacheControl cacheControl = <span class="keyword">this</span>.resourceProperties.getCache()</span><br><span class="line">			.getCachecontrol().toHttpCacheControl();</span><br><span class="line">	<span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">		customizeResourceHandlerRegistration(registry</span><br><span class="line">				.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">				.addResourceLocations(<span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">				.setCachePeriod(getSeconds(cachePeriod))</span><br><span class="line">				.setCacheControl(cacheControl));</span><br><span class="line">	&#125;</span><br><span class="line">	String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">	<span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">		customizeResourceHandlerRegistration(</span><br><span class="line">				registry.addResourceHandler(staticPathPattern)</span><br><span class="line">						.addResourceLocations(getResourceLocations(</span><br><span class="line">						<span class="keyword">this</span>.resourceProperties.getStaticLocations()))</span><br><span class="line">						.setCachePeriod(getSeconds(cachePeriod))</span><br><span class="line">						.setCacheControl(cacheControl));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>然后通过<code>this.resourceProperties.getStaticLocations()</code>找到默认的配置项，如下代码：</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;</span><br><span class="line">			<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/resources/"</span>,</span><br><span class="line">			<span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br></pre></td></tr></table></figure><p>静态资源加载顺序：<strong>META/resources &gt; resources &gt; static &gt; public</strong>，去里面找是否存在相应的资源，如果有则直接返回。</p><p>上面介绍的是<code>SpringBoot</code>提供的默认的资源目录，其实也就是我们为啥把文件放到static下，文件就能访问的原因。但是我们有时候有特殊需求不需要用他的目录，下面我们进行自定义资源目录。</p><h3 id="二、自定义资源文件目录"><a href="#二、自定义资源文件目录" class="headerlink" title="二、自定义资源文件目录"></a>二、自定义资源文件目录</h3><h4 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h4><p>通过配置文件直接配置。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 静态文件请求匹配方式</span></span><br><span class="line"><span class="meta">spring.mvc.static-path-pattern</span>=<span class="string">/**</span></span><br><span class="line"><span class="comment"># 修改默认的静态寻址资源目录</span></span><br><span class="line"><span class="meta">spring.resources.static-locations</span>= <span class="string">classpath:/templates/,classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用缓存</span></span><br><span class="line"><span class="meta">spring.resources.chain.cache</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># Enable the Spring Resource Handling chain. Disabled by default</span></span><br><span class="line"><span class="meta">spring.resources.chain.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 资源缓存时间，单位秒，30天</span></span><br><span class="line"><span class="meta">spring.resources.cache-period</span>=<span class="string">2592000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启gzip压缩</span></span><br><span class="line"><span class="meta">spring.resources.chain.gzipped</span>=<span class="string">true </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定版本号</span></span><br><span class="line"><span class="comment"># 开启版本控制策略，默认为false</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定要应用的版本的路径，多个以逗号分隔，默认为:[/**]</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.paths</span>=<span class="string">/static  </span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.fixed.version</span>=<span class="string">1.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 MD5 作为版本号</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.enable</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 指定要应用的版本的路径，多个以逗号分隔，默认为:[/**]</span></span><br><span class="line"><span class="meta">spring.resources.chain.strategy.content.paths</span>=<span class="string">/**</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设定Session的追踪模式(cookie, url, ssl)</span></span><br><span class="line"><span class="meta">server.session.tracking-modes</span>=<span class="string">cookie</span></span><br></pre></td></tr></table></figure><h4 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h4><p>通过实现<code>WebMvcConfigurer</code>进行配置。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcesStaticConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置静态资源映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registration)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// addResourceHandler是指你想在url请求的路径</span></span><br><span class="line">        <span class="comment">// 访问 http://127.0.0.1:8077/webTa/gateway/file/83a393c423544cb88d8859e3218c3bf6.jpg </span></span><br><span class="line">        <span class="comment">// 或者 http://127.0.0.1:8077/webTa/static/83a393c423544cb88d8859e3218c3bf6.jpg</span></span><br><span class="line">        <span class="comment">// 便可访问static文件夹下和/static/upload/ 文件夹下的文件。</span></span><br><span class="line">        ResourceHandlerRegistration registration = registry.addResourceHandler(<span class="string">"/static/**"</span>, <span class="string">"/gateway/file/**"</span>);</span><br><span class="line">        <span class="comment">// addResourceLocations是图片存放的真实路径，这里解析的就是static文件夹下和/static/upload/文件夹下的资源。</span></span><br><span class="line">        registration.addResourceLocations(<span class="string">"classpath:/static/"</span>, <span class="string">"file:/static/upload/"</span>);</span><br><span class="line">        <span class="comment">// 下面是兼容window系统添加的解析规则</span></span><br><span class="line">        String osName = <span class="string">"os.name"</span>;</span><br><span class="line">        String win = <span class="string">"win"</span>;</span><br><span class="line">        <span class="keyword">if</span> (System.getProperty(osName).toLowerCase().startsWith(win)) &#123;</span><br><span class="line">            registration.addResourceLocations(<span class="string">"file:///D:/static/upload/"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、静态资源额外配置"><a href="#三、静态资源额外配置" class="headerlink" title="三、静态资源额外配置"></a>三、静态资源额外配置</h3><h4 id="1-静态资源添加固定版本号"><a href="#1-静态资源添加固定版本号" class="headerlink" title="1.静态资源添加固定版本号"></a>1.静态资源添加固定版本号</h4><p>通过<code>.resourceChain(true)</code>可以开启缓存，静态文件就可以缓存到浏览器本地。同时也存在一个问题，如果服务器静态文件修改，浏览器端在未过期之前是不会重新加载文件的。此时需要通过版本号来控制。spring boot版本号支持两种，一种是文件md5，另一种是固定版本号。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设静态资源存放在 classpath:/static，且映射的 url 为 /static。</span></span><br><span class="line">   registry.addResourceHandler(<span class="string">"/static/**"</span>).addResourceLocations(<span class="string">"classpath:/static"</span>)</span><br><span class="line">           <span class="comment">// resourceChain(false) 的作用：是否开启缓存</span></span><br><span class="line">           .resourceChain(<span class="keyword">false</span>)</span><br><span class="line">           <span class="comment">// 添加 VersionResourceResolver ，且指定版本号</span></span><br><span class="line">           .addResolver(<span class="keyword">new</span> VersionResourceResolver()</span><br><span class="line">               .addFixedVersionStrategy(<span class="string">"1.0.0"</span>, <span class="string">"/**"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-静态资源添加MD5作为版本号"><a href="#2-静态资源添加MD5作为版本号" class="headerlink" title="2.静态资源添加MD5作为版本号"></a>2.静态资源添加MD5作为版本号</h4><p>md5方式，spring boot启动时会计算每个静态文件的md5值并缓存，浏览器访问时每个静态文件后缀前加上md5值作为版本号，如果服务器md5值改变则浏览器重新加载。（需要重启应用才会重新生成md5）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">"/static/**"</span>)</span><br><span class="line">                .addResourceLocations(<span class="string">"classpath:/static/"</span>)</span><br><span class="line">                .resourceChain(<span class="keyword">false</span>)</span><br><span class="line">                .addResolver(<span class="keyword">new</span> VersionResourceResolver()</span><br><span class="line">                    .addContentVersionStrategy(<span class="string">"/**"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-开启gzip-压缩"><a href="#3-开启gzip-压缩" class="headerlink" title="3.开启gzip 压缩"></a>3.开启gzip 压缩</h4><p>为了降低传输的数据量，可以对资源进行压缩。</p><p><strong>PS ： 请求头中的 Content-Encoding 要包含 gzip</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">   registry.addResourceHandler(<span class="string">"/static/**"</span>)</span><br><span class="line">           .addResourceLocations(<span class="string">"classpath:/static/"</span>)</span><br><span class="line">           .resourceChain(<span class="keyword">false</span>)</span><br><span class="line">           .addResolver(<span class="keyword">new</span> EncodedResourceResolver())</span><br><span class="line">           .addResolver(<span class="keyword">new</span> VersionResourceResolver().addContentVersionStrategy(<span class="string">"/**"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、踩坑"><a href="#四、踩坑" class="headerlink" title="四、踩坑"></a>四、踩坑</h3><ol><li>在计算机，针对<code>/static/upload</code>会解析成文件，<code>/static/upload/</code>才会解析成文件夹。最后以斜杠结尾的，才被认定为是一个文件夹。</li><li>如果定义<code>addResourceLocations</code>图片存放的真实路径为：<code>&quot;file:/static/&quot;</code>，但是实际想访问<code>/static/upload/</code>里面的一个文件的时候，那么访问路径就要增加文件夹的名称。比如 <code>http://127.0.0.1:8077/webTa/static/upload/83a393c423544cb88d8859e3218c3bf6.jpg</code> 。</li></ol><h3 id="五、资料"><a href="#五、资料" class="headerlink" title="五、资料"></a>五、资料</h3><p><a href="https://blog.csdn.net/u010811939/article/details/86300048" target="_blank" rel="noopener">《Spring Boot 静态资源处理》</a><br><a href="https://www.cnblogs.com/iiot/p/9647653.html" target="_blank" rel="noopener">《Spring boot web 静态资源缓存配置》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>线程的几种状态</title>
    <url>/post/bb12c453.html</url>
    <content><![CDATA[<blockquote><p>线程的几种状态 ~</p></blockquote><a id="more"></a><p>线程在一定条件下，状态会发生变化。线程一共有以下几种状态：</p><ol><li><strong>初始(NEW)</strong>：新创建了一个线程对象，但还没有调用start()方法。</li><li><strong>运行(RUNNABLE)</strong>：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li><strong>阻塞(BLOCKED)</strong>：表示线程阻塞于锁。</li><li><strong>等待(WAITING)</strong>：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li><strong>超时等待(TIMED_WAITING)</strong>：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li><strong>终止(TERMINATED)</strong>：表示该线程已经执行完毕。</li></ol><p><strong>源码如下：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        NEW,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">         * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">         * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">         * such as processor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        RUNNABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">         * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">         * following methods:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">         * perform a particular action.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">         * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">         * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">         * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">         * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">         * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">         * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">         * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">         * The thread has completed execution.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Java类加载顺序、双亲委派机制</title>
    <url>/post/94bf0674.html</url>
    <content><![CDATA[<blockquote><p>Java类加载顺序、双亲委派机制 ~</p></blockquote><a id="more"></a><h3 id="一、类加载过程"><a href="#一、类加载过程" class="headerlink" title="一、类加载过程"></a>一、类加载过程</h3><p>类加载一共分为七个过程，他们的具体的顺序是：<strong>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化</strong>。</p><ul><li>加载（Loading）</li><li>验证（Verification）</li><li>准备（Preparation）</li><li>解析（Resolution）</li><li>初始化（Initialization）</li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><h3 id="二、类加载器"><a href="#二、类加载器" class="headerlink" title="二、类加载器"></a>二、类加载器</h3><p>在<code>JVM</code>加载class文件主要由类加载器完成,不同类库下的class加载的加载器也不相同，<code>JVM</code>中有以下<strong>四</strong>种类加载器:</p><ol><li><strong><code>BootstrapClassLoader</code></strong>：引导类加载器: 负责加载支撑<code>JVM</code>运行的位于JRE的lib目录下的核心类库，比如<code>rt.jar</code>、<code>charsets.jar</code> 等。</li><li><strong><code>ExtClassLoader</code></strong>：拓展类加载器: 负责加载支撑<code>JVM</code>运行的位于<code>JRE</code>的lib目录下的ext扩展目录中的JAR类包,以上两种均加载<code>JRE</code>中的。</li><li><strong><code>AppClassLoader</code></strong>：应用程序类加载器:负责加载<code>ClassPath</code>路径下的类包，主要就是加载自己写的类。</li><li><strong><code>CustomClassLoader</code></strong>：自定义类加载器: 负责加载用户自定义路径下的类包。</li></ol><h3 id="三、双亲委派机制"><a href="#三、双亲委派机制" class="headerlink" title="三、双亲委派机制"></a>三、双亲委派机制</h3><h4 id="1、JDK9-之前的双亲委派模式"><a href="#1、JDK9-之前的双亲委派模式" class="headerlink" title="1、JDK9 之前的双亲委派模式"></a>1、<code>JDK9</code> 之前的双亲委派模式</h4><p><code>JDK9</code> 之前的 Java 应用都是由「启动类加载器」、「扩展类加载器」、「应用程序类加载器」这三种类加载器互相配合来完成加载的，如果有需要还可以加入自定义的类加载器来进行拓展。</p><blockquote><p>自定义的类加载器场景：典型的如增加除了磁盘位置之外的 Class 文件来源，或者通过类加载器实现类的隔离、重载等功能。</p></blockquote><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a><strong>工作过程</strong></h5><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求<strong>委派给父类加载器</strong>去完成，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a><strong>好处</strong></h5><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210602163208.png" alt=""></p><h4 id="2-JDK9-的双亲委派模式"><a href="#2-JDK9-的双亲委派模式" class="headerlink" title="2. JDK9 的双亲委派模式"></a>2. <code>JDK9</code> 的双亲委派模式</h4><p><code>JDK9</code> 之后的 Java 应用都是由「启动类加载器」、「平台类加载器」、「应用程序类加载器」这三种类加载器互相配合来完成加载的，如果有需要还可以加入自定义的类加载器来进行拓展。</p><p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210602163442.png" style="zoom:80%"><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210602163739.png" style="zoom:80%"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 缓存雪崩、击穿、穿透</title>
    <url>/post/31e3efbb.html</url>
    <content><![CDATA[<blockquote><p>Redis 缓存雪崩、击穿、穿透 ~</p></blockquote><a id="more"></a><h2 id="一、描述介绍"><a href="#一、描述介绍" class="headerlink" title="一、描述介绍"></a>一、描述介绍</h2><p><strong>缓存击穿</strong>是指 <u>缓存中没有但数据库中有的数据</u> （一般是缓存时间到期），一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p><p><strong>缓存穿透</strong>是指 <u>缓存和数据库中都没有的数据</u>，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><p><strong>缓存雪崩</strong>是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><blockquote><p>缓存雪崩是指⼤量缓存失效，缓存击穿是指热点数据的缓存失效</p></blockquote><h2 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h2><h4 id="1、缓存击穿"><a href="#1、缓存击穿" class="headerlink" title="1、缓存击穿"></a>1、缓存击穿</h4><ul><li>设置热点数据永远不过期</li><li>互斥锁</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单机模式可以用ReentrantLock，如果是分布式的话，最好使用分布式锁处理。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lock LOCK = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getData</span><span class="params">(String key)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//从缓存中读取数据</span></span><br><span class="line">        String result = getDataFromRedis(key);</span><br><span class="line">        <span class="comment">//如果缓存中不存在，就去查询数据库，否则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取锁，获取成功以后，就去查询数据库，否则就等会儿再次查询缓存</span></span><br><span class="line">            <span class="comment">//此处如果根据key值加锁更好，即线程A从数据库获取key1的数据，并不影响线程B从数据库获取key2的数据</span></span><br><span class="line">            <span class="keyword">if</span> (LOCK.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//从数据库获取数据</span></span><br><span class="line">                    result = getDataFromMySql(key);</span><br><span class="line">                    <span class="comment">//更新缓存数据</span></span><br><span class="line">                    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        setDataToCache(key, result);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 释放锁</span></span><br><span class="line">                    LOCK.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 睡一会</span></span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">                result = getData(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getDataFromRedis</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"从Redis获取缓存数据，key为：&#123;&#125;"</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Redis value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getDataFromMySql</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"从MySql获取数据，参数为：&#123;&#125;"</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MySql value"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDataToCache</span><span class="params">(String key, String result)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"设置Redis缓存,key为：&#123;&#125;，value为：&#123;&#125;"</span>, key, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、缓存穿透"><a href="#2、缓存穿透" class="headerlink" title="2、缓存穿透"></a>2、缓存穿透</h4><ul><li>接口层增加校验，对请求参数进⾏校验，不合理直接返回。如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截。</li><li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用），这样可以防止攻击用户反复用同一个id暴力攻击。</li><li><strong>布隆过滤器（Bloom Filter）</strong>原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新Redis再return（推荐使用）。</li><li>可以使用缓存空值并且设置快速过期的方式来作为一个兜底的方案(写法就是缓存空对象，针对空的数据，设置过期时间，比如10分钟，快速过期，防止太多的空值问题)。</li></ul><h4 id="3、缓存雪崩"><a href="#3、缓存雪崩" class="headerlink" title="3、缓存雪崩"></a>3、缓存雪崩</h4><ul><li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li><li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</li><li>设置热点数据永远不过期。</li><li>双缓存：我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。</li></ul><blockquote><p>一般避免以上情况发生我们从三个时间段去分析下：</p><ul><li>事前：<strong>Redis</strong> 高可用，主从+哨兵，<strong>Redis cluster</strong>，避免全盘崩溃。</li><li>事中：本地 <strong>ehcache</strong> 缓存 + <strong>Hystrix</strong> 限流+降级，避免 <strong>MySQL</strong> 被打死。</li><li>事后：<strong>Redis</strong> 持久化 <strong>RDB</strong>+<strong>AOF</strong>，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li><li>缓存的失效时间设置为随机值，避免同时失效。</li></ul><p><strong>好处：</strong><br>数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。 只要数据库不死，就是说，对用户来说，3/5 的请求都是可以被处理的。 只要有 3/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>VMware虚拟机Nat联网设置</title>
    <url>/post/f9e21a7.html</url>
    <content><![CDATA[<blockquote><p>VMware虚拟机Nat联网设置 ~</p></blockquote><a id="more"></a><h3 id="一、打开虚拟机网络编辑器"><a href="#一、打开虚拟机网络编辑器" class="headerlink" title="一、打开虚拟机网络编辑器"></a>一、打开虚拟机网络编辑器</h3><p>打开虚拟机网络编辑器如下：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210305142903.png" alt=""></p><p>打开Nat设置：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210305142909.png" alt=""></p><p>然后更改子网IP，再去更改NAT设置：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210305142914.png" alt=""></p><h3 id="二、查看windows环境的中VMnet8网络配置"><a href="#二、查看windows环境的中VMnet8网络配置" class="headerlink" title="二、查看windows环境的中VMnet8网络配置"></a>二、查看windows环境的中VMnet8网络配置</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210305142917.png" alt=""></p><p>按照图片更改IP地址、子网掩码、网关；</p><h3 id="三、查询当前虚拟机使用的网卡"><a href="#三、查询当前虚拟机使用的网卡" class="headerlink" title="三、查询当前虚拟机使用的网卡"></a>三、查询当前虚拟机使用的网卡</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip add</span><br></pre></td></tr></table></figure><p>执行完命令以后，一般是可以看到两个网卡1.lo 2.enp0s3 我们就需要修改enp0s3的配置文件，这个配置文件的名称可能会有所不同，但是通常在只开一个网卡的时候，一般网卡2就是我们需要修改的网卡。</p><p>然后进入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts</span><br></pre></td></tr></table></figure><p>通过ls命令就可以找到与网卡2 同名的文件 ifcfg-enp0s3；</p><p>vim命令编辑改文件如下:</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line"><span class="meta">#</span><span class="bash"> IP的配置方法[none|static|bootp|dhcp]（引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议）</span></span><br><span class="line">BOOTPROTO=static</span><br><span class="line"><span class="meta">#</span><span class="bash">IP地址</span></span><br><span class="line">IPADDR=192.168.1.101</span><br><span class="line"><span class="meta">#</span><span class="bash">子网掩码</span></span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"><span class="meta">#</span><span class="bash">网关</span></span><br><span class="line">GATEWAY=192.168.0.115</span><br><span class="line"><span class="meta">#</span><span class="bash">域名解析器</span></span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=8.8.8.8</span><br><span class="line">DNS3=192.168.1.2</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_PEERDNS=yes</span><br><span class="line">IPV6_PEERROUTES=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no  </span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=eth0</span><br><span class="line"><span class="meta">#</span><span class="bash">随机id</span></span><br><span class="line">UUID=972a1eb3-049f-4db2-80f5-7d8fd28ef76f</span><br><span class="line"><span class="meta">#</span><span class="bash">接口名（设备,网卡）</span></span><br><span class="line">DEVICE=eth0</span><br><span class="line"><span class="meta">#</span><span class="bash">系统启动的时候网络接口是否有效（yes/no）</span></span><br><span class="line">ONBOOT=yes</span><br></pre></td></tr></table></figure><p>执行service network restart，最好是重启一下虚拟机。</p><h3 id="四、XShell连接测试"><a href="#四、XShell连接测试" class="headerlink" title="四、XShell连接测试"></a>四、XShell连接测试</h3><p>用xshell连接登录当前虚拟机，输入ip地址和登录密码。测试一下ping <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是否可以正常。如果成功，那就大功告成了。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>VMware</category>
      </categories>
      <tags>
        <tag>VMware</tag>
      </tags>
  </entry>
  <entry>
    <title>美国“蓝天使”飞行表演队</title>
    <url>/post/4ed7ff9d.html</url>
    <content><![CDATA[<blockquote><p>美国海军“蓝天使”飞行表演队 ~</p></blockquote><a id="more"></a><p><strong>“蓝天使”飞行表演队是目前世界上唯一的一支属于海军航空兵的飞行表演队。它正式成立于1946年4月，正值第二次世界大战结束后一年，大本营在佛罗里达州的杰克逊维尔海军航空兵训练基地。“蓝天使”比“雷鸟”还要早建队7年，也是世界上组建最早的特技飞行表演队。</strong></p><h3 id="超级喜欢"><a href="#超级喜欢" class="headerlink" title="超级喜欢"></a>超级喜欢</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712112935.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712112948.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712112953.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712112957.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712113001.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712113014.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712113005.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712113008.jpeg" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210712113011.jpeg" alt=""></p><h3 id="高清图库"><a href="#高清图库" class="headerlink" title="高清图库"></a>高清图库</h3><p><a href="https://tieba.baidu.com/p/2182796655?pid=29768437816&red_tag=0907330958#29768437816" target="_blank" rel="noopener">《美国海军“蓝天使”系列高清图 Ⅰ 》</a><br><a href="https://zhuanlan.zhihu.com/p/32574065" target="_blank" rel="noopener">《美国海军“蓝天使”系列高清图 Ⅱ 》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>蓝天使</category>
      </categories>
      <tags>
        <tag>蓝天使</tag>
      </tags>
  </entry>
  <entry>
    <title>经典笔记整理</title>
    <url>/post/6d2214c4.html</url>
    <content><![CDATA[<blockquote><p>Redis、RabbitMq、TCP、Spring、Mysql、Linux思维导向图整理 ~</p></blockquote><a id="more"></a><h3 id="一、RabbitMQ"><a href="#一、RabbitMQ" class="headerlink" title="一、RabbitMQ"></a>一、RabbitMQ</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210817102609.png" alt="RabbitMq"></p><h3 id="二、LINUX"><a href="#二、LINUX" class="headerlink" title="二、LINUX"></a>二、LINUX</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210817102625.png" alt="Linux"></p><h3 id="三、Mysql"><a href="#三、Mysql" class="headerlink" title="三、Mysql"></a>三、Mysql</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210817102643.png" alt="Mysql"></p><h3 id="四、Spring"><a href="#四、Spring" class="headerlink" title="四、Spring"></a>四、Spring</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210817102633.png" alt="Spring笔记"></p><h3 id="五、TCP-IP"><a href="#五、TCP-IP" class="headerlink" title="五、TCP\IP"></a>五、TCP\IP</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210817102637.png" alt="TCP:IP"></p><h3 id="六、Redis"><a href="#六、Redis" class="headerlink" title="六、Redis"></a>六、Redis</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210817102652.png" alt="Redis"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Mind map</category>
      </categories>
      <tags>
        <tag>Mind map</tag>
      </tags>
  </entry>
  <entry>
    <title>Idea代码提交分支合并</title>
    <url>/post/42c5ff4c.html</url>
    <content><![CDATA[<blockquote><p>Idea代码提交分支合并介绍 ~</p></blockquote><a id="more"></a><h4 id="一、功能简述"><a href="#一、功能简述" class="headerlink" title="一、功能简述"></a>一、功能简述</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20211223152307.png" alt=""></p><ol><li><strong>checkout</strong>：检出；</li><li><strong>new branch from selected</strong> ：从当前选择的分支，重新创建一个新的分支；</li><li><strong>Compare with current</strong>：跟当前的分支比较；</li><li><strong>show diff with working tree</strong>：比较并展示到idea窗口中；</li><li><strong>rebase current onto selected</strong>：从当前已选择的分支rebase；</li><li><strong>merge selected into current</strong>：从当前已选择的分支merge；</li><li><strong>pull into current using rebase</strong>：从当前已选择的分支rebase；</li><li><strong>pull into current using merge</strong>：从当前已选择的分支merge；</li></ol><blockquote><p><font color="red"><strong>rebase和merge的区别？</strong></font></p><ol><li>下游分支更新上游分支内容的时候使用 <code>rebase</code></li><li>上游分支合并下游分支内容的时候使用 <code>merge</code></li><li>更新当前分支的内容时一定要使用 <code>--rebase</code> 参数</li></ol><p>例如：</p><p>1、现有上游分支 master，基于 master 分支拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支，此时切换到 dev 分支，使用 <code>git rebase master</code></p><p>2、等 dev 分支开发完成了之后，要合并到上游分支 master 上的时候，切换到 master 分支，使用 <code>git merge dev</code></p></blockquote><h4 id="二、cherry-pick-摘樱桃"><a href="#二、cherry-pick-摘樱桃" class="headerlink" title="二、cherry-pick 摘樱桃"></a>二、cherry-pick 摘樱桃</h4><p>场景：适合部分提交在不同分支之间的merge；</p><ol><li>先切换到主分支A；</li><li>在IDEA中打开GIT试图，选择Log框；</li></ol><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20211223153710.png" alt=""></p><ol start="3"><li>选中需要merge过来的分支提交记录，点击樱桃🍒图标，即可merge进当前分支，如果当前的log是一次提交多个文件时，可以选择只merge部分文件；</li><li>然后在当前的分支提交，并push进master即可，本次部分提交记录合并完成；</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP协议记录</title>
    <url>/post/e3c11488.html</url>
    <content><![CDATA[<blockquote><p>TCP协议记录 ~</p></blockquote><a id="more"></a><h3 id="一、TCP协议报文格式"><a href="#一、TCP协议报文格式" class="headerlink" title="一、TCP协议报文格式"></a>一、TCP协议报文格式</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210723105315.jpeg" alt="TCP协议报文格式"></p><p>其中比较重要的字段有：</p><p>（1）序号（sequence number）：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p><p>（2）确认号（acknowledgement number）：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p><p>（3）标志位（Flags）：共6个，即URG、ACK、PSH、RST、SYN、FIN等。具体含义如下：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>URG</td><td>紧急指针是否有效。为1，表示某一位需要被优先处理</td></tr><tr><td>ACK</td><td>确认号是否有效，一般置为1。</td></tr><tr><td>PSH</td><td>提示接收端应用程序立即从TCP缓冲区把数据读走。</td></tr><tr><td>RST</td><td>对方要求重新建立连接，复位。</td></tr><tr><td>SYN</td><td>请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td></tr><tr><td>FIN</td><td>希望断开连接。</td></tr></tbody></table><h3 id="二、TCP-IP协议分层"><a href="#二、TCP-IP协议分层" class="headerlink" title="二、TCP/IP协议分层"></a>二、TCP/IP协议分层</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210723105327.jpg" alt="TCP/IP协议分层"></p><h3 id="三、TCP三次握手"><a href="#三、TCP三次握手" class="headerlink" title="三、TCP三次握手"></a>三、TCP三次握手</h3><p>所谓三次握手（Three-Way Handshake）即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发，整个流程如下图所示：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210723105330.png" alt="TCP三次握手"></p><p>（1）第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p><p>（2）第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p><p>（3）第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p><p>简单来说，就是</p><p>1、建立连接时，客户端发送SYN包（SYN=i）到服务器，并进入到SYN-SEND状态，等待服务器确认</p><p>2、服务器收到SYN包，必须确认客户的SYN（ack=i+1）,同时自己也发送一个SYN包（SYN=k）,即SYN+ACK包，此时服务器进入SYN-RECV状态</p><p>3、客户端收到服务器的SYN+ACK包，向服务器发送确认报ACK（ack=k+1）,此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手，客户端与服务器开始传送数据。</p><p><strong>SYN攻击</strong>：</p><p>在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了，使用如下命令可以让之现行：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">netstat -nap | grep SYN_RECV</span></span><br></pre></td></tr></table></figure><h3 id="四、TCP四次挥手"><a href="#四、TCP四次挥手" class="headerlink" title="四、TCP四次挥手"></a>四、TCP四次挥手</h3><p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210723105333.png" alt="TCP四次挥手"></p><p>由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。</p><p>（1）第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><p>（2）第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><p>（3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><p>（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><h3 id="五、经典问题"><a href="#五、经典问题" class="headerlink" title="五、经典问题"></a>五、经典问题</h3><h4 id="【问题1】为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#【问题1】为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="【问题1】为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>【问题1】为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h4><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p><h4 id="【问题2】为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？"><a href="#【问题2】为什么TIME-WAIT状态需要经过2MSL-最大报文段生存时间-才能返回到CLOSE状态？" class="headerlink" title="【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？"></a>【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</h4><p>原因有二：<br>一、保证TCP协议的全双工连接能够可靠关闭<br>二、保证这次连接的重复数据段从网络中消失</p><p>先说第一点，如果Client直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致Server没有收到Client最后回复的ACK。那么Server就会在超时之后继续发送FIN，此时由于Client已经CLOSED了，就找不到与重发的FIN对应的连接，最后Server就会收到RST而不是ACK，Server就会以为是连接错误把问题报告给高层。这样的情况虽然不会造成数据丢失，但是却导致TCP协议不符合可靠连接的要求。所以，Client不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。</p><p>再说第二点，如果Client直接CLOSED，然后又再向Server发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Jmeter工具结果分析</title>
    <url>/post/b65a13e2.html</url>
    <content><![CDATA[<blockquote><p>Jmeter压测工具结果分析 ~</p></blockquote><a id="more"></a><h4 id="一、聚合报告"><a href="#一、聚合报告" class="headerlink" title="一、聚合报告"></a>一、聚合报告</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20211203143329.png" alt=""></p><blockquote><p><strong>#Samples</strong>：表示你这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100</p><p><strong>Average</strong>：平均响应时间——默认情况下是单个Request 的平均响应时间，当使用了 Transaction Controller 时，也可以以Transaction 为单位显示平均响应时间</p><p><strong>Median</strong>：中位数，也就是50％ 用户的响应时间</p><p><strong>90% Line</strong>：90％ 用户的响应时间</p><p><strong>Min</strong>：最小响应时间</p><p><strong>Max</strong>：最大响应时间</p><p><strong>Error%</strong>：本次测试中出现错误的请求的数量/请求的总数</p><p><strong>Throughput(QPS)</strong>：吞吐量——默认情况下表示每秒完成的请求数（Request per Second），当使用了 Transaction Controller 时，也可以表示类似 LoadRunner的 Transaction per Second 数，如果是1.0，即每秒1个请求</p><p><strong>KB/Sec</strong>：每秒从服务器端接收到的数据量，相当于LoadRunner中的Throughput/Sec</p></blockquote><h4 id="二、察看结果树"><a href="#二、察看结果树" class="headerlink" title="二、察看结果树"></a>二、察看结果树</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20211203144221.png" alt=""></p><blockquote><p><strong>Thread Name</strong>: 线程组名称</p><p><strong>Sample Start</strong>: 启动开始时间</p><p><strong>Load time</strong>: 加载时长</p><p><strong>Latency</strong>: 等待时长</p><p><strong>Size in bytes</strong>:发送的数据总大小</p><p><strong>Headers size in bytes</strong>:发送头大小</p><p><strong>Body size in bytes</strong>:发送数据的其余部分大小</p><p><strong>Sample Count</strong>:发送统计</p><p><strong>Error Count</strong>:交互错误统计</p><p><strong>Response code</strong>返回码</p></blockquote><h4 id="三、线程组"><a href="#三、线程组" class="headerlink" title="三、线程组"></a>三、线程组</h4><p><strong>线程数</strong>：虚拟用户数。一个虚拟用户占用一个进程或线程。设置多少虚拟用户数在这里也就是设置多少个线程数。</p><p><strong>准备时长Ramp-Up Period(in seconds)）</strong>： 设置的虚拟用户数需要多长时间全部启动。如果线程数为20 ，准备时长为10 ，那么需要10秒钟启动20个线程。也就是每秒钟启动2个线程。</p><p><strong>循环次数</strong>：每个线程发送请求的次数。如果线程数为20 ，循环次数为100 ，那么每个线程发送100次请求。总请求数为20*100=2000 。如果勾选了“永远”，那么所有线程会一直发送请求，一到选择停止运行脚本。</p><h4 id="四、吞吐量定时器"><a href="#四、吞吐量定时器" class="headerlink" title="四、吞吐量定时器"></a>四、吞吐量定时器</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20240119180723046.png" alt=""></p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/202401201929958.png" alt=""></p><p>作用：控制 QPS ，保证并发稳定在一定的数值内。</p><p>如上：吞吐量设置的是一分钟 600 次（一秒 10 次），线程数设置的 20 次，20 * 10 = 200 QPS；</p><p>这样设置参数后，保证QPS稳定在 200 QPS。</p><h4 id="五、接口压测模板"><a href="#五、接口压测模板" class="headerlink" title="五、接口压测模板"></a>五、接口压测模板</h4><p>接口压测模板文件 <a href="/download/接口压测模板.jmx">↓点击下载↓</a></p><h4 id="六、TPS-QPS"><a href="#六、TPS-QPS" class="headerlink" title="六、TPS\QPS"></a>六、TPS\QPS</h4><p><a href="https://www.cnblogs.com/data2value/p/6220859.html" target="_blank" rel="noopener">《吞吐量（TPS）、QPS、并发数、响应时间（RT）概念》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>QPS</category>
      </categories>
      <tags>
        <tag>Jmeter</tag>
        <tag>QPS</tag>
      </tags>
  </entry>
  <entry>
    <title>HttpClient跳过Https证书认证</title>
    <url>/post/f0330bfd.html</url>
    <content><![CDATA[<blockquote><p>HttpClient跳过Https证书认证 ~</p></blockquote><a id="more"></a><h3 id="一、错误原因"><a href="#一、错误原因" class="headerlink" title="一、错误原因"></a>一、错误原因</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">	at sun.security.ssl.Alerts.getSSLException(Alerts.java:<span class="number">192</span>)</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.fatal(SSLSocketImpl.java:<span class="number">1949</span>)</span><br><span class="line">	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:<span class="number">302</span>)</span><br><span class="line">	at sun.security.ssl.Handshaker.fatalSE(Handshaker.java:<span class="number">296</span>)</span><br><span class="line">	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:<span class="number">1509</span>)</span><br><span class="line">	at sun.security.ssl.ClientHandshaker.processMessage(ClientHandshaker.java:<span class="number">216</span>)</span><br><span class="line">	at sun.security.ssl.Handshaker.processLoop(Handshaker.java:<span class="number">979</span>)</span><br><span class="line">	at sun.security.ssl.Handshaker.process_record(Handshaker.java:<span class="number">914</span>)</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.readRecord(SSLSocketImpl.java:<span class="number">1062</span>)</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.performInitialHandshake(SSLSocketImpl.java:<span class="number">1375</span>)</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:<span class="number">1403</span>)</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:<span class="number">1387</span>)</span><br><span class="line">	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.createLayeredSocket(SSLConnectionSocketFactory.java:<span class="number">396</span>)</span><br><span class="line">	at org.apache.http.conn.ssl.SSLConnectionSocketFactory.connectSocket(SSLConnectionSocketFactory.java:<span class="number">355</span>)</span><br><span class="line">	at org.apache.http.impl.conn.DefaultHttpClientConnectionOperator.connect(DefaultHttpClientConnectionOperator.java:<span class="number">142</span>)</span><br><span class="line">	at org.apache.http.impl.conn.PoolingHttpClientConnectionManager.connect(PoolingHttpClientConnectionManager.java:<span class="number">373</span>)</span><br><span class="line">	at org.apache.http.impl.execchain.MainClientExec.establishRoute(MainClientExec.java:<span class="number">394</span>)</span><br><span class="line">	at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:<span class="number">237</span>)</span><br><span class="line">	at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:<span class="number">185</span>)</span><br><span class="line">	at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:<span class="number">89</span>)</span><br><span class="line">	at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:<span class="number">110</span>)</span><br><span class="line">	at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:<span class="number">185</span>)</span><br><span class="line">	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:<span class="number">83</span>)</span><br><span class="line">	at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:<span class="number">108</span>)</span><br><span class="line">	at com.cyj.demo.Demo02.main(Demo02.java:<span class="number">48</span>)</span><br><span class="line">Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:<span class="number">387</span>)</span><br><span class="line">	at sun.security.validator.PKIXValidator.engineValidate(PKIXValidator.java:<span class="number">292</span>)</span><br><span class="line">	at sun.security.validator.Validator.validate(Validator.java:<span class="number">260</span>)</span><br><span class="line">	at sun.security.ssl.X509TrustManagerImpl.validate(X509TrustManagerImpl.java:<span class="number">324</span>)</span><br><span class="line">	at sun.security.ssl.X509TrustManagerImpl.checkTrusted(X509TrustManagerImpl.java:<span class="number">229</span>)</span><br><span class="line">	at sun.security.ssl.X509TrustManagerImpl.checkServerTrusted(X509TrustManagerImpl.java:<span class="number">124</span>)</span><br><span class="line">	at sun.security.ssl.ClientHandshaker.serverCertificate(ClientHandshaker.java:<span class="number">1491</span>)</span><br><span class="line">	... <span class="number">20</span> more</span><br><span class="line">Caused by: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</span><br><span class="line">	at sun.security.provider.certpath.SunCertPathBuilder.build(SunCertPathBuilder.java:<span class="number">141</span>)</span><br><span class="line">	at sun.security.provider.certpath.SunCertPathBuilder.engineBuild(SunCertPathBuilder.java:<span class="number">126</span>)</span><br><span class="line">	at java.security.cert.CertPathBuilder.build(CertPathBuilder.java:<span class="number">280</span>)</span><br><span class="line">	at sun.security.validator.PKIXValidator.doBuild(PKIXValidator.java:<span class="number">382</span>)</span><br><span class="line">	... <span class="number">26</span> more</span><br></pre></td></tr></table></figure><h3 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h3><p>https多了一个ssl证书验证，可以说https是身披SSL外壳的http。因为http存在如下缺陷：</p><p>1）通信使用明文，内容可能被窃听(重要密码泄露)；</p><p>2）不验证通信方身份，有可能遭遇伪装(跨站点请求伪造)；</p><p>3）无法证明报文的完整性，有可能已遭篡改(运营商劫持)；</p><p>而https是利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><h3 id="三、代码解决"><a href="#三、代码解决" class="headerlink" title="三、代码解决"></a>三、代码解决</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建HttpClient对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxTotal    最大连接数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxPerRoute 路由基础的连接数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxRoute    目标主机的最大连接数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hostname    目标主机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port        端口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> CloseableHttpClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CloseableHttpClient <span class="title">createHttpClient</span><span class="params">(<span class="keyword">int</span> maxTotal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="keyword">int</span> maxPerRoute, <span class="keyword">int</span> maxRoute, String hostname, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 请求重试处理</span></span><br><span class="line">        HttpRequestRetryHandler httpRequestRetryHandler = (exception, executionCount, context) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (executionCount &gt;= <span class="number">5</span>) &#123;<span class="comment">// 如果已经重试了5次，就放弃</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> NoHttpResponseException) &#123;<span class="comment">// 如果服务器丢掉了连接，那么就重试</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> SSLHandshakeException) &#123;<span class="comment">// 不要重试SSL握手异常</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> InterruptedIOException) &#123;<span class="comment">// 读取超时，那么就重试</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> UnknownHostException) &#123;<span class="comment">// 目标服务器不可达</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ConnectTimeoutException) &#123;<span class="comment">// 连接超时，那么就重试</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> SSLException) &#123;<span class="comment">// SSL握手异常</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HttpClientContext clientContext = HttpClientContext</span><br><span class="line">                    .adapt(context);</span><br><span class="line">            HttpRequest request = clientContext.getRequest();</span><br><span class="line">            <span class="comment">// 如果请求是幂等的，就再次尝试</span></span><br><span class="line">            <span class="keyword">if</span> (!(request <span class="keyword">instanceof</span> HttpEntityEnclosingRequest)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        SSLContext sslContext = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、信任所有证书</span></span><br><span class="line">            sslContext = <span class="keyword">new</span> SSLContextBuilder().loadTrustMaterial(<span class="keyword">null</span>, (TrustStrategy) (chain, authType) -&gt; <span class="keyword">true</span>).build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> sslContext != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 2、</span></span><br><span class="line">        Registry&lt;ConnectionSocketFactory&gt; registry = RegistryBuilder</span><br><span class="line">                .&lt;ConnectionSocketFactory&gt;create().register(<span class="string">"http"</span>, PlainConnectionSocketFactory.INSTANCE)</span><br><span class="line">                .register(<span class="string">"https"</span>, <span class="keyword">new</span> SSLConnectionSocketFactory(sslContext)).build();</span><br><span class="line">        cm = <span class="keyword">new</span> PoolingHttpClientConnectionManager(</span><br><span class="line">                registry);</span><br><span class="line">        <span class="comment">// 将最大连接数增加</span></span><br><span class="line">        cm.setMaxTotal(maxTotal);</span><br><span class="line">        <span class="comment">// 将每个路由基础的连接增加</span></span><br><span class="line">        cm.setDefaultMaxPerRoute(maxPerRoute);</span><br><span class="line">        HttpHost httpHost = <span class="keyword">new</span> HttpHost(hostname, port);</span><br><span class="line">        <span class="comment">// 将目标主机的最大连接数增加</span></span><br><span class="line">        cm.setMaxPerRoute(<span class="keyword">new</span> HttpRoute(httpHost), maxRoute);</span><br><span class="line">        SSLConnectionSocketFactory sslFactory = <span class="keyword">new</span> SSLConnectionSocketFactory(sslContext, NoopHostnameVerifier.INSTANCE);</span><br><span class="line">        <span class="keyword">return</span> HttpClients.custom()</span><br><span class="line">                .setSSLContext(sslContext)</span><br><span class="line">                .setSSLHostnameVerifier(<span class="keyword">new</span> NoopHostnameVerifier())</span><br><span class="line">                .setSSLSocketFactory(sslFactory)</span><br><span class="line">                .setConnectionManager(cm)</span><br><span class="line">                .setRetryHandler(httpRequestRetryHandler).build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>聊聊Spring事务失效的12种场景</title>
    <url>/post/8570e6fb.html</url>
    <content><![CDATA[<blockquote><p>来吧，聊聊事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看 ~</p></blockquote><a id="more"></a><h3 id="一、场景全图"><a href="#一、场景全图" class="headerlink" title="一、场景全图"></a>一、场景全图</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20210922163221.jpeg" alt=""></p><h3 id="二、举例说明"><a href="#二、举例说明" class="headerlink" title="二、举例说明"></a>二、举例说明</h3><p>​ 上面列举了有12种场景，这里咱们只拿其中的几个不怎么好理解的场景，举例说明一下。</p><h4 id="1、方法用final修饰"><a href="#1、方法用final修饰" class="headerlink" title="1、方法用final修饰"></a>1、方法用final修饰</h4><p>将事务方法定义成final的，事务会失效的。 为什么呢？</p><p>如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。</p><p>但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。</p><p>注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。</p><h4 id="2、方法内部调用"><a href="#2、方法内部调用" class="headerlink" title="2、方法内部调用"></a>2、方法内部调用</h4><p>有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(UserModel userModel)</span> </span>&#123; </span><br><span class="line">        userMapper.insertUser(userModel); </span><br><span class="line">        <span class="comment">// 直接调取</span></span><br><span class="line">        updateStatus(userModel); </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStatus</span><span class="params">(UserModel userModel)</span> </span>&#123; </span><br><span class="line">        doSameThing(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到在事务方法add中，直接调用事务方法updateStatus。updateStatus方法拥有事务的能力是因为 <strong>spring aop生成代理了对象</strong>，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。</p><p>由此可见，在同一个类中的方法直接内部调用，会导致事务失效。</p><p>如果真的需要怎么办？</p><h5 id="1-新加一个Service方法"><a href="#1-新加一个Service方法" class="headerlink" title="1.新加一个Service方法"></a>1.<strong>新加一个Service方法</strong></h5><h5 id="2-在该Service类中注入自己"><a href="#2-在该Service类中注入自己" class="headerlink" title="2.在该Service类中注入自己"></a>2.<strong>在该Service类中注入自己</strong></h5><h5 id="3-通过AopContent类"><a href="#3-通过AopContent类" class="headerlink" title="3.通过AopContent类"></a>3.<strong>通过AopContent类</strong></h5><h4 id="3、多线程调用"><a href="#3、多线程调用" class="headerlink" title="3、多线程调用"></a>3、多线程调用</h4><p>在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗?</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j </span><br><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RoleService roleService; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(UserModel userModel)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">        userMapper.insertUser(userModel); </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123; </span><br><span class="line">            roleService.doOtherThing(); </span><br><span class="line">        &#125;).start(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleService</span> </span>&#123; </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Transactional</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherThing</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"保存role表数据"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。</p><p>这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。</p><p>如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。</p><p>我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。</p><h4 id="4、表不支持事务"><a href="#4、表不支持事务" class="headerlink" title="4、表不支持事务"></a>4、表不支持事务</h4><p>周所周知，在mysql5之前，默认的数据库引擎是myisam。</p><p>它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。</p><p>myisam好用，但有个很致命的问题是：不支持事务。</p><p>如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。</p><p>此外，myisam还不支持行锁和外键。</p><p>有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。</p><h3 id="三、-大事务问题"><a href="#三、-大事务问题" class="headerlink" title="三、 大事务问题"></a>三、 大事务问题</h3><p>在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。通常情况下，我们会在方法上@Transactional注解，填加事务功能。但@Transactional注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。但是这种写法，会导致所有的query方法也被包含在同一个事务当中。如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。</p><p>如何解决？</p><p>上面聊的这些内容都是基于@Transactional注解的，主要说的是它的事务问题，我们把这种事务叫做：声明式事务。</p><p>其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，我们把这种事务叫做：编程式事务。例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate; </span><br><span class="line"> </span><br><span class="line">... </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(<span class="keyword">final</span> User user)</span> </span>&#123; </span><br><span class="line">      queryData1(); </span><br><span class="line">      queryData2(); </span><br><span class="line">      transactionTemplate.execute((status) =&gt; &#123; </span><br><span class="line">         addData1(); </span><br><span class="line">         updateData2(); </span><br><span class="line">         <span class="keyword">return</span> Boolean.TRUE; </span><br><span class="line">      &#125;) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。</p><p>相较于@Transactional注解声明式事务，我更建议大家使用，基于TransactionTemplate的编程式事务。主要原因如下：</p><ul><li>避免由于spring aop问题，导致事务失效的问题。</li><li>能够更小粒度的控制事务的范围，更直观。</li></ul><p>建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java位运算</title>
    <url>/post/44f703eb.html</url>
    <content><![CDATA[<blockquote><p>位运算 ~</p></blockquote><a id="more"></a><h3 id="一、位运算概览"><a href="#一、位运算概览" class="headerlink" title="一、位运算概览"></a>一、位运算概览</h3><table><thead><tr><th align="center">符号</th><th align="center">描述</th><th align="center">运算规则</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">与</td><td align="center">两个位都为1时，结果才为1</td></tr><tr><td align="center">|</td><td align="center">或</td><td align="center">两个位都为0时，结果才为0</td></tr><tr><td align="center">^</td><td align="center">异或</td><td align="center">两个位相同为0，相异为1</td></tr><tr><td align="center">~</td><td align="center">取反</td><td align="center">0变1，1变0</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移</td><td align="center">各二进位全部左移若干位，高位丢弃，低位补0</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移</td><td align="center">各二进位全部右移若干位，<br>对无符号数，高位补0，有符号位，各编译器处理方法不一样，<br>有的补符号位（算术右移），有的补0（逻辑右移）</td></tr></tbody></table><h3 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &amp; 0x01 获取最低位</span></span><br><span class="line">    System.out.println(<span class="number">0b1011</span> &amp; <span class="number">0x01</span>);</span><br><span class="line">    <span class="comment">// &amp; 0x0f 获取低字节</span></span><br><span class="line">    System.out.println(<span class="number">0x03</span> &amp; <span class="number">0x0f</span>);</span><br><span class="line">    <span class="comment">//  &gt;&gt; 4  获取高字节</span></span><br><span class="line">    System.out.println(<span class="number">0xBa</span> &gt;&gt; <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当一些时候, 我们不需要判断传进来的数是正数还是负数, 但是希望得到的结果一定是一个正数的时候,</span></span><br><span class="line">    <span class="comment">// 我们就可以通过与运算相应位的0XFF, 就能保证得到的一定是一个正数.</span></span><br><span class="line">    <span class="comment">// 10111010</span></span><br><span class="line">    <span class="comment">// 11111111</span></span><br><span class="line">    <span class="comment">// 10111010</span></span><br><span class="line">    System.out.println(<span class="number">0b10111010</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>浅析RPC</title>
    <url>/post/c220c6b3.html</url>
    <content><![CDATA[<blockquote><p>浅析RPC的实现原理 ~</p></blockquote><a id="more"></a><h3 id="一、什么是RPC"><a href="#一、什么是RPC" class="headerlink" title="一、什么是RPC"></a>一、什么是RPC</h3><p>RPC 的全称是 <strong>Remote Procedure Call</strong> 是一种进程间通信方式。它允许程序调用另一个地址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用的细节。即无论是调用本地接口/服务的还是远程的接口/服务，本质上编写的调用代码基本相同。</p><p>比如两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数或者方法，由于不在一个内存空间，不能直接调用，这时候需要通过就可以应用RPC框架的实现来解决。</p><ul><li><p>RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）</p></li><li><p>RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）</p></li><li><p>RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</p></li></ul><h3 id="二、一次基本的-RPC-调用会涉及到什么？"><a href="#二、一次基本的-RPC-调用会涉及到什么？" class="headerlink" title="二、一次基本的 RPC 调用会涉及到什么？"></a>二、一次基本的 RPC 调用会涉及到什么？</h3><p>现在业界内比较流行的一些 RPC 框架，例如 Dubbo 提供的是<code>基于接口的远程方法调用</code>，即客户端只需要知道接口的定义即可调用远程服务。在 Java 中接口并不能直接调用实例方法，必须通过其实现类对象来完成此操作，这意味着客户端必须为这些接口生成<code>代理对象</code>，对此 Java 提供了 <code>Proxy</code>、<code>InvocationHandler</code> 生成动态代理的支持；生成了代理对象，那么每个具体的发方法是怎么调用的呢？jdk 动态代理生成的代理对象调用指定方法时实际会执行 <code>InvocationHandler</code> 中定义的 <code>#invoke</code> 方法，在该方法中完成远程方法调用并获取结果。</p><p>抛开客户端，回过头来看 RPC 是两台计算机间的调用，实质上是两台主机间的<code>网络通信</code>，涉及到网络通信又必然会有<code>序列化、反序列化</code>，<code>编解码</code>等一些必须要考虑的问题；同时实际上现在大多系统都是集群部署的，多台主机/容器对外提供相同的服务，如果集群的节点数量很大的话，那么管理服务地址也将是一件十分繁琐的事情，常见的做法是各个服务节点将自己的地址和提供的服务列表注册到一个 <code>注册中心</code>，由 <code>注册中心</code> 来统一管理服务列表；这样的做法解决了一些问题同时为客户端增加了一项新的工作——那就是<code>服务发现</code>，通俗来说就是从注册中心中找到远程方法对应的服务列表并通过某种策略从中选取一个服务地址来完成网络通信。</p><p>聊了客户端和 <code>注册中心</code>，另外一个重要的角色自然是服务端，服务端最重要的任务便是提供服务接口的真正实现并在某个端口上监听网络请求，监听到请求后从网络请求中获取到对应的参数（比如服务接口、方法、请求参数等），再根据这些参数通过<code>反射</code>的方式调用接口的真正实现获取结果并将其写入对应的响应流中。</p><p>综上所述，一次基本的 RPC 调用流程大致如下：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220118180310.png" alt=""></p><h3 id="三、使用到的技术"><a href="#三、使用到的技术" class="headerlink" title="三、使用到的技术"></a>三、使用到的技术</h3><h4 id="1-动态代理"><a href="#1-动态代理" class="headerlink" title="1.动态代理"></a>1.动态代理</h4><p>生成 client stub和server stub需要用到 Java 动态代理技术 ，我们可以使用JDK原生的动态代理机制，可以使用一些开源字节码工具框架 如：CgLib、Javassist等。</p><h4 id="2-序列化"><a href="#2-序列化" class="headerlink" title="2.序列化"></a>2.序列化</h4><p>为了能在网络上传输和接收 Java对象，我们需要对它进行 序列化和反序列化操作。</p><ul><li><p>序列化：将Java对象转换成 byte[] 的过程，也就是编码的过程；</p></li><li><p>反序列化：将 byte[] 转换成Java对象的过程；</p></li></ul><p>可以使用Java原生的序列化机制，但是效率非常低，推荐使用一些开源的、成熟的序列化技术，例如：<code>protobuf</code>、<code>Thrift</code>、<code>hessian</code>、<code>Kryo</code>、<code>Msgpack</code></p><p>关于序列化工具性能比较可以参考：<code>jvm-serializers</code></p><h4 id="3-NIO"><a href="#3-NIO" class="headerlink" title="3.NIO"></a>3.NIO</h4><p>很多RPC框架都直接基于<strong><code>Netty</code></strong>这一IO通信框架，比如阿里巴巴的<code>HSF</code>、<code>dubbo</code>，<code>Hadoop Avro</code>，推荐使用<code>Netty</code> 作为底层通信框架。</p><h4 id="4-服务注册中心"><a href="#4-服务注册中心" class="headerlink" title="4.服务注册中心"></a>4.服务注册中心</h4><p>可选技术：Redis、Zookeeper、Consul、Etcd、Nacos、Eureka</p><h3 id="四、Netty实现-Dubbo-RPC"><a href="#四、Netty实现-Dubbo-RPC" class="headerlink" title="四、Netty实现 Dubbo RPC"></a>四、Netty实现 <code>Dubbo RPC</code></h3><p><a href="https://dongzl.github.io/netty-handbook/#/_content/chapter11" target="_blank" rel="noopener">《 Netty实现 Dubbo RPC 》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java三种工厂模式</title>
    <url>/post/2c61f458.html</url>
    <content><![CDATA[<blockquote><p>“设计模式” 这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。直到 1990 年，软件工程界才开始研讨设计模式的话题 ~</p></blockquote><a id="more"></a><h3 id="软件设计模式的概念与意义"><a href="#软件设计模式的概念与意义" class="headerlink" title="软件设计模式的概念与意义"></a>软件设计模式的概念与意义</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p><strong>软件设计模式</strong>（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p><h4 id="2、意义"><a href="#2、意义" class="headerlink" title="2、意义"></a>2、意义</h4><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><p>当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p><hr><p>今天就开始总结一下，开发中最常见的设计模式：<font color="red"><strong>工厂模式</strong></font></p><p>按实际业务场景划分，工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。</p><h3 id="一、简单工厂模式"><a href="#一、简单工厂模式" class="headerlink" title="一、简单工厂模式"></a>一、简单工厂模式</h3><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</p><p>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/23 20:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 创建一个面条的基类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">INoodles</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 描述每种面条啥样的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">desc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/23 21:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 干扣面具体实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GankouNoodles</span> <span class="keyword">extends</span> <span class="title">INoodles</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">desc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"干扣面"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/23 20:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 兰州拉面具体实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LzNoodles</span> <span class="keyword">extends</span> <span class="title">INoodles</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">desc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"兰州拉面"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/23 21:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 简单工厂类，负责：根据传入的入参创建那个具体的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleNoodlesFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_LZ = <span class="number">1</span>;<span class="comment">//兰州拉面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TYPE_GK = <span class="number">3</span>;<span class="comment">//干扣面</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> INoodles <span class="title">createNoodles</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> TYPE_LZ:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> LzNoodles();</span><br><span class="line">            <span class="keyword">case</span> TYPE_GK:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GankouNoodles();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> GankouNoodles();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2018/8/23 21:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:简单工厂模式，测试类，根据工厂的枚举来选择创建那个类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK);</span><br><span class="line">        noodles.desc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ol><li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。</li><li>客户端无需知道所创建具体产品的类名，只需知道参数即可。</li><li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li></ol><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ol><li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，违背高聚合原则。</li><li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度</li><li>系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li><li>简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。</li><li>简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。</li></ol><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p><h3 id="二、工厂方法模式"><a href="#二、工厂方法模式" class="headerlink" title="二、工厂方法模式"></a>二、工厂方法模式</h3><p>“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><p>工厂方法模式的主要角色如下：</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建人类抽象工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里采用了泛型，对createHuman的输入参数产生两层限制</span></span><br><span class="line">    <span class="comment">// 1.必须是Class类型</span></span><br><span class="line">    <span class="comment">// 2.必须是Human的实现类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; c)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//创建人类具体工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanFactory</span> <span class="keyword">extends</span> <span class="title">AbstractHumanFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Human&gt; <span class="function">T <span class="title">createHuman</span><span class="params">(Class&lt;T&gt; tClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个生产的人种</span></span><br><span class="line">        Human human = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//产生一个人种</span></span><br><span class="line">            human = (T) Class.forName(tClass.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"人种生成错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) human;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建抽象产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="comment">//没个人种的皮肤都有相应的颜色</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//人类会说话</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//黑色人种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlackHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色人种的皮肤颜色是黑色的！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑人会说话，一般人听不懂！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黄色人种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种的皮肤颜色是黄色的！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黄色人种会说话，一般说的 都是双字节！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色人种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhiteHuman</span> <span class="keyword">implements</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种的皮肤颜色是白色的！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色人种会说话，一般都是单字节！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂方法模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/8 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NvWaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//声明阴阳八卦炉</span></span><br><span class="line">        AbstractHumanFactory humanFactory = <span class="keyword">new</span> HumanFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//女娲第一次造人，火候不足，于是白人产生了</span></span><br><span class="line">        System.out.println(<span class="string">"造出来的第一批人是白色人种"</span>);</span><br><span class="line">        Human whiteHuman = humanFactory.createHuman(WhiteHuman<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        whiteHuman.getColor();</span><br><span class="line">        whiteHuman.talk();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//女娲第二次造人， 火候过足， 于是黑人产生了</span></span><br><span class="line">        System.out.println(<span class="string">"造出的第二批人是黑色人种"</span>);</span><br><span class="line">        Human blackHuman = humanFactory.createHuman(BlackHuman<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        blackHuman.getColor();</span><br><span class="line">        blackHuman.talk();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三次造人， 火候刚刚好， 于是黄色人种产生了</span></span><br><span class="line">        System.out.println(<span class="string">"造出的第三批人是黄色人种"</span>);</span><br><span class="line">        Human yellowHuman = humanFactory.createHuman(YellowHuman<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        yellowHuman.getColor();</span><br><span class="line">        yellowHuman.talk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点和缺点-1"><a href="#优点和缺点-1" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li><li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li><li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>类的个数容易过多，增加复杂度</li><li>增加了系统的抽象性和理解难度</li><li>抽象产品只能生产一种产品，此弊端可使用<strong>抽象工厂模式</strong>解决。</li></ul><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。</li><li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li><li>客户不关心创建产品的细节，只关心产品的品牌</li></ul><h3 id="三、抽象工厂模式"><a href="#三、抽象工厂模式" class="headerlink" title="三、抽象工厂模式"></a>三、抽象工厂模式</h3><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，<u>工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品</u>。</p><p>抽象工厂模式，也称为工厂的工厂，有一个工厂创建其他工厂。当使用抽象工厂模式时，我们首先使用超级工厂创建工厂，然后使用创建的工厂创建对象。</p><h4 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h4><p>抽象工厂模式的主要角色如下。</p><ol><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ol><p>我们将要创建形状和打印机。对于形状，我们会有圆形，矩形和正方形。对于打印机，我们将有纸张打印机，网络打印机和屏幕打印机。</p><h5 id="1、创建颜色相关的类"><a href="#1、创建颜色相关的类" class="headerlink" title="1、创建颜色相关的类"></a>1、创建颜色相关的类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 颜色抽象产品：创建颜色的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 颜色具体产品：实现颜色的具体实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Red</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"红色颜色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Green</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"绿色颜色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blue</span> <span class="keyword">implements</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"蓝色颜色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、创建形状相关的类"><a href="#2、创建形状相关的类" class="headerlink" title="2、创建形状相关的类"></a>2、创建形状相关的类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形状抽象产品：创建形状的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 形状具体产品</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 长方形实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长方形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正方形实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正方形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 圆实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、创建抽象工厂类"><a href="#3、创建抽象工厂类" class="headerlink" title="3、创建抽象工厂类"></a>3、创建抽象工厂类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个抽象类来获取打印机和形状对象的工厂为 Color 和 Shape 对象创建抽象类来获取工厂。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title">getColor</span><span class="params">(String color)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title">getShape</span><span class="params">(String shape)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、创建颜色的具体工厂类"><a href="#4、创建颜色的具体工厂类" class="headerlink" title="4、创建颜色的具体工厂类"></a>4、创建颜色的具体工厂类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建扩展了 颜色的 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (color == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"RED"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Red();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"GREEN"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Green();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color.equalsIgnoreCase(<span class="string">"BLUE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Blue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、创建形状的具体工厂类"><a href="#5、创建形状的具体工厂类" class="headerlink" title="5、创建形状的具体工厂类"></a>5、创建形状的具体工厂类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建扩展了 形状 的AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6、创建超级工厂类"><a href="#6、创建超级工厂类" class="headerlink" title="6、创建超级工厂类"></a>6、创建超级工厂类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。通过工厂来创建具体的工厂。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title">getFactory</span><span class="params">(String choice)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ShapeFactory();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choice.equalsIgnoreCase(<span class="string">"COLOR"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ColorFactory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7、测试运行"><a href="#7、测试运行" class="headerlink" title="7、测试运行"></a>7、测试运行</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象工厂模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/8 16:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取形状工厂</span></span><br><span class="line">        AbstractFactory shapeFactory = FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">        Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">        Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">        Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色工厂</span></span><br><span class="line">        AbstractFactory colorFactory = FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">        Color color1 = colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line">        <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">        color1.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">        Color color2 = colorFactory.getColor(<span class="string">"Green"</span>);</span><br><span class="line">        <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">        color2.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">        Color color3 = colorFactory.getColor(<span class="string">"BLUE"</span>);</span><br><span class="line">        <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">        color3.fill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点和缺点-2"><a href="#优点和缺点-2" class="headerlink" title="优点和缺点"></a>优点和缺点</h4><h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul><li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li><li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。</li><li>抽象工厂增强了程序的可扩展性，当增加一个新的产品族时，不需要修改原代码，满足开闭原则。</li></ul><h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。增加了系统的抽象性和理解难度。</li></ul><h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li><li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ul><h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a href="http://c.biancheng.net/design_pattern/" target="_blank" rel="noopener">《Java设计模式：23种设计模式全面解析（超级详细）》</a><br><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html" target="_blank" rel="noopener">《Java设计模式》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>使用@Scheduled定时执行任务的坑</title>
    <url>/post/9c19b9ad.html</url>
    <content><![CDATA[<blockquote><p>使用@Scheduled定时执行任务的坑,多任务阻塞执行 ~</p></blockquote><a id="more"></a><p><strong>SpringBoot使用@Scheduled定时执行任务的时候是在一个单线程中，如果有多个任务，其中一个任务执行时间过长，则有可能会导致其他后续任务被阻塞直到该任务执行完成。也就是会造成一些任务无法定时执行，造成生产事件的发生。</strong></p><h3 id="实践模拟"><a href="#实践模拟" class="headerlink" title="实践模拟"></a>实践模拟</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/1 * * * * ? "</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    log.info(<span class="string">"one success, time:"</span> + <span class="keyword">new</span> Date().toString());</span><br><span class="line">    <span class="comment">//模拟长时间执行，比如IO操作，http请求</span></span><br><span class="line">    Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0/1 * * * * ? "</span>）</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"two success, time:"</span> + <span class="keyword">new</span> Date().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，若是一个项目中有多个定时任务，且其中一个定时任务执行时间比较久或者出现故障，则会导致其它job没能被线程所执行，导致没能达到准点执行的效果。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="1-将-Scheduled注释的方法内部改成异步执行"><a href="#1-将-Scheduled注释的方法内部改成异步执行" class="headerlink" title="1.将@Scheduled注释的方法内部改成异步执行"></a>1.将@Scheduled注释的方法内部改成异步执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当然了，构建一个合理的线程池也是一个关键，否则提交的任务也会在自己构建的线程池中阻塞</span></span><br><span class="line">    ExecutorService service = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/1 * * * * ? "</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">one</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.execute(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"one success, time:"</span> + <span class="keyword">new</span> Date().toString());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 改成异步执行后，就算你再耗时也不会印象到后续任务的定时调度了</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0/1 * * * * ? "</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">two</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.execute(()-&gt;&#123;</span><br><span class="line">            log.info(<span class="string">"two success, time:"</span> + <span class="keyword">new</span> Date().toString());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-把Scheduled配置成成多线程执行"><a href="#2-把Scheduled配置成成多线程执行" class="headerlink" title="2.把Scheduled配置成成多线程执行"></a>2.把Scheduled配置成成多线程执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleConfig</span> <span class="keyword">implements</span> <span class="title">SchedulingConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">(ScheduledTaskRegistrar taskRegistrar)</span> </span>&#123;</span><br><span class="line">        Method[] methods = BatchProperties.Job<span class="class">.<span class="keyword">class</span>.<span class="title">getMethods</span>()</span>;</span><br><span class="line">       <span class="comment">// 获取计算机的计算线程数</span></span><br><span class="line">        <span class="keyword">int</span> defaultPoolSize = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (methods.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">                Scheduled annotation = method.getAnnotation(Scheduled<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (annotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    corePoolSize++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (defaultPoolSize &gt; corePoolSize)</span><br><span class="line">                corePoolSize = defaultPoolSize;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//当然了，这里设置的线程池是corePoolSize也是很关键了，自己根据业务需求设定，假设你有4个任务需要每隔1秒执行，而其中三个都是比较耗时的操作可能需要10多秒，而你上面的语句是这样写的：</span></span><br><span class="line">        taskRegistrar.setScheduler(Executors.newScheduledThreadPool(corePoolSize));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Netty中ByteBuf的copy、duplicate、slice方法对比</title>
    <url>/post/94c01782.html</url>
    <content><![CDATA[<blockquote><p>Netty中ByteBuf的copy、duplicate、slice方法对比 ~</p></blockquote><a id="more"></a><h3 id="一、源码内容"><a href="#一、源码内容" class="headerlink" title="一、源码内容"></a>一、源码内容</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回ByteBuf的可读字节的拷贝。</span></span><br><span class="line"><span class="comment"> * 修改返回的ByteBuf内容与当前ByteBuf完全不会相互影响。</span></span><br><span class="line"><span class="comment"> * 此方法不会修改当前ByteBuf的readerIndex或writerIndex</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">copy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回ByteBuf可读字节的一部分。 </span></span><br><span class="line"><span class="comment"> * 修改返回的ByteBuf或当前ByteBuf会影响彼此的内容，</span></span><br><span class="line"><span class="comment"> * 同时它们维护单独的索引和标记,此方法不会修改当前ByteBuf的readerIndex或writerIndex</span></span><br><span class="line"><span class="comment"> * 另请注意，此方法不会调用&#123;<span class="doctag">@link</span> #retain（）&#125;，因此不会增加引用计数。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">duplicate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回共享当前ByteBuf信息的新ByteBuf,他们使用独立的readIndex writeIndex markIndex</span></span><br><span class="line"><span class="comment"> * 修改返回的ByteBuf或当前ByteBuf会影响彼此的内容，同时它们维护单独的索引和标记,</span></span><br><span class="line"><span class="comment"> * 此方法不会修改当前ByteBuf的readerIndex或writerIndex，</span></span><br><span class="line"><span class="comment"> * 另请注意，此方法不会调用&#123;<span class="doctag">@link</span> #retain（）&#125;，因此不会增加引用计数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuf <span class="title">slice</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="二、示例自测"><a href="#二、示例自测" class="headerlink" title="二、示例自测"></a>二、示例自测</h3><h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBuf;</span><br><span class="line"><span class="keyword">import</span> io.netty.buffer.ByteBufAllocator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteBufTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf byteBuf = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">        byteBuf.writeInt(<span class="number">126</span>);</span><br><span class="line">        byteBuf.writeInt(<span class="number">127</span>);</span><br><span class="line">        byteBuf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"byteBuf readInt="</span> + byteBuf.readInt());</span><br><span class="line">        System.out.println(<span class="string">"byteBuf readerIndex="</span> + byteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + byteBuf.writerIndex() + <span class="string">"|capacity="</span> + byteBuf.capacity());</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回ByteBuf的可读字节的拷贝。修改返回的ByteBuf内容与当前ByteBuf完全不会相互影响。</span></span><br><span class="line">        <span class="comment">//此方法不会修改当前ByteBuf的readerIndex或writerIndex</span></span><br><span class="line">        System.out.println(<span class="string">"====================byteBuf.copy()=================="</span>);</span><br><span class="line">        ByteBuf cByteBuf = byteBuf.copy();</span><br><span class="line">        System.out.println(<span class="string">"cByteBuf readerIndex="</span> + cByteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + cByteBuf.writerIndex() + <span class="string">"|capacity="</span> + cByteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"byteBuf readerIndex="</span> + byteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + byteBuf.writerIndex() + <span class="string">"|capacity="</span> + byteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"向cByteBuf中写入数据"</span> + cByteBuf.setInt(<span class="number">0</span>, <span class="number">128</span>));</span><br><span class="line">        System.out.println(<span class="string">"cByteBuf="</span> + cByteBuf.getInt(<span class="number">0</span>) + <span class="string">"|cByteBuf="</span> + cByteBuf.getByte(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf.getInt(<span class="number">0</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getInt(<span class="number">4</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getByte(<span class="number">8</span>));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回ByteBuf可读字节的一部分。 修改返回的ByteBuf或当前ByteBuf会影响彼此的内容，</span></span><br><span class="line">        <span class="comment">// 同时它们维护单独的索引和标记,此方法不会修改当前ByteBuf的readerIndex或writerIndex</span></span><br><span class="line">        <span class="comment">//另请注意，此方法不会调用&#123;@link #retain（）&#125;，因此不会增加引用计数。</span></span><br><span class="line">        System.out.println(<span class="string">"====================byteBuf.slice()=================="</span>);</span><br><span class="line">        ByteBuf sByteBuf = byteBuf.slice();</span><br><span class="line">        System.out.println(<span class="string">"sByteBuf readerIndex="</span> + sByteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + sByteBuf.writerIndex() + <span class="string">"|capacity="</span> + sByteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"byteBuf readerIndex="</span> + byteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + byteBuf.writerIndex() + <span class="string">"|capacity="</span> + byteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"向sByteBuf中写入数据"</span> + sByteBuf.setInt(<span class="number">0</span>, <span class="number">128</span>));</span><br><span class="line">        System.out.println(<span class="string">"sByteBuf="</span> + sByteBuf.getInt(<span class="number">0</span>) + <span class="string">"|sByteBuf="</span> + sByteBuf.getByte(<span class="number">4</span>));</span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf.getInt(<span class="number">0</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getInt(<span class="number">4</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getByte(<span class="number">8</span>));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//返回共享当前ByteBuf信息的新ByteBuf,他们使用独立的readIndex writeIndex markIndex</span></span><br><span class="line">        <span class="comment">//修改返回的ByteBuf或当前ByteBuf会影响彼此的内容，同时它们维护单独的索引和标记,</span></span><br><span class="line">        <span class="comment">// 此方法不会修改当前ByteBuf的readerIndex或writerIndex，</span></span><br><span class="line">        <span class="comment">//另请注意，此方法不会调用&#123;@link #retain（）&#125;，因此不会增加引用计数。</span></span><br><span class="line">        System.out.println(<span class="string">"====================byteBuf.duplicate()=================="</span>);</span><br><span class="line">        ByteBuf dByteBuf = byteBuf.duplicate();</span><br><span class="line">        System.out.println(<span class="string">"dByteBuf readerIndex="</span> + dByteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + dByteBuf.writerIndex() + <span class="string">"|capacity="</span> + dByteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"byteBuf readerIndex="</span> + byteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + byteBuf.writerIndex() + <span class="string">"|capacity="</span> + byteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"向dByteBuf中写入数据"</span> + dByteBuf.setInt(<span class="number">0</span>, <span class="number">100</span>));</span><br><span class="line">        System.out.println(<span class="string">"dByteBuf="</span> + dByteBuf.getInt(<span class="number">0</span>) + <span class="string">"|dByteBuf="</span> + dByteBuf.getInt(<span class="number">4</span>) + <span class="string">"|dByteBuf="</span> + dByteBuf.getByte(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf.getInt(<span class="number">0</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getInt(<span class="number">4</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getByte(<span class="number">8</span>));</span><br><span class="line">        dByteBuf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">2</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"dByteBuf readerIndex="</span> + dByteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + dByteBuf.writerIndex() + <span class="string">"|capacity="</span> + dByteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"byteBuf readerIndex="</span> + byteBuf.readerIndex() + <span class="string">"| writeIndex="</span> + byteBuf.writerIndex() + <span class="string">"|capacity="</span> + byteBuf.capacity());</span><br><span class="line">        System.out.println(<span class="string">"dByteBuf="</span> + dByteBuf.getInt(<span class="number">0</span>) + <span class="string">"|dByteBuf="</span> + dByteBuf.getInt(<span class="number">4</span>) + <span class="string">"|dByteBuf="</span> + dByteBuf.getByte(<span class="number">8</span>) + <span class="string">"|dByteBuf="</span> + dByteBuf.getByte(<span class="number">9</span>));</span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf.getInt(<span class="number">0</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getInt(<span class="number">4</span>) + <span class="string">"|byteBuf="</span> + byteBuf.getByte(<span class="number">8</span>) + <span class="string">"|byteBuf="</span> + dByteBuf.getByte(<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">byteBuf readInt=<span class="number">126</span></span><br><span class="line">byteBuf readerIndex=<span class="number">4</span>| writeIndex=<span class="number">9</span>|capacity=<span class="number">10</span></span><br><span class="line">====================byteBuf.copy()==================</span><br><span class="line">cByteBuf readerIndex=<span class="number">0</span>| writeIndex=<span class="number">5</span>|capacity=<span class="number">5</span></span><br><span class="line">byteBuf readerIndex=<span class="number">4</span>| writeIndex=<span class="number">9</span>|capacity=<span class="number">10</span></span><br><span class="line">向cByteBuf中写入数据PooledUnsafeDirectByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">5</span>, cap: <span class="number">5</span>)</span><br><span class="line">cByteBuf=<span class="number">128</span>|cByteBuf=<span class="number">1</span></span><br><span class="line">byteBuf=<span class="number">126</span>|byteBuf=<span class="number">127</span>|byteBuf=<span class="number">1</span></span><br><span class="line">====================byteBuf.slice()==================</span><br><span class="line">sByteBuf readerIndex=<span class="number">0</span>| writeIndex=<span class="number">5</span>|capacity=<span class="number">5</span></span><br><span class="line">byteBuf readerIndex=<span class="number">4</span>| writeIndex=<span class="number">9</span>|capacity=<span class="number">10</span></span><br><span class="line">向sByteBuf中写入数据UnpooledSlicedByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">5</span>, cap: <span class="number">5</span>/<span class="number">5</span>, unwrapped: PooledUnsafeDirectByteBuf(ridx: <span class="number">4</span>, widx: <span class="number">9</span>, cap: <span class="number">10</span>))</span><br><span class="line">sByteBuf=<span class="number">128</span>|sByteBuf=<span class="number">1</span></span><br><span class="line">byteBuf=<span class="number">126</span>|byteBuf=<span class="number">128</span>|byteBuf=<span class="number">1</span></span><br><span class="line">====================byteBuf.duplicate()==================</span><br><span class="line">dByteBuf readerIndex=<span class="number">4</span>| writeIndex=<span class="number">9</span>|capacity=<span class="number">10</span></span><br><span class="line">byteBuf readerIndex=<span class="number">4</span>| writeIndex=<span class="number">9</span>|capacity=<span class="number">10</span></span><br><span class="line">向dByteBuf中写入数据UnpooledDuplicatedByteBuf(ridx: <span class="number">4</span>, widx: <span class="number">9</span>, cap: <span class="number">10</span>, unwrapped: PooledUnsafeDirectByteBuf(ridx: <span class="number">4</span>, widx: <span class="number">9</span>, cap: <span class="number">10</span>))</span><br><span class="line">dByteBuf=<span class="number">100</span>|dByteBuf=<span class="number">128</span>|dByteBuf=<span class="number">1</span></span><br><span class="line">byteBuf=<span class="number">100</span>|byteBuf=<span class="number">128</span>|byteBuf=<span class="number">1</span></span><br><span class="line">dByteBuf readerIndex=<span class="number">4</span>| writeIndex=<span class="number">10</span>|capacity=<span class="number">10</span></span><br><span class="line">byteBuf readerIndex=<span class="number">4</span>| writeIndex=<span class="number">9</span>|capacity=<span class="number">10</span></span><br><span class="line">dByteBuf=<span class="number">100</span>|dByteBuf=<span class="number">128</span>|dByteBuf=<span class="number">1</span>|dByteBuf=<span class="number">2</span></span><br><span class="line">byteBuf=<span class="number">100</span>|byteBuf=<span class="number">128</span>|byteBuf=<span class="number">1</span>|byteBuf=<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="三、常用方法"><a href="#三、常用方法" class="headerlink" title="三、常用方法"></a>三、常用方法</h3><p>1、<strong>duplicate()</strong>：直接拷贝整个buffer，包括readerIndex、capacity、writerIndex。<br>2、<strong>slice()</strong>：拷贝buffer中已经写入数据的部分。<br>3、<strong>copy()</strong>：方法会进行内存复制工作，效率很低。</p><p>duplicate和copye这两个方法都属于浅拷贝它和原buffer是共享数据的。所以说调用这些方法消耗是很低的，<br>并没有开辟新的空间去存储，但是修改后会影响原buffer。这就会导致一个问题：在源ByteBuf调用release() 之后，<br>一旦引用计数为零，就变得不能访问了；在这种场景下，源ByteBuf的所有浅层复制实例也不能进行读写了；如果强行对浅层复制实例进行读写，则会报错。因此，在调用浅层复制实例时，可以通过调用一次retain() 方法来增加引用，表示它们对应的底层内存多了一次引用，引用计数为2。在浅层复制实例用完后，需要调用两次release()方法，将引用计数减一，这样就不影响源ByteBuf的内存释放。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20211213111512.png" alt="Netty ByteBuf 字节操作"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>log4j2动态修改日志级别</title>
    <url>/post/48969847.html</url>
    <content><![CDATA[<blockquote><p>log4j2实现动态修改日志级别，哇塞！ 好厉害 ~</p></blockquote><a id="more"></a><h3 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h3><h4 id="pom坐标"><a href="#pom坐标" class="headerlink" title="pom坐标"></a>pom坐标</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shuaizi.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.Api;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.Level;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.LogManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.core.LoggerContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.core.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.logging.log4j.core.config.LoggerConfig;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 依赖的pom坐标:</span></span><br><span class="line"><span class="comment"> * &lt;dependency&gt;</span></span><br><span class="line"><span class="comment"> * &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment"> * &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment"> * &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/10/13 15:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Api</span>(value = <span class="string">"log4j2日志接口"</span>, tags = &#123;<span class="string">"日志接口"</span>&#125;)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"获取当前系统log4j2日志级别"</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/logger/level"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLoggerLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LoggerContext ctx = (LoggerContext) LogManager.getContext(<span class="keyword">false</span>);</span><br><span class="line">        Configuration config = ctx.getConfiguration();</span><br><span class="line">        LoggerConfig loggerConfig = config.getLoggerConfig(LogManager.ROOT_LOGGER_NAME);</span><br><span class="line">        <span class="keyword">return</span> loggerConfig.getLevel().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(value = <span class="string">"修改当前系统log4j2日志级别"</span>)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/root/&#123;level&#125;"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateRootLog4j2Level</span><span class="params">(@PathVariable(<span class="string">"level"</span>)</span> @<span class="title">ApiParam</span><span class="params">(<span class="string">"修改debug级别的时候传debug,info级别的时候传info"</span>)</span> String levelName) </span>&#123;</span><br><span class="line">        LoggerContext ctx = (LoggerContext) LogManager.getContext(<span class="keyword">false</span>);</span><br><span class="line">        Configuration config = ctx.getConfiguration();</span><br><span class="line">        LoggerConfig loggerConfig = config.getLoggerConfig(LogManager.ROOT_LOGGER_NAME);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"debug"</span>.equals(levelName)) &#123;</span><br><span class="line">            loggerConfig.setLevel(Level.DEBUG);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">""</span>.equals(levelName)) &#123;</span><br><span class="line">            loggerConfig.setLevel(Level.INFO);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            loggerConfig.setLevel(Level.INFO);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.updateLoggers();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"修改root的log4j2&#123;"</span> + levelName + <span class="string">"&#125;级别成功"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>HashMap的负载因子初始值为什么是0.75？</title>
    <url>/post/fb9b2f80.html</url>
    <content><![CDATA[<blockquote><p>HashMap的负载因子初始值为什么是0.75，总结一下吧 ~</p></blockquote><a id="more"></a><h3 id="一、负载因子的作用"><a href="#一、负载因子的作用" class="headerlink" title="一、负载因子的作用"></a>一、负载因子的作用</h3><p>负载因子是和扩容机制有关的，意思是如果当前容器的容量，达到了我们设定的最大值，就要开始执行扩容操作。相当于是一个扩容机制的阈值。当超过了这个阈值，就会触发扩容机制。</p><blockquote><p>比如说当前的容器容量是16，负载因子是0.75,16*0.75=12，也就是说，当容量达到了12的时候就会进行扩容操作。</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>翻看HashMap的源码可以看出，系统默认的负载因子值就是0.75，而且我们还可以在构造方法中去指定。</p><h3 id="二、原因解释"><a href="#二、原因解释" class="headerlink" title="二、原因解释"></a>二、原因解释</h3><h4 id="1、负载因子是1-0"><a href="#1、负载因子是1-0" class="headerlink" title="1、负载因子是1.0"></a><strong>1、负载因子是1.0</strong></h4><p>我们先看HashMap的底层数据结构</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220407162656.png" alt=""></p><p>我们的数据一开始是保存在数组里面的，当发生了Hash碰撞的时候，就是在这个数据节点上，生出一个链表，当链表长度达到一定长度的时候，就会把链表转化为红黑树。</p><p><strong>当负载因子是1.0的时候，也就意味着，只有当数组的8个值（这个图表示了8个）全部填充了，才会发生扩容。这就带来了很大的问题，因为Hash冲突时避免不了的。当负载因子是1.0的时候，意味着会出现大量的Hash的冲突，底层的红黑树变得异常复杂。对于查询效率极其不利。这种情况就是牺牲了时间来保证空间的利用率。</strong></p><p><em>一句话总结就是负载因子过大，虽然空间利用率上去了，但是时间效率降低了。</em></p><h4 id="2、负载因子是0-5"><a href="#2、负载因子是0-5" class="headerlink" title="2、负载因子是0.5"></a><strong>2、负载因子是0.5</strong></h4><p>负载因子是0.5的时候，这也就意味着，当数组中的元素达到了一半就开始扩容，既然填充的元素少了，Hash冲突也会减少，那么底层的链表长度或者是红黑树的高度就会降低。查询效率就会增加。</p><p>但是，这时候空间利用率就会大大的降低，原本存储1M的数据，现在就意味着需要2M的空间。</p><p><em>一句话总结就是负载因子太小，虽然时间效率提升了，但是空间利用率降低了。</em></p><h4 id="3、负载因子0-75"><a href="#3、负载因子0-75" class="headerlink" title="3、负载因子0.75"></a><strong>3、负载因子0.75</strong></h4><p>经过前面的分析，基本上为什么是0.75的答案也就出来了，这是时间和空间的权衡。当然这个答案不是我自己想出来的。答案就在源码上，我们可以看看：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;As a general rule, the default load factor (.75) offers a good</span></span><br><span class="line"><span class="comment">* tradeoff between time and space costs.  Higher values decrease the</span></span><br><span class="line"><span class="comment">* space overhead but increase the lookup cost (reflected in most of</span></span><br><span class="line"><span class="comment">* the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class, including</span></span><br><span class="line"><span class="comment">* &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number of entries in</span></span><br><span class="line"><span class="comment">* the map and its load factor should be taken into account when</span></span><br><span class="line"><span class="comment">* setting its initial capacity, so as to minimize the number of</span></span><br><span class="line"><span class="comment">* rehash operations.  If the initial capacity is greater than the</span></span><br><span class="line"><span class="comment">* maximum number of entries divided by the load factor, no rehash</span></span><br><span class="line"><span class="comment">* operations will ever occur.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>大致意思就是说负载因子是0.75的时候，空间利用率比较高，而且避免了相当多的Hash冲突，使得底层的链表或者是红黑树的高度比较低，提升了空间效率。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Container</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Service Mesh 服务网格</title>
    <url>/post/28775a98.html</url>
    <content><![CDATA[<blockquote><p>Service Mesh服务网格 !</p></blockquote><a id="more"></a><h3 id="一、什么是ServiceMesh"><a href="#一、什么是ServiceMesh" class="headerlink" title="一、什么是ServiceMesh"></a>一、什么是ServiceMesh</h3><p>Service Mesh是用于处理服务间通信的基础设施层，用于在云原生应用复杂的服务拓扑中实现可靠的请求传递。在实践中，Service Mesh通常是一组与应用一起部署，但对应用透明的轻量级网络代理。Service Mesh与传统基础设施层不同之处在于，它形成了一个分布式的互连代理网络，以Sidecar形式部署在服务两侧，服务对于代理无感知，且服务间所有通信都由代理进行路由。</p><p>如果简单的描述的话，可以将它比作是应用程序或者说微服务间的 TCP/IP，负责服务之间的网络调用、限流、熔断和监控，如果使用 ServiceMesh 也就无须关系服务之间的那些原来是通过应用程序或者其他框架实现的事情，比如 Spring Cloud、OSS，现在只要交给 ServiceMesh 就可以了。ServiceMesh的出现主要是由于应用虚拟化技术的发展，例如Kubernetes,Rainbond等项目，大大降低了应用的部署和运维复杂度。</p><p>Service Mesh 中文称为 服务网格，为啥，因为它的部署图看起来就像一个网格，如下图：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220418142746.jpg" alt=""></p><h3 id="二、为什么需要ServiceMesh"><a href="#二、为什么需要ServiceMesh" class="headerlink" title="二、为什么需要ServiceMesh"></a>二、为什么需要ServiceMesh</h3><p>在传统微服务架构中，随着业务越来越大，拆分的服务实例也越来越多，那么各个服务之间的依赖就变成了非常复杂的网络拓扑结构，可能就类似于这样了：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220418142832.jpg" alt=""></p><p>在如此复杂的分布式部署结构下，咱们微服务中服务依赖调用和数据传输所面临的问题也成倍增加，极大的提高了服务治理的难度。</p><p>同时，由于 容器化技术 的成熟和规模化，微服务都会采用容器化，并朝着 云原生应用 的方向发展。而传统的微服务架构中，虽然也有服务治理的组件，但是这些组件大多需要在应用代码里进行集成，这是不符合 云原生应用 的思想的。因此，大家急需一个标准化，能高效部署和运维的微服务体系方案。</p><p>因此，Service Mesh 就出现了，Service Mesh 就是用来解决这些痛点的，设计的目的就是用来解决微服务架构中 服务间可靠调用、服务治理 等问题。</p><p>下面就拿第一代 Service Mesh 产品 Linkerd 举例说明：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220418143015.jpg" alt=""></p><p>图中可以看到，每一个服务实例（Service）的部署都会同时部署一个 Linkerd 实例，并且服务之间的调用并不是直接进行的，而是先经过 Linkerd 模块去代理转发完成的。</p><p>例如：Service A 需要调用 Service B 的时候，Service A 是把请求发给与它一起部署的 Linkerd-1 的，然后这个 Linkerd-1 将请求发给 Service B 所部署模块的 Linkerd-2，然后 Linkerd-2 再将请求内容转发给 Service B 处理。因此，在整个流程中，Service A 和 Service B 只需要关注自己的业务逻辑即可，无需关注任何服务框架的功能，这些服务框架的功能都是由Linkerd 去实现，Linkerd 要做 负载均衡、熔断、限流、监控等等。</p><h3 id="三、ServiceMesh原理与应用"><a href="#三、ServiceMesh原理与应用" class="headerlink" title="三、ServiceMesh原理与应用"></a>三、ServiceMesh原理与应用</h3><p>Service Mesh 的核心其实就2个模块：<strong>SideCar</strong> 与 <strong>Control Plane</strong>，如图：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220418143104.jpg" alt=""></p><p>搞懂了 SideCar 与 Control Plane 也就对 Service Mesh 的基础思想原理明白了。</p><h4 id="SideCar"><a href="#SideCar" class="headerlink" title="SideCar"></a>SideCar</h4><p>上面说到的与服务部署在一起的轻量级网络代理也就是指SideCar，它的作用就是实现服务框架的各项功能，这样，就可以让服务（Service A 或 Service B）回归业务本质。</p><p>传统的微服务架构中，各种服务框架的功能（例如：服务发现、负载均衡、限流熔断等）都代码逻辑或多或少的都需要耦合到服务实例的代码里，给服务实例增加了很多无关业务的代码，也带来了复杂度。</p><p>有了SideCar之后，服务节点只做业务逻辑自身的功能，服务之间的调用交给了SideCar，由SideCar去注册服务、去做服务发现、去做请求路由、去实现熔断限流、去做日志统计。</p><p>那么在这种新的微服务架构中，所有的 SideCar 组成在一起，其实就是一个服务网格了。那么这个大型的服务网格并不是完全自治的，它还需要一个统一的控制节点，也就是 Control Plane。</p><h4 id="Control-Plane"><a href="#Control-Plane" class="headerlink" title="Control Plane"></a>Control Plane</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220418143312.jpg" alt=""></p><p>Control Plane 是用来从全局的角度上控制 SideCar 的。比如 它负责所有 SideCar 的注册，它存储一个统一的路由表，帮助各个 SideCar 进行负载均衡和请求调度。它收集所有 SideCar 的监控信息和日志数据。它就相当于 Service Mesh架构 的大脑。Control Plane 控制着 SideCar 来实现服务治理的各项功能。</p><p>在文章的最开始提到过，以 Linkerd 为代表的被称为第一代 Service Mesh，而以 Istio 为代表的称为了第二代 Service Mesh。主要的不同就是 Istio 引入了 Control Plane 的概念，可以通过 Control Plane 来对服务进行一些精细化控制，所以 Istio 也被称为是实际上的 Service Mesh 标准产品。</p><h3 id="四、ServiceMesh平台功能对比"><a href="#四、ServiceMesh平台功能对比" class="headerlink" title="四、ServiceMesh平台功能对比"></a>四、ServiceMesh平台功能对比</h3><style>table th:first-of-type{width:80px}</style><table><thead><tr><th align="center">功能</th><th align="center">Linkerd</th><th align="center">Envoy</th><th align="center">Istio</th><th align="center">Conduit</th></tr></thead><tbody><tr><td align="center">代理</td><td align="center">Finagle(scala) + Jetty(java)</td><td align="center">Envoy(c++)</td><td align="center">Envoy(c++)/Mosn(golang)</td><td align="center">Conduit(rust)</td></tr><tr><td align="center">熔断</td><td align="center">支持，基于连接的熔断器Fast Fail和基于请求的熔断器Failure Accrual</td><td align="center">支持，通过特定准则，如最大连接数、 最大请求数、最大挂起请求数或者最大重试数的设定</td><td align="center">支持，通过特定准则，如最大连接数和最大请求数等的设定</td><td align="center">暂不支持</td></tr><tr><td align="center">动态路由</td><td align="center">支持，通过设置Linkerd的dtab规则实现不同版本服务请求的动态路由</td><td align="center">支持，通过服务的版本或环境信息实现</td><td align="center">支持，通过服务的版本或环境信息实现</td><td align="center">暂不支持</td></tr><tr><td align="center">流量分流</td><td align="center">支持，以增量和受控的方式实现分流</td><td align="center">支持，以增量和受控的方式实现分流</td><td align="center">支持，以增量和受控的方式实现分流</td><td align="center">暂不支持</td></tr><tr><td align="center">服务发现</td><td align="center">支持，支持多种服务发现机制，如基于文件的服务发现、Consul、Zookeeper、Kubernetes等</td><td align="center">支持，通过提供平台无关的服务发现接口实现与不同服务发现工具集成</td><td align="center">支持，通过提供平台无关的服务发现接口实现与不同服务发现工具集成</td><td align="center">只支持Kubernetes</td></tr><tr><td align="center">负载均衡</td><td align="center">支持，提供多种负载均衡算法</td><td align="center">支持，提供多种负载均衡算法，如Round Robin、加权最小请求、哈希环、Maglev等</td><td align="center">支持，提供多种负载均衡算法，如Round Robin、加权最小请求、哈希环、Maglev等</td><td align="center">支持，当前只有HTTP请求支持基于 P2C + least-loaded的负载均衡算法</td></tr><tr><td align="center">安全通信</td><td align="center">支持TLS</td><td align="center">支持TLS</td><td align="center">支持TLS</td><td align="center">支持TLS</td></tr><tr><td align="center">访问控制</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持，基于RBAC的访问控制</td><td align="center">暂不支持</td></tr><tr><td align="center">可见性</td><td align="center">分布式追踪(Zipkin)、运行时指标(InfluxDB、Prometheus、statsd)</td><td align="center">分布式追踪(Zipkin)、运行时指标(statsd)</td><td align="center">分布式追踪(Zipkin)、运行时指标(Prometheus、statsd)、监控(NewRepic、Stackdriver)</td><td align="center">运行时指标(Prometheus)</td></tr><tr><td align="center">部署模式</td><td align="center">sidecar或者per-host模式</td><td align="center">sidecar模式</td><td align="center">sidecar模式</td><td align="center">sidecar模式</td></tr><tr><td align="center">控制平面</td><td align="center">Namerd(scala)</td><td align="center">没有，但可通过API实现(api)</td><td align="center">Pilot、Mixer、Citadel(golang)</td><td align="center">Conduit(golang)</td></tr><tr><td align="center">协议支持</td><td align="center">HTTP/1.x、HTTP/2、gRPC</td><td align="center">HTTP/1.x、HTTP/2、gRPC、TCP</td><td align="center">HTTP/1.x、HTTP/2、gRPC、TCP, dubbo(mosn)</td><td align="center">HTTP/1.x、HTTP/2、gRPC、TCP</td></tr><tr><td align="center">运行平台</td><td align="center">平台无关</td><td align="center">平台无关</td><td align="center">目前支持Kubernetes，平台无关是最终实现目标</td><td align="center">只支持Kubernetes</td></tr></tbody></table><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>middleware</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化和反序列化相关问题分析</title>
    <url>/post/c71ae8ea.html</url>
    <content><![CDATA[<blockquote><p>Java序列化和反序列化介绍 ~</p></blockquote><a id="more"></a><h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>​ Java对象<strong>序列化</strong>的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。<strong>反序列化</strong>就是根据这些保存的信息重建对象的过程。</p><p>序列化：将java对象转化为字节序列的过程。</p><p>反序列化：将字节序列转化为java对象的过程。</p><h3 id="二、为什么要序列化和反序列化"><a href="#二、为什么要序列化和反序列化" class="headerlink" title="二、为什么要序列化和反序列化"></a>二、为什么要序列化和反序列化</h3><p>​ 我们知道，当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本、图片、音频、视频等， 而这些数据都会以二进制序列的形式在网络上传送。那么当两个Java进程进行通信时，能否实现进程间的对象传送呢？答案是可以的。如何做到呢？这就需要Java序列化与反序列化了。换句话说，一方面，发送方需要把这个Java对象转换为字节序列，然后在网络上传送；另一方面，接收方需要从字节序列中恢复出Java对象。当我们明晰了为什么需要Java序列化和反序列化后，我们很自然地会想Java序列化的好处。其好处一是实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里），二是，利用序列化实现远程通信，即在网络上传送对象的字节序列。</p><h3 id="三、序列化ID的作用"><a href="#三、序列化ID的作用" class="headerlink" title="三、序列化ID的作用"></a>三、序列化ID的作用</h3><p>​ 其实，这个序列化ID起着关键的作用，它决定着是否能够成功反序列化！简单来说，java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地实体类中的serialVersionUID进行比较，如果相同则认为是一致的，便可以进行反序列化，否则就会报序列化版本不一致的异常。</p><h3 id="四、序列化ID如何产生"><a href="#四、序列化ID如何产生" class="headerlink" title="四、序列化ID如何产生"></a>四、序列化ID如何产生</h3><p>​ 当我们一个实体类中没有显示的定义一个名为“serialVersionUID”、类型为long的变量时，Java序列化机制会根据编译时的class自动生成一个serialVersionUID作为序列化版本比较，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID。譬如，当我们编写一个类时，随着时间的推移，我们因为需求改动，需要在本地类中添加其他的字段，这个时候再反序列化时便会出现serialVersionUID不一致，导致反序列化失败。那么如何解决呢？便是在本地类中添加一个“serialVersionUID”变量，值保持不变，便可以进行序列化和反序列化。</p><h3 id="五、Java对象序列化的方式"><a href="#五、Java对象序列化的方式" class="headerlink" title="五、Java对象序列化的方式"></a>五、Java对象序列化的方式</h3><h4 id="1、原生序列化方式"><a href="#1、原生序列化方式" class="headerlink" title="1、原生序列化方式"></a>1、原生序列化方式</h4><p>在Java中，如果一个对象要想实现序列化，必须要实现下面两个接口之一：</p><ul><li><p><strong>Serializable 接口</strong></p><p>一个对象想要被序列化，那么它的类就要实现此接口或者它的子接口。</p><p>这个对象的所有属性（包括private属性、包括其引用的对象）都可以被序列化和反序列化来保存、传递。不想序列化的字段可以使用transient修饰。</p></li><li><p><strong>Externalizable 接口</strong></p><p>它是Serializable接口的子类，用户要实现的writeExternal()和readExternal() 方法，用来决定如何序列化和反序列化。</p></li></ul><h4 id="2、Json序列化"><a href="#2、Json序列化" class="headerlink" title="2、Json序列化"></a>2、Json序列化</h4><p>jackson、fastjson</p><h4 id="3、ProtoBuff序列化"><a href="#3、ProtoBuff序列化" class="headerlink" title="3、ProtoBuff序列化"></a>3、ProtoBuff序列化</h4><p>ProtocolBuffer是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化。适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p><p>优点：跨语言；序列化后数据占用空间比JSON小，JSON有一定的格式，在数据量上还有可以压缩的空间。</p><p>缺点：它以二进制的方式存储，无法直接读取编辑，除非你有 .proto 定义，否则无法直接读出 Protobuffer的任何内容。</p><p>其与thrift的对比：两者语法类似，都支持版本向后兼容和向前兼容，thrift侧重点是构建跨语言的可伸缩的服务，支持的语言多，同时提供了全套RPC解决方案，可以很方便的直接构建服务，不需要做太多其他的工作。 Protobuffer主要是一种序列化机制，在数据序列化上进行性能比较，Protobuffer相对较好。</p><p>百度研发的<strong>jprotobuf</strong>框架将Google原始的protobuf进行了封装，对其进行简化，仅提供序列化和反序列化方法。</p><h3 id="六、为什么说序列化并不安全"><a href="#六、为什么说序列化并不安全" class="headerlink" title="六、为什么说序列化并不安全"></a>六、为什么说序列化并不安全</h3><p>因为序列化的对象数据转换为二进制，并且完全可逆。但是在RMI调用时，所有private字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的。</p><p>解决方案：<br>1、 序列化Hook化（移位和复位）<br>2、 序列数据加密和签名<br>3、 利用transient的特性解决<br>4、 打包和解包代理</p><h3 id="七、序列化和单例模式"><a href="#七、序列化和单例模式" class="headerlink" title="七、序列化和单例模式"></a>七、序列化和单例模式</h3><p>所谓单例：就是单例模式就是在整个全局中（无论是单线程还是多线程），该对象只存在一个实例，而且只应该存在一个实例，没有副本。<br>序列化对单例有破坏的：<br>1、通过对某个对象的序列化与反序列化得到的对象是一个新的对象，这就破坏了单例模式的单例性。<br>2、我们知道readObject()的时候，底层运用了反射的技术，序列化会通过反射调用无参数的构造方法创建一个新的对象。这破坏了对象的单例性。<br>3、解决方案：在需要的单例的对象类中添加。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Drools规则引擎</title>
    <url>/post/7180ebce.html</url>
    <content><![CDATA[<blockquote><p>Drools 规则引擎 ~</p></blockquote><a id="more"></a><h3 id="什么是规则引擎"><a href="#什么是规则引擎" class="headerlink" title="什么是规则引擎"></a>什么是规则引擎</h3><p>规则引擎是处理复杂规则集合的引擎。通过输入一些基础事件，以推演或者归纳等方式，得到最终的执行结果。规则引擎的核心作用在于将复杂、易变的规则从系统中抽离出来，由灵活可变的规则来描述业务需求。</p><h3 id="Drools-简介"><a href="#Drools-简介" class="headerlink" title="Drools 简介"></a>Drools 简介</h3><p>Drools 是 Java 编写的一款开源规则引擎。Drools 的核心算法基于 Rete。早些版本中，Drools 使用的是基于 Rete 二次开发的 ReteOO 算法。在 7.x 版本的 Drools 中，其内部算法已经改为使用 Phreak。Phreak 也是Drools 团队自研的算法，虽然网上关于该算法的资料很少，但是总体来说与 Rete 算法相似。阅读本文之前可以先了解下 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FRete_algorithm" target="_blank" rel="noopener">Rete 算法</a>。</p><h3 id="规则引擎的构成"><a href="#规则引擎的构成" class="headerlink" title="规则引擎的构成"></a>规则引擎的构成</h3><p>drools规则引擎由以下三部分构成：</p><ol><li>Working Memory（工作内存）</li><li>Rule Base（规则库）</li><li>Inference Engine（推理引擎）</li><li>其中Inference Engine（推理引擎）又包括：<ul><li>Pattern Matcher（匹配器） 具体匹配哪一个规则，由这个完成</li><li>Agenda(议程)</li><li>Execution Engine（执行引擎）</li></ul></li></ol><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20220809104314344.png" alt=""></p><h3 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h3><ol><li>单独使用 drools；</li><li>搭配spring使用，springboot整合Drools；</li></ol><blockquote><p>IDEA安装了drools插件，支持drools语法编写。</p></blockquote><p>详细代码不在这里做详细描述。</p><h3 id="规则动态存储数据库"><a href="#规则动态存储数据库" class="headerlink" title="规则动态存储数据库"></a>规则动态存储数据库</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>需要把规则文件的内容存储在数据库中；</li><li>Drools相关对象（例如KieContainer对象）的创建都基于数据库中存储的规则来创建；</li><li>提供HTTP访问接口，当规则发生变化时调用此接口重新加载数据库中的规则，重新创建KieContainer等对象；</li></ol><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> droolsRule</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">id</span>               <span class="built_in">bigint</span> auto_increment</span><br><span class="line">        primary <span class="keyword">key</span>,</span><br><span class="line">    <span class="keyword">content</span>          <span class="built_in">text</span>         <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    create_time      <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    last_modify_time <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="literal">null</span>,</span><br><span class="line">    rule_key         <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">version</span>          <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">constraint</span> UK_9yepjak9olg92holwkr8p3l0f</span><br><span class="line">        <span class="keyword">unique</span> (rule_key),</span><br><span class="line">    <span class="keyword">constraint</span> UK_ei48upwykmhx9r5p7p4ndxvgn</span><br><span class="line">        <span class="keyword">unique</span> (last_modify_time),</span><br><span class="line">    <span class="keyword">constraint</span> UK_ilmbp99kyt6gy10224pc9bl6n</span><br><span class="line">        <span class="keyword">unique</span> (<span class="keyword">version</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> drools.droolsRule (<span class="keyword">id</span>, <span class="keyword">content</span>, create_time, last_modify_time, rule_key, <span class="keyword">version</span>)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">'package rules;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import com.shuaizi.domain.Order;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//100元以下不加分</span></span><br><span class="line"><span class="string">rule "score_1" //名称需唯一</span></span><br><span class="line"><span class="string">when</span></span><br><span class="line"><span class="string">$orderTest:Order(amount &lt; 100);</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">$orderTest.setScore(0);</span></span><br><span class="line"><span class="string">System.out.println("触发规则，100元以下不加分");</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//100元-500元 加100分</span></span><br><span class="line"><span class="string">rule "score_2"</span></span><br><span class="line"><span class="string">when</span></span><br><span class="line"><span class="string">$orderTest:Order(100 &lt; amount &amp;&amp; amount&lt; 500)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">$orderTest.setScore(100);</span></span><br><span class="line"><span class="string">System.out.println("触发规则，100元-500元 加100分");</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//500元-1000元 加500分</span></span><br><span class="line"><span class="string">rule "score_3"</span></span><br><span class="line"><span class="string">when</span></span><br><span class="line"><span class="string">$orderTest:Order(500 &lt; amount &amp;&amp; amount &lt; 1000)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">$orderTest.setScore(500);</span></span><br><span class="line"><span class="string">System.out.println("触发规则，500元-1000元 加500分");</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//1000元以上 加1000分</span></span><br><span class="line"><span class="string">rule "score_4"</span></span><br><span class="line"><span class="string">when</span></span><br><span class="line"><span class="string">$orderTest:Order(1000 &lt; amount)</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line"><span class="string">$orderTest.setScore(1000);</span></span><br><span class="line"><span class="string">System.out.println("触发规则，500元-1000元 加1000分");</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">'</span>, <span class="string">'2022-08-09 12:12:23'</span>, <span class="string">'2022-08-09 12:12:23'</span>, <span class="string">'1'</span>, <span class="string">'1.0'</span>);</span><br></pre></td></tr></table></figure><h4 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shuaizi.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableId;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableName;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.EqualsAndHashCode;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"><span class="keyword">import</span> lombok.experimental.Accessors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 规则对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/9 10:50 AM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode</span>(callSuper = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@TableName</span>(<span class="string">"droolsRule"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rule</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@TableId</span>(value = <span class="string">"id"</span>, type = IdType.INPUT)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String ruleKey;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">    <span class="keyword">private</span> String lastModifyTime;</span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有的规则配置类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/8/8 6:10 PM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DroolsKieAllConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RULES_PATH = <span class="string">"rules/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReloadDroolsRulesService droolsRulesService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DroolsKieAllConfig</span><span class="params">(ReloadDroolsRulesService droolsRulesService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.droolsRulesService = droolsRulesService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieContainer <span class="title">kieContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> KieRepository kieRepository = getKieServices().getRepository();</span><br><span class="line">        kieRepository.addKieModule(kieRepository::getDefaultReleaseId);</span><br><span class="line">        KieBuilder kieBuilder = getKieServices().newKieBuilder(kieFileSystem());</span><br><span class="line">        kieBuilder.buildAll();</span><br><span class="line">        <span class="keyword">return</span> getKieServices().newKieContainer(kieRepository.getDefaultReleaseId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> KieServices <span class="title">getKieServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> KieServices.Factory.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> KieFileSystem <span class="title">kieFileSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KieFileSystem kieFileSystem = getKieServices().newKieFileSystem();</span><br><span class="line">         <span class="comment">// 加载数据库中存储的规则</span></span><br><span class="line">        List&lt;DroolsRule&gt; all = droolsRulesService.loadRules();</span><br><span class="line">        all.forEach(droolsRule -&gt; &#123;</span><br><span class="line">            <span class="comment">//该目录文件为虚拟目录,不需要实际存在,**后缀一定要带.drl**</span></span><br><span class="line">            String path = <span class="string">"src/main/resources/"</span> + RULES_PATH + droolsRule.getId() + <span class="string">".drl"</span>;</span><br><span class="line">            kieFileSystem.write(path, droolsRule.getContent().getBytes());</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> kieFileSystem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重新加载所有的规则</span></span><br><span class="line"><span class="comment"> * 访问地址：&lt;a href="http://127.0.0.1:2342/rules/reloading"&gt;访问地址&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/reloading"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reloading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        KieContainer kieContainer = droolsKieAllConfig.kieContainer();</span><br><span class="line">        kieContext.update(kieContainer);</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; stringListMap = kieContext.droolsBaseInfo();</span><br><span class="line">        System.out.println(stringListMap);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"重载kie异常,异常为:&#123;&#125;"</span>, e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="workBench"><a href="#workBench" class="headerlink" title="workBench"></a>workBench</h3><p><a href="http://www.bigtspace.com/archives/7588.html" target="_blank" rel="noopener">《 workbench学习和案例 》</a></p><h3 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h3><p><a href="https://blog.csdn.net/chy_18883701161/article/details/124027004" target="_blank" rel="noopener">《资料 1》</a><br><a href="https://blog.csdn.net/qq_41358574/article/details/122323187" target="_blank" rel="noopener">《资料 2》</a><br><a href="https://blog.csdn.net/weixin_44728369/article/details/120413891" target="_blank" rel="noopener">《资料 3》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Drools</tag>
      </tags>
  </entry>
  <entry>
    <title>UUID太长怎么办？快来试试NanoId (Java版本)</title>
    <url>/post/8b659f0f.html</url>
    <content><![CDATA[<blockquote><p>UUID太长怎么办？快来试试NanoId吧 ~</p></blockquote><a id="more"></a><h3 id="一、什么是NanoId"><a href="#一、什么是NanoId" class="headerlink" title="一、什么是NanoId"></a>一、什么是NanoId</h3><p>Nano ID 与 UUID v4 (基于随机) 相当。它们在 ID 中有相似数量的随机位 (Nano ID 为126，UUID 为122),因此它们的冲突概率相似,要想有十亿分之一的重复机会, 必须产生103万亿个版本4的ID。NanoID的有一个特点是它允许开发者使用自定义字母。你可以改变字面意思或ID的大小。考虑到它的小尺寸、URL 友好性、安全性和速度，我建议在未来的任何项目中使用 NanoID 而不是 UUID。</p><h3 id="二、如何使用"><a href="#二、如何使用" class="headerlink" title="二、如何使用"></a>二、如何使用</h3><p>引入pom坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.aventrix.jnanoid<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jnanoid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="三、工具类"><a href="#三、工具类" class="headerlink" title="三、工具类"></a>三、工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NanoId生成工具类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mr.Jia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/3/28 17:16</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NanoIdUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SecureRandom DEFAULT_NUMBER_GENERATOR = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">char</span>[] DEFAULT_ALPHABET = <span class="string">"_-0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>.toCharArray();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NanoIdUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomNanoId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> randomNanoId(DEFAULT_NUMBER_GENERATOR, DEFAULT_ALPHABET, DEFAULT_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">randomNanoId</span><span class="params">(Random random, <span class="keyword">char</span>[] alphabet, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (random == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"random cannot be null."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alphabet == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"alphabet cannot be null."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alphabet.length != <span class="number">0</span> &amp;&amp; alphabet.length &lt; <span class="number">256</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"size must be greater than zero."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mask = (<span class="number">2</span> &lt;&lt; (<span class="keyword">int</span>) Math.floor(Math.log((<span class="keyword">double</span>) (alphabet.length - <span class="number">1</span>)) / Math.log(<span class="number">2.0</span>D))) - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> step = (<span class="keyword">int</span>) Math.ceil(<span class="number">1.6</span>D * (<span class="keyword">double</span>) mask * (<span class="keyword">double</span>) size / (<span class="keyword">double</span>) alphabet.length);</span><br><span class="line">                StringBuilder idBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[step];</span><br><span class="line">                    random.nextBytes(bytes);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; step; ++i) &#123;</span><br><span class="line">                        <span class="keyword">int</span> alphabetIndex = bytes[i] &amp; mask;</span><br><span class="line">                        <span class="keyword">if</span> (alphabetIndex &lt; alphabet.length) &#123;</span><br><span class="line">                            idBuilder.append(alphabet[alphabetIndex]);</span><br><span class="line">                            <span class="keyword">if</span> (idBuilder.length() == size) &#123;</span><br><span class="line">                                <span class="keyword">return</span> idBuilder.toString();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"alphabet must contain between 1 and 255 symbols."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(NanoIdUtils.randomNanoId());</span><br><span class="line">            System.out.println(UUID.randomUUID());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、举例"><a href="#四、举例" class="headerlink" title="四、举例"></a>四、举例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9GbBeXWTgzhHyq6D2Yw2k</span><br><span class="line">M-EQX_HNQIhnAZvt9wsnV</span><br><span class="line">lWsqiiICbO3Ap6YoyRI_h</span><br><span class="line">gIKypjdIQmr8b-KplY9LF</span><br><span class="line">dughj0nsIoExHLCn9sEGU</span><br><span class="line">i7QutbhcpD-haYhudeTsx</span><br><span class="line">OkjYlBa8uzTu5NiMfYkIY</span><br><span class="line">dTVLLd9r8VhzUGw2MxoLy</span><br><span class="line">CPsmZfnGeydbT8KiNDtmH</span><br><span class="line">sOEMsKe2xpvFiO6VOXOGw</span><br></pre></td></tr></table></figure><h3 id="五、优秀资料"><a href="#五、优秀资料" class="headerlink" title="五、优秀资料"></a>五、优秀资料</h3><p><a href="https://zhuanlan.zhihu.com/p/472060150" target="_blank" rel="noopener">《是时候使用NanoID取代UUID了》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Java多线程- wait/notify机制</title>
    <url>/post/19d6c147.html</url>
    <content><![CDATA[<blockquote><p>Java多线程- wait/notify机制介绍 ~</p></blockquote><a id="more"></a><h3 id="Wait与Notify"><a href="#Wait与Notify" class="headerlink" title="Wait与Notify"></a>Wait与Notify</h3><p><strong>wait：调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的锁.</strong></p><p><strong>notify：调用某个对象的notify()方法能够唤醒一个正在等待这个对象的锁的线程，如果有多个线程都在等待这个对象的锁，则只能唤醒其中一个线程</strong></p><p><strong>notifyAll：方法能够唤醒所有正在等待这个对象锁的线程；</strong></p><p>wait是Object类的方法，而同样可以实现阻塞功能的sleep()方法是Thread类的方法，必须使用synchorized代码块进行控制，而sleep()方法可以在任何需要的时候使用，如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放该同步锁，wait()会释放该同步锁。</p><p>notify()不会立刻立刻释放syncronized（obj）中的obj锁，必须要等notify()所在线程执行完synchronized（obj）块中的所有代码才会释放这把锁。</p><p>由上面第二条结论，我们在使用wait()、notify()方法进行控制之后，若notify()对应同步块方法仍未执行完，仍会占有锁，那么wait()对应线程也是没办法执行的，因为获取不到锁。所以应该notify完之后再次wait，从而将锁释放。</p><h3 id="Notify和NotifyAll的区别"><a href="#Notify和NotifyAll的区别" class="headerlink" title="Notify和NotifyAll的区别"></a>Notify和NotifyAll的区别</h3><p><strong>notify</strong>只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；<br><strong>notifyAll</strong>会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会；</p><h3 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.shuaizi.Thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">":"</span> + Thread.currentThread().getName() + <span class="string">"进入启动"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//使当前线程进入等待(进入Object.wait队列)并释放对象锁</span></span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">":"</span> + Thread.currentThread().getName() + <span class="string">"线程执行结束"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        Thread thread_2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                System.out.println(System.currentTimeMillis() + <span class="string">":"</span> + Thread.currentThread().getName() + <span class="string">"进入启动"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//随机在Object.waitd队列中唤醒一个正在等待该对象锁的线程</span></span><br><span class="line">                    object.notify();</span><br><span class="line">                    System.out.println(System.currentTimeMillis() + <span class="string">":"</span> + Thread.currentThread().getName() + <span class="string">"唤醒一个等待的线程"</span>);</span><br><span class="line">                    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread_2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从时间戳中可以看出 Thread-1 在通知Thread-0 继续执行后，Thread-0 并未立即执行，而是等待Thread-1 释放Object锁，在重新获得Object锁后，才能继续执行。(最后两个时间戳相减刚好是10秒)</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Volatile实现原理</title>
    <url>/post/93ed042.html</url>
    <content><![CDATA[<blockquote><p>volatile 相关整理和认识 ~</p></blockquote><a id="more"></a><h3 id="一、volatile关键字"><a href="#一、volatile关键字" class="headerlink" title="一、volatile关键字"></a>一、volatile关键字</h3><p>volatile 可以说是 JVM 提供的最轻量级的同步机制，当一个变量定义为volatile之后，它将具备两种特性：</p><ol><li><p>保证变量在多线程之间的可见性。当被volatile修饰的变量被修改时，其他线程能立刻读到被修改变量的最新值。</p></li><li><p>禁止指令重排序优化。普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。被volatile修饰的变量通过在读写指令附加 <u>内存屏障指令</u> 来禁止重排序，从而保证代码的执行顺序一致。</p></li></ol><h3 id="二、指令重排序"><a href="#二、指令重排序" class="headerlink" title="二、指令重排序"></a>二、指令重排序</h3><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p><ol><li>编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li><li>从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：<br>a. 源代码；<br>b. 编译器优化重排序；<br>c. 指令集重排序；<br>d. 内存系统重排序；<br>e. 最终执行的指令；</li><li>JMM 属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</li><li>java 编译器禁止处理器重排序是通过在生成指令序列的适当位置会插入内存屏障（重排序时不能把后面的指令重排序到内存屏障之前的位置）指令来实现的。</li><li>重排序需要遵守happens-before规则。(JSR133对happens-before有明确定义)</li></ol><h3 id="三、应该如何正确地进行多线程编程"><a href="#三、应该如何正确地进行多线程编程" class="headerlink" title="三、应该如何正确地进行多线程编程"></a>三、应该如何正确地进行多线程编程</h3><p><strong>在多线程的环境中，可见性、有序性以及原子性是构成线程安全的基石。</strong></p><ul><li><p><strong>可见性</strong></p><p>通过volatile修饰变量保证变量被修改后其他线程立即可见。</p><p>atomic 原子操作也可以保证可见性（高效且不需要使用同步，基于CAS）</p></li><li><p><strong>有序性</strong></p><p>通过Volatile修饰变量禁止指令重排序严格保证代码的执行有序性。</p></li><li><p><strong>原子性</strong></p><p>要严格保证原子性，需要在volatile修饰的基础上，使用同步块技术（锁）和Java concurrent包（原子操作类等）。另外还有：CAS无锁算法</p></li></ul><h3 id="四、Volatile和Synchronized区别"><a href="#四、Volatile和Synchronized区别" class="headerlink" title="四、Volatile和Synchronized区别"></a>四、Volatile和Synchronized区别</h3><p><strong>Volatile只是保证变量可见性，并不能确保原子性。</strong>它是<u>依赖CPU提供的特殊指令内存屏障指令来控制可见性</u>，被Volatile修饰的成员变量在被线程访问时在读操作前会强行插入一条内存屏障读指令强行从主存中读取（让高速缓存中的数据失效，重新从主内存加载数据），变量在被线程修改时会在写指令之后插入写屏障，让写入缓存的最新数据写回到主内存。</p><p><em>不能确保原子性</em>，是因为如果A线程和B线程同时读取到变量a值，A线程修改a后将值刷到主存、同时B线程也修改了a的值并刷到主存，这时候B线程就覆盖了A线程修改操作。</p><p><strong>Synchronized</strong>是通过<u>对线程加锁（独占锁）控制线程同步</u>，被Synchronized修饰的内存只允许一个线程访问；</p><h3 id="五、优秀资料"><a href="#五、优秀资料" class="headerlink" title="五、优秀资料"></a>五、优秀资料</h3><p><a href="https://www.cnblogs.com/xrq730/p/7048693.html" target="_blank" rel="noopener">《就是要你懂Java中volatile关键字实现原理》</a><br><a href="http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf" target="_blank" rel="noopener">《JSR133规范中文版》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Web Hook 钩子</title>
    <url>/post/a2f884a0.html</url>
    <content><![CDATA[<blockquote><p>WebHook 介绍 ~</p></blockquote><a id="more"></a><h3 id="一、什么是Web-Hook？"><a href="#一、什么是Web-Hook？" class="headerlink" title="一、什么是Web Hook？"></a><strong>一、什么是Web Hook？</strong></h3><p>Webhook是一个API概念，并且变得越来越流行。我们能用事件描述的事物越多，webhook的作用范围也就越大。Webhook作为一个轻量的事件处理应用，正变得越来越有用。简单来说就是一种反向API机制,类似于触发器一样。</p><h3 id="二、应用场景"><a href="#二、应用场景" class="headerlink" title="二、应用场景"></a>二、应用场景</h3><p>对于第三方平台验权、登陆等 没有前端界面做中转的场景，或者强安全要求的支付场景等，适合用 Webhooks 做数据主动推送。说白了就是在前端无从参与，或者因为前端安全问题不适合参与时，就是 Webhooks 的场景。很显然 Webhooks 也不是 Http 的替代品，不过的确是一种新的前后端交互方式。</p><p>如果客户端要长期监听某个任务的状态，按照正常的api调用的方式去做，那么必须不停得轮训服务器来获取当前状态；使用webhook则无需轮训，通过API 可以确定是否发生了更改，如果更改了只需要等待服务器推送信息过来，然后客户端更新就可以。</p><p>eg：git webhook其实也是这方面的应用；</p><h3 id="三、安全问题"><a href="#三、安全问题" class="headerlink" title="三、安全问题"></a>三、安全问题</h3><p>由于webhook会向公网上的hook url发送数据,这就意味着某些不好心的人可能会找到这个url,从而进行发送错误的数据,但是我们可以通过以下一些技术手段来解决这个问题:</p><ul><li>增加token机制</li><li>增加auth认证</li><li>只接收对应服务端domain或IP请求</li><li>数据签名</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>提升 Spring Boot 吞吐量神技！</title>
    <url>/post/65e82e4.html</url>
    <content><![CDATA[<blockquote><p>提升Spring Boot吞吐量神技 ~</p></blockquote><a id="more"></a><h4 id="一、异步执行"><a href="#一、异步执行" class="headerlink" title="一、异步执行"></a>一、异步执行</h4><h5 id="注解方式和Future类"><a href="#注解方式和Future类" class="headerlink" title="注解方式和Future类"></a>注解方式和Future类</h5><p>使用异步注解<code>@aysnc</code>、<code>启动类：添加@EnableAsync注解</code></p><p>JDK 8本身有一个非常好用的Future类——<code>CompletableFuture</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AskThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CompletableFuture&lt;Integer&gt; re = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> myRe = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            myRe = re.get() * re.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(myRe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;Integer&gt; future = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> AskThread(future)).start();</span><br><span class="line">        <span class="comment">//模拟长时间的计算过程</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//告知完成结果</span></span><br><span class="line">        future.complete(<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异步调用-Deferred"><a href="#异步调用-Deferred" class="headerlink" title="异步调用 Deferred"></a>异步调用 Deferred</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncDeferredController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LongTimeTask taskService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncDeferredController</span><span class="params">(LongTimeTask taskService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskService = taskService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/deferred"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">executeSlowTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(Thread.currentThread().getName() + <span class="string">"进入executeSlowTask方法"</span>);</span><br><span class="line">        DeferredResult&lt;String&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;&gt;();</span><br><span class="line">        <span class="comment">// 调用长时间执行任务</span></span><br><span class="line">        taskService.execute(deferredResult);</span><br><span class="line">        <span class="comment">// 当长时间任务中使用deferred.setResult("world");这个方法时，会从长时间任务中返回，继续controller里面的流程</span></span><br><span class="line">        logger.info(Thread.currentThread().getName() + <span class="string">"从executeSlowTask方法返回"</span>);</span><br><span class="line">        <span class="comment">// 超时的回调方法</span></span><br><span class="line">        deferredResult.onTimeout(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">		</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" onTimeout"</span>);</span><br><span class="line">				<span class="comment">// 返回超时信息</span></span><br><span class="line">				deferredResult.setErrorResult(<span class="string">"time out!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理完成的回调方法，无论是超时还是处理成功，都会进入这个回调方法</span></span><br><span class="line">        deferredResult.onCompletion(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">		</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" onCompletion"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> deferredResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异步调用-WebAsyncTask"><a href="#异步调用-WebAsyncTask" class="headerlink" title="异步调用 WebAsyncTask"></a>异步调用 WebAsyncTask</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> HelloService hello;</span><br><span class="line"> </span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 带超时时间的异步请求 通过WebAsyncTask自定义客户端超时间</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/world"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">worldController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		logger.info(Thread.currentThread().getName() + <span class="string">" 进入helloController方法"</span>);</span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 3s钟没返回，则认为超时</span></span><br><span class="line">		WebAsyncTask&lt;String&gt; webAsyncTask = <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">3000</span>, <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" 进入call方法"</span>);</span><br><span class="line">				String say = hello.sayHello();</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" 从helloService方法返回"</span>);</span><br><span class="line">				<span class="keyword">return</span> say;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		logger.info(Thread.currentThread().getName() + <span class="string">" 从helloController方法返回"</span>);</span><br><span class="line"> </span><br><span class="line">		webAsyncTask.onCompletion(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" 执行完毕"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"> </span><br><span class="line">		webAsyncTask.onTimeout(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" onTimeout"</span>);</span><br><span class="line">				<span class="comment">// 超时的时候，直接抛异常，让外层统一处理超时异常</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"调用超时"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="keyword">return</span> webAsyncTask;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 异步调用，异常处理，详细的处理流程见MyExceptionHandler类</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/exception"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">exceptionController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		logger.info(Thread.currentThread().getName() + <span class="string">" 进入helloController方法"</span>);</span><br><span class="line">		Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" 进入call方法"</span>);</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"调用超时!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		logger.info(Thread.currentThread().getName() + <span class="string">" 从helloController方法返回"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> WebAsyncTask&lt;&gt;(<span class="number">20000</span>, callable);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="异步调用-Callable"><a href="#异步调用-Callable" class="headerlink" title="异步调用 Callable"></a>异步调用 Callable</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HelloController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> HelloService hello;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/helloworld"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">helloWorldController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> hello.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 异步调用restful</span></span><br><span class="line"><span class="comment">	 * 当controller返回值是Callable的时候，springmvc就会启动一个线程将Callable交给TaskExecutor去处理</span></span><br><span class="line"><span class="comment">	 * 然后DispatcherServlet还有所有的spring拦截器都退出主线程，然后把response保持打开的状态</span></span><br><span class="line"><span class="comment">	 * 当Callable执行结束之后，springmvc就会重新启动分配一个request请求，然后DispatcherServlet就重新</span></span><br><span class="line"><span class="comment">	 * 调用和处理Callable异步执行的返回结果， 然后返回视图</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">helloController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		logger.info(Thread.currentThread().getName() + <span class="string">" 进入helloController方法"</span>);</span><br><span class="line">		Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line"> </span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" 进入call方法"</span>);</span><br><span class="line">				String say = hello.sayHello();</span><br><span class="line">				logger.info(Thread.currentThread().getName() + <span class="string">" 从helloService方法返回"</span>);</span><br><span class="line">				<span class="keyword">return</span> say;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		logger.info(Thread.currentThread().getName() + <span class="string">" 从helloController方法返回"</span>);</span><br><span class="line">		<span class="keyword">return</span> callable;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二、增加内嵌Tomcat的最大连接数"><a href="#二、增加内嵌Tomcat的最大连接数" class="headerlink" title="二、增加内嵌Tomcat的最大连接数"></a>二、增加内嵌Tomcat的最大连接数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConfigurableServletWebServerFactory <span class="title">webServerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TomcatServletWebServerFactory tomcatFactory = <span class="keyword">new</span> TomcatServletWebServerFactory();</span><br><span class="line">        tomcatFactory.addConnectorCustomizers(<span class="keyword">new</span> MyTomcatConnectorCustomizer());</span><br><span class="line">        tomcatFactory.setPort(<span class="number">8005</span>);</span><br><span class="line">        tomcatFactory.setContextPath(<span class="string">"/api-g"</span>);</span><br><span class="line">        <span class="keyword">return</span> tomcatFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyTomcatConnectorCustomizer</span> <span class="keyword">implements</span> <span class="title">TomcatConnectorCustomizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">            Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">            <span class="comment">//设置最大连接数               </span></span><br><span class="line">            protocol.setMaxConnections(<span class="number">20000</span>);</span><br><span class="line">            <span class="comment">//设置最大线程数               </span></span><br><span class="line">            protocol.setMaxThreads(<span class="number">2000</span>);</span><br><span class="line">            protocol.setConnectionTimeout(<span class="number">30000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三、使用-ComponentScan-定位扫包比-SpringBootApplication扫包更快"><a href="#三、使用-ComponentScan-定位扫包比-SpringBootApplication扫包更快" class="headerlink" title="三、使用@ComponentScan()定位扫包比@SpringBootApplication扫包更快"></a>三、使用@ComponentScan()定位扫包比@SpringBootApplication扫包更快</h4><h4 id="四、默认tomcat容器改为Undertow（Jboss下的服务器，Tomcat吞吐量5000，Undertow吞吐量8000）"><a href="#四、默认tomcat容器改为Undertow（Jboss下的服务器，Tomcat吞吐量5000，Undertow吞吐量8000）" class="headerlink" title="四、默认tomcat容器改为Undertow（Jboss下的服务器，Tomcat吞吐量5000，Undertow吞吐量8000）"></a>四、默认tomcat容器改为Undertow（Jboss下的服务器，Tomcat<a href="https://so.csdn.net/so/search?q=吞吐量&spm=1001.2101.3001.7020" target="_blank" rel="noopener">吞吐量</a>5000，Undertow吞吐量8000）</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="五、使用-BufferedWriter-进行缓冲"><a href="#五、使用-BufferedWriter-进行缓冲" class="headerlink" title="五、使用 BufferedWriter 进行缓冲"></a>五、使用 BufferedWriter 进行缓冲</h4><h4 id="六、异步调用可以使用AsyncHandlerInterceptor进行拦截"><a href="#六、异步调用可以使用AsyncHandlerInterceptor进行拦截" class="headerlink" title="六、异步调用可以使用AsyncHandlerInterceptor进行拦截"></a>六、异步调用可以使用AsyncHandlerInterceptor进行拦截</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title">AsyncHandlerInterceptor</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyAsyncHandlerInterceptor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">			ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//		HandlerMethod handlerMethod = (HandlerMethod) handler;</span></span><br><span class="line">		logger.info(Thread.currentThread().getName()+ <span class="string">"服务调用完成，返回结果给客户端"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">null</span> != ex)&#123;</span><br><span class="line">			System.out.println(<span class="string">"发生异常:"</span>+ex.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConcurrentHandlingStarted</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 拦截之后，重新写回数据，将原来的hello world换成如下字符串</span></span><br><span class="line">		String resp = <span class="string">"my name is chhliu!"</span>;</span><br><span class="line">		response.setContentLength(resp.length());</span><br><span class="line">		response.getOutputStream().write(resp.getBytes());</span><br><span class="line">		</span><br><span class="line">		logger.info(Thread.currentThread().getName() + <span class="string">" 进入afterConcurrentHandlingStarted方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>kafka指定时间段消费主题消息</title>
    <url>/post/17596c1b.html</url>
    <content><![CDATA[<blockquote><p>kafka指定时间段消费主题消息 ~</p></blockquote><a id="more"></a><h3 id="一、-Pom坐标"><a href="#一、-Pom坐标" class="headerlink" title="一、 Pom坐标"></a>一、 Pom坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.kafka<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-kafka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二、工具类"><a href="#二、工具类" class="headerlink" title="二、工具类"></a>二、工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.OffsetAndTimestamp;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.TopicPartition;</span><br><span class="line"><span class="keyword">import</span> org.jetbrains.annotations.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建消费者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KafkaConsumer&lt;String, String&gt; <span class="title">getConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, getServers());</span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"2000"</span>);</span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, <span class="string">"jias_test"</span>);</span><br><span class="line">        props.put(<span class="string">"auto.offset.reset"</span>, <span class="string">"earliest"</span>);</span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KafkaProducer&lt;String, String&gt; <span class="title">getKafkaProducer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, getServers());</span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"2000"</span>);</span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, <span class="string">"jias_test_producer_one"</span>);</span><br><span class="line">        props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据时间戳获取偏移量</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> partition 分区号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datetimeStr 消息时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">getOffsetByDateTime</span><span class="params">(KafkaConsumer consumer, String topic, <span class="keyword">int</span> partition, String datetimeStr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        <span class="keyword">long</span> timestamp = df.parse(datetimeStr).getTime();</span><br><span class="line">        Map&lt;TopicPartition, Long&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        TopicPartition topicPartition = <span class="keyword">new</span> TopicPartition(topic, partition);</span><br><span class="line">        map.put(topicPartition, timestamp);</span><br><span class="line">        Map&lt;TopicPartition, OffsetAndTimestamp&gt; offset = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            offset = consumer.offsetsForTimes(map, Duration.ofSeconds(<span class="number">10</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> offset.get(topicPartition).offset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消费某时间范围内的一批数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> producer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to_topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> partition 分区号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startTime 消费起始时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> endTime 消费结束时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">consumerOnTimeBatch</span><span class="params">(KafkaProducer&lt;String, String&gt; producer,</span></span></span><br><span class="line"><span class="function"><span class="params">        KafkaConsumer&lt;String, String&gt; consumer, String topic, String to_topic, <span class="keyword">int</span> partition, String startTime,</span></span></span><br><span class="line"><span class="function"><span class="params">        String endTime)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        TopicPartition topicPartition = <span class="keyword">new</span> TopicPartition(topic, partition);</span><br><span class="line">        <span class="comment">// 指定主题分区</span></span><br><span class="line">        consumer.assign(Arrays.asList(topicPartition));</span><br><span class="line">        <span class="keyword">long</span> startOffset = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> endOffset = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startOffset = getOffsetByDateTime(consumer, topic, partition, startTime);</span><br><span class="line">            endOffset = getOffsetByDateTime(consumer, topic, partition, endTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        consumer.seek(topicPartition, startOffset);</span><br><span class="line">        <span class="keyword">boolean</span> reachedEnd = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="keyword">if</span> (record.offset() &gt;= endOffset) &#123;</span><br><span class="line">                    reachedEnd = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count++;</span><br><span class="line">                log.info(<span class="string">"时间："</span> + <span class="keyword">new</span> Date(record.timestamp()) + <span class="string">",偏移量："</span> + record.offset() + <span class="string">",消息体："</span> + record.value());</span><br><span class="line">                <span class="comment">// writeFile(record.value(), "/Users/app.log");</span></span><br><span class="line">                <span class="comment">// try &#123;</span></span><br><span class="line">                <span class="comment">// Thread.sleep(20);</span></span><br><span class="line">                <span class="comment">// producer.send(new ProducerRecord&lt;&gt;(to_topic, record.value()));</span></span><br><span class="line">                <span class="comment">// &#125; catch (Exception e) &#123;</span></span><br><span class="line">                <span class="comment">// e.printStackTrace();</span></span><br><span class="line">                <span class="comment">// reachedEnd = true;</span></span><br><span class="line">                <span class="comment">// break;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (reachedEnd)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(String.format(<span class="string">"分区：%d:%d"</span>, partition, count));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"kafka broker 地址"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向文件追加内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 写入的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName 文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String content, String fileName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在文件夹目录下新建文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> hasFile = file.createNewFile();</span><br><span class="line">                <span class="keyword">if</span> (hasFile) &#123;</span><br><span class="line">                    log.info(<span class="string">"file not exists, create new file"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fos = <span class="keyword">new</span> FileOutputStream(file, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="comment">// 写入内容</span></span><br><span class="line">            osw.write(content);</span><br><span class="line">            <span class="comment">// 换行</span></span><br><span class="line">            osw.write(<span class="string">"\r\n"</span>);</span><br><span class="line">            log.info(<span class="string">"成功向文件 [&#123;&#125;] 写入内容：[&#123;&#125;]"</span>, fileName, content);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">"写入文件发生异常"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (osw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    osw.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                log.info(<span class="string">"关闭流异常"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = getConsumer();</span><br><span class="line">        KafkaProducer&lt;String, String&gt; producer = getKafkaProducer();</span><br><span class="line">        String topic = <span class="string">"主题"</span>;</span><br><span class="line">        String to_topic = <span class="string">""</span>;</span><br><span class="line">        String startTime = <span class="string">"开始时间"</span>;</span><br><span class="line">        String endTime = <span class="string">"结束时间"</span>;</span><br><span class="line">        <span class="comment">// 循环分区数  </span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            consumerOnTimeBatch(producer, consumer, topic, to_topic, i, startTime, endTime);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>慢接口场景优化方式总结</title>
    <url>/post/6bc54127.html</url>
    <content><![CDATA[<blockquote><p>项目中通常会有慢接口：不论多少，反正或多或少。尤其是我们依赖了其他被依赖程度极高的大数据服务、主数据服务、鉴权服务等，它们这些系统的接口性能直接影响了我们对外提供服务的感知度：毕竟我们才是前台 ~</p></blockquote><a id="more"></a><h1 id="之前的尝试"><a href="#之前的尝试" class="headerlink" title="之前的尝试"></a>之前的尝试</h1><p>之前我们已经在经历过的各种慢场景中尝试了解决方案，主要分成三种途径：</p><h2 id="优化本地代码"><a href="#优化本地代码" class="headerlink" title="优化本地代码"></a>优化本地代码</h2><p>接口太慢了，在不是外部原因的情况下我们通常第一步方案都是代码优化，然后才会考虑使用中间件。</p><p>优先考虑优化本地代码的原因是我们确实能力有限，谁都会写出不够好的代码，所以通常我们的代码都有一定程度的可优化空间。比如数据结构使用的不好，应该用LinkedList却用了ArrayList，比如使用了ArrayList导致了频繁扩容，比如创建了太多非必要临时对象导致GC太多，比如线程池配置不合适导致CPU负载太高，等等等；另外不直接考虑引入中间件的原因还有，使用中间件会使系统复杂性提高，需要编写更多的代码保证功能的使用，出了问题也比没有中间件更难排查。</p><p>但是本地代码优化后的改善通常很小。一个原因是就算代码再烂，现代高速CPU也会抹平和好代码的时间差异，那点毫秒级差异甚至微秒级差异对我们的优化目标实在贡献太少。还有一部分原因是受限于技术能力，就算定位了烂代码，也不一定能写出好代码。所以通常情况下，代码优化和代码美化一样只是我们的个人追求。</p><h2 id="使用缓存"><a href="#使用缓存" class="headerlink" title="使用缓存"></a>使用缓存</h2><p>毫无疑问，缓存是提升系统相应速度最有利的武器之一。关于它的好处这里不提了；仅说一句，缓存分为本地缓存（通过Java的数据结构记在堆内存里）和分布式缓存（一般就是Redis）。</p><p>缓存带来的坏处也是高频考点：数据的一致性。所以使用缓存需求权衡这个中间点：既不能存的太久严重影响一致性，也不能存的太短影响系统其他方面性能。所以哪些数据能缓存、缓存多久、缓存在哪、怎么缓存都是需要仔细考虑的。使用什么定时任务、使用几个定时任务也是关键一步。</p><h2 id="优化SQL"><a href="#优化SQL" class="headerlink" title="优化SQL"></a>优化SQL</h2><p>自己系统内部的接口慢，最大的可能是查询数据库引起的。所以优化表设计和SQL脚本也至关重要。</p><h1 id="最近的研究"><a href="#最近的研究" class="headerlink" title="最近的研究"></a>最近的研究</h1><p>经过上面提到的这些手段优化过以后，依然存在漏网之鱼：这些慢接口都是依赖第三方系统、而且无法设计（提前）缓存来改善。这样就意味着没有其他（或者现在没想到）手段来提升接口的速度了。</p><p>慢接口带来的问题主要有两个：一个当然是用户体验不好，另一个是公司的质量检测。</p><p>公司对慢接口的监控是依据URL请求响应间隔超过一定时间进行统计的。所以最近我分别考虑了以下技术：</p><ul><li>短轮询</li><li>长轮询</li><li>响应式</li><li>非阻塞异步</li><li>WebSocket</li><li>SSE</li><li>Servlet4</li></ul><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p>短轮询就是查一下，有数据就拿到，没数据就拿不到；过一会再尝试。</p><p>要使用短轮询，服务端需要使用缓存：前端请求的时候就去缓存拿，没拿到（或数据过期了）就返回；同时后台异步去取数据，可能很慢，啥时候取好了就放到缓存等着下一次轮询（期间可能已经轮询好几次了）。</p><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p>长轮询就是查一下，有数据就返回，没数据就不返回，在那等着：这样看起来似乎我们的接口基本都这样，可以给长轮询使用。不过真正意义的长轮询不是后端收到请求就去取数据，而是后端就算取了没取到，请求也不会结束，会一直等到后端有数据了或者请求超时了才返回，然后立即开始下一次请求。</p><p>很多人都以为长轮询是对短轮询的代替，有了长轮询就再也不需要短轮询了。其实它们各自有自己的应用场景，比如后端数据更新特别频繁，一秒更好几次。这个时候使用长轮询会导致连续不断请求，浏览器都可能卡死；相反使用短轮询，1秒或几秒查询一次，性能好数据延迟也不大。</p><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>响应式就是RxJava（Rx 是 C# 的），在Spring5中是WebFlux，据说性能比Vert.x差很多。响应式是基于NIO的，必须运行在netty或者Servlet3.1以上的容器，它们处理请求和返回响应的线程不是同一个。响应式一般不能提升响应速度，也就是浏览器拿到结果的时间不会下降；而是会提升服务端的吞吐量，也就是非相应式的时候（使用Spring MVC）服务器本来比如只能接受1万个请求，使用WebFlux可以无上限的接受（前提当然是不被其他条件约束，比如内存，比如线程数量）。</p><p>那使用WebFlux可以减少慢接口吗？在一定条件下可以。比如服务端接口实际处理业务需要等2秒（必须是IO型的，比如请求其他服务或者数据库、中间件等），机器有10个CPU，在Web MVC场景下这时候如果有10个客户端进行请求，则tomcat可以都创建连接并通过线程池调度，使得每个请求都在2秒左右结束。如果这时候有20个请求，虽然都能建立连接，但是只有10个能在2秒结束并返回，剩下的10个要继续执行2秒，总共4秒才返回。</p><p>但是使用WebFlux，这20个（哪怕2千2万）都是2秒左右返回。从这个角度讲，WebFlux是可以提升响应速度的，但是我们的接口慢并不是因为连接数多，相反连接数很难上两位数。</p><h2 id="非阻塞异步"><a href="#非阻塞异步" class="headerlink" title="非阻塞异步"></a>非阻塞异步</h2><p>如果不想额外引入WebFlux依赖，或者项目使用的Spring版本是5以下的，可以考虑使用Spring提供的异步工具：DeferredResult，或者Callable。但是这个和WebFlux原理不一样，这个是基于线程池的，和NIO模式的tomcat一样（就是上面提到的只能同时处理10个请求那种）；而WebFlux是基于selector的。所以他们能力完全不同。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>要用websocket需要后端也一起改造，因为mvc并不能提供websocket的连接，websocket的协议是ws的不是http。图模的后端项目ugmdp-api中定义了WebSocket的端点。</p><h2 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h2><p>sse是websocket的简化版。websocekt是全双工通信，sse是只能服务端给客户端发送。它比websocket好用的一点是普通mvc的端点就能使用，因为它连接的就是http端点。<strong>注意</strong>：浏览器有限制，对于长链接最多只能保持6个。</p><h2 id="Servlet4"><a href="#Servlet4" class="headerlink" title="Servlet4"></a>Servlet4</h2><p>Servlet4的一个主要功能也是服务器推送，但是它是给http/2用的。鉴于我们现在都在用http/1.1，这一方面我没有特别研究。</p><h1 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h1><p>通过上面这几种技术对比，我计划使用SSE来尝试改善接口性能并一定程度改善用户体验。</p><ul><li>响应式，或其他异步技术，并不能改变接口响应时间：它改善的不是客户端而是服务端性能</li><li>短轮询和WebSocket可以消除慢接口，但是要求系统进行比较大的改造；前端改动量也不小</li><li>SSE需要前后端都有改造，但是改动量都不大</li></ul><h1 id="SSE用法"><a href="#SSE用法" class="headerlink" title="SSE用法"></a>SSE用法</h1><p>Spring提供了（至少）两种方法来生成SSE流，下面分别来介绍。</p><h2 id="通过WebFlux提供SSE流"><a href="#通过WebFlux提供SSE流" class="headerlink" title="通过WebFlux提供SSE流"></a>通过WebFlux提供SSE流</h2><p>这个自行百度吧</p><h2 id="通过SseEmitter提供SSE流"><a href="#通过SseEmitter提供SSE流" class="headerlink" title="通过SseEmitter提供SSE流"></a>通过SseEmitter提供SSE流</h2><p>SseEmitter是Spring 4 提供的用来发送SSE流的工具，无需引入WebFlux。</p><h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><p>这段代码的意思是去请求一个方法，但是这个方法要10秒才能返回。为了让用户有点希望，每秒返回一个随机的进度，最多返回5次。10秒后把结果（字符串ok）返回给前端。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.MediaType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.method.annotation.SseEmitter;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CompletableFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/sse/mvc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessController</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(PerformanceController<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService bossPool = Executors.newCachedThreadPool();</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@GetMapping</span>(path = <span class="string">"/process"</span>, produces = MediaType.TEXT_EVENT_STREAM_VALUE)</span><br><span class="line">    <span class="function">SseEmitter <span class="title">getWords</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SseEmitter emitter = <span class="keyword">new</span> SseEmitter();</span><br><span class="line">        logger.info(<span class="string">"Emitter created: &#123;&#125;"</span>, emitter);</span><br><span class="line"> </span><br><span class="line">        CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">        &#125;).whenCompleteAsync((res, ex) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="keyword">null</span>) &#123;</span><br><span class="line">                WebResult&lt;String&gt; wr = <span class="keyword">new</span> WebResult&lt;&gt;();</span><br><span class="line">                wr.setData(res);</span><br><span class="line">                SseEmitter.SseEventBuilder data = SseEmitter.event().data(wr);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emitter.send(data);</span><br><span class="line">                    emitter.complete();</span><br><span class="line">                    logger.info(<span class="string">"Emitter completed: &#123;&#125;"</span>, emitter);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    emitter.completeWithError(e);</span><br><span class="line">                    logger.warn(<span class="string">"Emitter failed: &#123;&#125; &#123;&#125;"</span>, emitter, e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        AtomicInteger base = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">20</span>;</span><br><span class="line">        bossPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (base.get() &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                WebResult&lt;String&gt; wr = <span class="keyword">new</span> WebResult&lt;&gt;();</span><br><span class="line">                wr.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">                wr.setMsg(<span class="string">""</span> + (r.nextInt(step) + base.get()) + <span class="string">"%"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emitter.send(SseEmitter.event().data(wr));</span><br><span class="line">                    base.addAndGet(step);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    emitter.complete();</span><br><span class="line">                    logger.info(<span class="string">"Emitter completed period: &#123;&#125;"</span>, emitter);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="前端消费SSE流"><a href="#前端消费SSE流" class="headerlink" title="前端消费SSE流"></a>前端消费SSE流</h4><p>前端不断受到后端的消息，如果success返回true了，就关闭连接，否则就显示进度：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;common-container margin=<span class="string">"0 184px"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;wxd&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button v-on:click="reverseMessage"&gt;获取消息&lt;/</span>button&gt;</span><br><span class="line">    &lt;div style=<span class="string">"background: lightblue"</span>&gt;</span><br><span class="line">      &lt;ul&gt;&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">      &lt;loading v-if="true" /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>common-container&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  name: 'OneColForm',</span></span><br><span class="line"><span class="regexp">  data() &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;&#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  components: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  mounted() &#123;&#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;</span></span><br><span class="line"><span class="regexp">    async reverseMessage() &#123;</span></span><br><span class="line"><span class="regexp">      if (window.EventSource == null) &#123;</span></span><br><span class="line"><span class="regexp">        alert('The browser does not support Server-Sent Events')</span></span><br><span class="line"><span class="regexp">      &#125; else &#123;</span></span><br><span class="line"><span class="regexp">        var eventSource = new EventSource(</span></span><br><span class="line"><span class="regexp">          'http:/</span><span class="regexp">/localhost:8080/</span>sse/mvc/process<span class="string">'</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">        var eventList = document.querySelector('</span>ul<span class="string">')</span></span><br><span class="line"><span class="string">        eventSource.onopen = function () &#123;</span></span><br><span class="line"><span class="string">          console.log('</span>connection is established<span class="string">')</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        eventSource.onerror = function (error) &#123;</span></span><br><span class="line"><span class="string">          console.log(</span></span><br><span class="line"><span class="string">            '</span>connection state: <span class="string">' + eventSource.readyState + '</span>, <span class="attr">error</span>: <span class="string">' + event</span></span><br><span class="line"><span class="string">          )</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        eventSource.onmessage = function (event) &#123;</span></span><br><span class="line"><span class="string">          var obj = JSON.parse(event.data)</span></span><br><span class="line"><span class="string">          console.log('</span>id: <span class="string">' + event.lastEventId + '</span>, <span class="attr">data</span>: <span class="string">' + event.data)</span></span><br><span class="line"><span class="string">          this.message = event.data</span></span><br><span class="line"><span class="string">          var newElement = document.createElement('</span>li<span class="string">')</span></span><br><span class="line"><span class="string">          var msg = obj.success ? obj.data : obj.msg</span></span><br><span class="line"><span class="string">          newElement.textContent = new Date() + '</span>收到消息<span class="string">' + msg</span></span><br><span class="line"><span class="string">          eventList.appendChild(newElement)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">          if (!!obj.success) &#123;</span></span><br><span class="line"><span class="string">            eventSource.close()</span></span><br><span class="line"><span class="string">            console.log('</span>connection is closed<span class="string">')</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&lt;style&gt;&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/20220627142227.png" border="1"><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MultiThread</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka配置auto.offset.reset时earliest和latest的区别</title>
    <url>/post/9f1e82e9.html</url>
    <content><![CDATA[<blockquote><p>kafka配置auto.offset.reset时earliest和latest的区别 ~</p></blockquote><a id="more"></a><h3 id="一、earliest"><a href="#一、earliest" class="headerlink" title="一、earliest"></a>一、earliest</h3><p>创建一个topic名称为 <strong>test1</strong> ,设定这个topic初始有三个分区</p><p>生成一个消费者组 g001 ,订阅 <strong>test1</strong> ,参数使用 earliest</p><p>如果 g001 消费者组 在 test1的其中一个分区下<u>没有提交 偏移量offset 时</u>,在消费该分区数据的时候会 <strong>从头 全部读取</strong></p><p>如果 g001 消费者组 在 test1 的其中一个分区下<u>有提交 偏移量offset 时</u>,在消费该分区数据的时候会<strong>从 偏移量offset处开始读取</strong></p><h3 id="二、latest"><a href="#二、latest" class="headerlink" title="二、latest"></a>二、latest</h3><p>创建一个topic名称为 test2 ,设定这个topic初始有三个分区</p><p>生成一个消费者组 g002 ,订阅 test2 ,参数使用 latest</p><p>如果 g002 消费者组 在 test2 的其中一个分区下<u>没有提交 偏移量offset 时</u>,在消费该分区数据的时不会 从头 全部读取，而<strong>是读取 新产生的数据</strong>。</p><p>如果 g002 消费者组 在 test2 的其中一个分区下<u>有提交 偏移量offset 时</u>,在消费该分区数据的时候会<strong>从 偏移量offset 处开始读取。</strong></p><h3 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h3><p>如果想要测试,可以设置参数 enable.auto.commit 为 fales (当设置为fales时当前消费者组将不再自动提交偏移量offset,默认是true)</p><p>创建一个topic名称为 test3 ,设定这个topic初始有三个分区,假设有初始数据10条</p><p>生成一个新的消费者组 g003 ,订阅 test3 ,参数使用 earliest 设置参数 enable.auto.commit 为 fales</p><p>消费者组 g003 不管重新启动多少次,依旧消费这10条数据,因为 g003 还没有提交过关于 test3 的 偏移量offset</p><p>当消费者组 g003 提交了一次关于 test3 的 偏移量offset 之后(在这我们假设提交之后 偏移量offset 为11) , 有一个生产者向 test3 新提交了5条数据</p><p>这时,不管重启多少次 g003 ,也只会消费这新的5条数据</p><p>创建一个topic名称为 test4 ,设定这个topic初始有三个分区,假设有初始数据10条</p><p>生成一个新的消费者组 g004 ,订阅 test4 ,参数使用 latest 设置参数 enable.auto.commit 为 fales</p><p>消费者组 g004 不管重新启动多少次,都不会消费到这10条数据,因为 g004 还没有提交过关于 test4 的 偏移量offset 所以 latest 会让消费者组读取新产生的数据</p><p>当消费者组 g004 提交了一次关于 test4 的 偏移量offset 之后(在这我们假设提交之后 偏移量offset 为11) , 有一个生产者向 test4 新提交了5条数据</p><p>这时,不管重启多少次 g004 ,也都会一直消费这新的5条数据</p><h3 id="四、结论"><a href="#四、结论" class="headerlink" title="四、结论"></a>四、结论</h3><p><strong>earliest 和 latest 在有 偏移量offset 时,效果是一样的,都会从 偏移量offset 处继续消费;当没有 偏移量offset 时, ealiest 从头消费, latest 消费新产生的数据</strong>。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>大数据中间件生态系列</title>
    <url>/post/e6be6b16.html</url>
    <content><![CDATA[<blockquote><p>大数据中间件生态系列 ~</p></blockquote><a id="more"></a><blockquote class="pullquote mindmap mindmap-lg"><ul><li>大数据框架<ul><li>Hadoop<ul><li>一个分布式并行计算框架</li><li>核心设计思想是：MapReduce和HDFS</li><li>MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。概念”Map（映射）”和”Reduce（化简）”</li><li>Map(映射)和reduce(化简)是分开处理的，map是将一个任务分解为多个任务执行，reduce是将多个任务汇总起来得到想要的结果。把一个list拆解为多个放到线程池中启动多个线程计算list中值，然后把多个任务返回的结果合并为一个总的结果其实就是一个简单的MapReduce的应用</li></ul></li><li>日志收集框架<ul><li>Flume</li><li>ElasticSearch</li><li>Logstash</li><li>Kibana</li></ul></li><li>分布式文件存储系统<ul><li>Hadoop HDFS<ul><li>分布式文件系统，负责分布式文件存储</li></ul></li><li>KFS</li><li>GFS<ul><li>支持结构化、半结构和非结构化数据的存储，并通过增加机器进行横向扩展</li></ul></li></ul></li><li>数据库系统<ul><li>Hive</li><li>Mongodb</li><li>TIDB<ul><li><a href="https://zhuanlan.zhihu.com/p/409413038" target="_blank" rel="noopener">TiDB</a></li><li>TiDB 是 PingCAP 公司基于 Google Spanner / F1 论文实现的开源分布式 NewSQL 数据库</li><li>SQL支持 （TiDB 是 MySQL 兼容的）</li><li>水平线性弹性扩展</li><li>分布式事务</li><li>故障自恢复的高可用</li><li>跨数据中心数据强一致性保证</li></ul></li><li>PreSto<ul><li>Facebook开源的，完全基于内存的并⾏计算，分布式SQL交互式查询引擎</li><li>一种Massively parallel processing (MPP)架构，多个节点管道式执⾏</li><li>⽀持任意数据源（通过扩展式Connector组件）</li><li>数据规模GB~PB级</li></ul></li><li>HBase<ul><li>列式数据库，非关系型分布式数据库，支持随机读写和实时应用,HDFS是做顺序读写的，但在实际应用中很多需要随机读写，就由HBase完成</li><li><a href="https://blog.csdn.net/m0_55868614/article/details/121147275" target="_blank" rel="noopener">Hive与HBase之间的区别和联系</a></li></ul></li></ul></li><li>分布式计算框架：<ul><li>Hadoop MapReduce<ul><li>分布式并行编程框架,磁盘计算框架,离线计算框架</li><li>主要适用于大批量的集群任务，由于是批量执行，故时效性偏低</li></ul></li><li>Storm<ul><li>流式计算框架</li></ul></li><li>Spark<ul><li>是专为大规模数据处理而设计的快速通用的计算引擎，其是基于内存的计算框架</li><li>Spark是基于数据片集合（RDD）进行小批量处理的</li><li>只能支持秒级计算</li></ul></li><li>Flink（主流）<ul><li>一个面向数据流处理和批量数据处理的可分布式的开源计算框架</li><li>Flink基于每个事件一行一行地流式处理，是真正的流式计算</li><li>基于同一个Flink流式执行模型，能够支持流处理和批处理两种应用类型</li><li>支持毫秒级计算</li></ul></li><li><a href="https://www.cnblogs.com/eetv/p/13584557.html" target="_blank" rel="noopener">分布式计算框架框架对比</a></li></ul></li><li>查询分析框架<ul><li>Hive<ul><li>是数据仓库，是架构在MapReduce之上，SQL会被转化为一堆的MapReduce作业再去执行</li></ul></li><li>Pig<ul><li>Pig是一个Apache项目，为文本处理提供高级编程语言，可以将文本处理命令转换成Hadoop的MapReduce作业</li></ul></li><li>Phoenix<ul><li>Phoenix是构建在HBase上的一个SQL层，能让我们用标椎的JDBC APIs而不是HBase客户端APIs来创建表，插入数据和对HBase数据进程查询</li><li>Phoenix完全使用java编写，作为HBase内嵌的JDBC驱动，Phoenix查询引擎会将SQL查询转换为一个或多个HBase扫描（Scan），并编排执行以生成标椎的JDBC结果集；</li><li>直接使用HBase API协同处理器自定义过滤器，对于简单查询来说，其性能量级是毫秒，对于百万级的行数来说，其性能量级是秒；</li></ul></li></ul></li><li>数据迁移工具<ul><li>Sqoop<ul><li>Sqoop是针对关系型数据库（RDBMS）与Hadoop之间进行数据传输的工具，数据传输的过程大部分是自动的，通过MapReduce过程来实现，只需要依赖数据库的Schema信息。Sqoop所执行的操作是并行的，数据传输性能高，具备较好的容错性，并且能够自动转换数据类型。</li></ul></li><li>Canal<ul><li>Canal 模拟 MySQL的交互协议，伪装自己为Slave，向Master发送dump 协议；</li><li>Master收到dump请求，开始推送 binary log 给Slave(即Canal)；</li><li>Canal解析binary log，获得Mysql的更新信息。</li></ul></li></ul></li><li>任务调度框架<ul><li>Azkaban<ul><li>Azkaban是由Linkedin开源的一个批量工作流任务调度器。用于在一个工作流内以一个特定的顺序运行一组工作和流程。Azkaban定义了一种KV文件格式来建立任务之间的依赖关系，并提供一个易于使用的web用户界面维护和跟踪你的工作流。</li><li>Oozie</li><li>Apache Oozie，其配置工作流的过程是编写大量的XML配置，而且代码复杂度比较高，不易于二次开发。</li><li>Oozie相比azkaban是一个重量级的任务调度系统，功能全面，但配置使用也更复杂。如果可以不在意某些功能的缺失，轻量级调度器azkaban是很不错的候选对象。</li></ul></li><li>DolphinScheduler</li><li><a href="https://blog.csdn.net/zhanglong_4444/article/details/114017156" target="_blank" rel="noopener">任务调度框架对比</a></li></ul></li><li>集群管理<ul><li>集群部署和监控<ul><li>Ambari<ul><li>是 Apache 软件基金会的一个顶级项目,就是创建、管理、监视 Hadoop 的集群,为了让 Hadoop 以及相关的大数据软件更容易使用的一个工具。</li></ul></li><li>Cloudera Manager</li></ul></li><li>集群资源管理器<ul><li>Hadoop YARN<ul><li>Yarn 是一个资源调度平台，负责为运算程序提供服务器运算资源，相当于一个分布式的操作系统平台</li></ul></li><li>Tez<ul><li>负责DAG计算，把很多MapReduce作业进行分析优化，构建成一个有向无环图，可以保证最好的处理效率，分清有些先做有些后做有些不要重复做</li></ul></li></ul></li><li>分布式协调服务<ul><li>Zookeeper</li></ul></li></ul></li><li>时序数据库<ul><li>InfluxDB</li><li>TDengine</li><li>OpenTSDB</li></ul></li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>数据仓库</title>
    <url>/post/ec060e02.html</url>
    <content><![CDATA[<blockquote><p>大数据-数据仓库 ~</p></blockquote><a id="more"></a><h3 id="一、数据仓库架构"><a href="#一、数据仓库架构" class="headerlink" title="一、数据仓库架构"></a>一、数据仓库架构</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115622312.png" alt=""></p><h3 id="二、数据仓库实例"><a href="#二、数据仓库实例" class="headerlink" title="二、数据仓库实例"></a>二、<strong>数据仓库实例</strong></h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115656360.png" alt=""></p><h3 id="三、大数据技术栈"><a href="#三、大数据技术栈" class="headerlink" title="三、大数据技术栈"></a>三、<strong>大数据技术栈</strong></h3><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115814844.png" style="zoom:33%"> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115829295.png" style="zoom:33%"> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115840903.png" style="zoom:33%"> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115915722.png" style="zoom:33%"> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115933393.png" style="zoom:33%"> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115944567.png" style="zoom:33%"> <img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115951486.png" style="zoom:33%"><h3 id="四、大数据架构演变"><a href="#四、大数据架构演变" class="headerlink" title="四、大数据架构演变"></a>四、<strong>大数据架构</strong>演变</h3><h4 id="传统离线架构（离线）"><a href="#传统离线架构（离线）" class="headerlink" title="传统离线架构（离线）"></a>传统离线架构（离线）</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312115515623.png" alt=""></p><p>缺点：不能处理实时数据，有延迟。</p><h4 id="传统实时Lambda架构（离线-实时链路）"><a href="#传统实时Lambda架构（离线-实时链路）" class="headerlink" title="传统实时Lambda架构（离线+实时链路）"></a>传统实时Lambda架构（离线+实时链路）</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312120934952.png" alt=""></p><p>缺点：实时链路烟囱式开发，数据不能被复用。</p><h4 id="Lambda架构（离线数仓-实时数仓）"><a href="#Lambda架构（离线数仓-实时数仓）" class="headerlink" title="Lambda架构（离线数仓+实时数仓）"></a>Lambda架构（离线数仓+实时数仓）</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312122121491.png" alt=""></p><p>缺点：</p><ol><li>同样需求需要开发多套一样的代码；</li><li>集群资源使用多；</li><li>计算和离线计算结果不一致；</li><li>批量计算 T+1 可能计算不完；</li><li>服务器存储大；</li></ol><h4 id="Kappa架构（纯实时数仓）"><a href="#Kappa架构（纯实时数仓）" class="headerlink" title="Kappa架构（纯实时数仓）"></a>Kappa架构（纯实时数仓）</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312123548987.png" alt=""></p><p>缺点：</p><ol><li>kafka无法支撑海量数据库存储，不支持sql查询；</li><li>kafka不支持高效的OLAP（不支持SQL查询）；</li><li>无法复用数据血缘管理体系；</li><li>kafka不支持更新，只支持追加；</li></ol><h4 id="架构选择"><a href="#架构选择" class="headerlink" title="架构选择"></a>架构选择</h4><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312125650029.png" style="zoom:25%"><p>大部分公司采用Lambda架构，互联网公司实时业务多的采用混合架构。绝大多数公司采用kappa架构，关键核心业务使用离线全量计算方式</p><h3 id="五、实时数仓发展趋势"><a href="#五、实时数仓发展趋势" class="headerlink" title="五、实时数仓发展趋势"></a>五、实时数仓发展趋势</h3><h4 id="批流一体"><a href="#批流一体" class="headerlink" title="批流一体"></a>批流一体</h4><p>既能处理批数据，也可以处理实时流数据。</p><h4 id="湖仓一体"><a href="#湖仓一体" class="headerlink" title="湖仓一体"></a>湖仓一体</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312131536980.png" alt=""></p><p>可以用Hudi 代替 lacBerg。</p><p>优点：</p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312132039579.png" style="zoom:33%"><p>缺点：</p><ol><li>数据湖，数据存储速度没有kafka快；</li><li>hudi和lacBerg如何解决存储速度慢的问题？针对写，采用行式存储，针对读，采用列式存储；</li></ol><h3 id="六、互联网数仓实践"><a href="#六、互联网数仓实践" class="headerlink" title="六、互联网数仓实践"></a>六、互联网数仓实践</h3><h4 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312132421394.png" alt=""></p><h4 id="顺丰"><a href="#顺丰" class="headerlink" title="顺丰"></a>顺丰</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312132750323.png" alt=""></p><h4 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312133529551.png" alt=""></p><h4 id="滴滴"><a href="#滴滴" class="headerlink" title="滴滴"></a>滴滴</h4><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230312133348139.png" alt=""></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>DWH</category>
      </categories>
      <tags>
        <tag>DWH</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisson缓存</title>
    <url>/post/390aefa8.html</url>
    <content><![CDATA[<blockquote><p>Redisson是 redis 官方推荐的一款应用在分布环境中的 redis 客户端 ~</p></blockquote><a id="more"></a><h3 id="一、Redisson简介"><a href="#一、Redisson简介" class="headerlink" title="一、Redisson简介"></a>一、Redisson简介</h3><p>Redisson是 redis 官方推荐的一款应用在分布环境中的 redis 客户端，Redisson 在Java工具包中接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类比如：分布式锁、分布式远程服务、分布式调度任务服务等，具有更丰富的数据结构。</p><h3 id="二、Springboot-整合-Redisson"><a href="#二、Springboot-整合-Redisson" class="headerlink" title="二、Springboot 整合 Redisson"></a>二、Springboot 整合 Redisson</h3><h4 id="1、引入包"><a href="#1、引入包" class="headerlink" title="1、引入包"></a>1、引入包</h4><p>Redisson 提供了 Springboot 版本的starter</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.11.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、redisson-yml-配置"><a href="#2、redisson-yml-配置" class="headerlink" title="2、redisson.yml 配置"></a>2、redisson.yml 配置</h4><p>resources 目录下创建 redisson 配置文件 redisson.yml，也可以添加在application.yml，看个人喜好。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="string">"singleServerConfig"</span><span class="string">:&#123;</span></span><br><span class="line">    <span class="string">"idleConnectionTimeout"</span><span class="string">:10000,</span></span><br><span class="line">    <span class="string">"pingTimeout"</span><span class="string">:1000,</span></span><br><span class="line">    <span class="string">"connectTimeout"</span><span class="string">:10000,</span></span><br><span class="line">    <span class="string">"timeout"</span><span class="string">:3000,</span></span><br><span class="line">    <span class="string">"retryAttempts"</span><span class="string">:3,</span></span><br><span class="line">    <span class="string">"retryInterval"</span><span class="string">:1500,</span></span><br><span class="line">    <span class="string">"password"</span><span class="string">:"123456",</span></span><br><span class="line">    <span class="string">"subscriptionsPerConnection"</span><span class="string">:5,</span></span><br><span class="line">    <span class="string">"clientName"</span><span class="string">:null,</span></span><br><span class="line">    <span class="attr">"address":</span> <span class="string">"redis://127.0.0.1:6379"</span><span class="string">,</span></span><br><span class="line">    <span class="string">"subscriptionConnectionMinimumIdleSize"</span><span class="string">:1,</span></span><br><span class="line">    <span class="string">"subscriptionConnectionPoolSize"</span><span class="string">:50,</span></span><br><span class="line">    <span class="string">"connectionMinimumIdleSize"</span><span class="string">:32,</span></span><br><span class="line">    <span class="string">"connectionPoolSize"</span><span class="string">:64,</span></span><br><span class="line">    <span class="string">"database"</span><span class="string">:14</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">"threads"</span><span class="string">:0,</span></span><br><span class="line">  <span class="string">"nettyThreads"</span><span class="string">:0,</span></span><br><span class="line">  <span class="string">"codec"</span><span class="string">:&#123;</span></span><br><span class="line">    <span class="string">"class"</span><span class="string">:"org.redisson.codec.JsonJacksonCodec"</span></span><br><span class="line">  <span class="string">&#125;,</span></span><br><span class="line">  <span class="string">"transportMode"</span><span class="string">:"NIO"</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3、application-yml配置"><a href="#3、application-yml配置" class="headerlink" title="3、application.yml配置"></a>3、application.yml配置</h4><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">redisson:</span></span><br><span class="line">      <span class="attr">config:</span> <span class="string">"classpath:redisson.yml"</span></span><br></pre></td></tr></table></figure><h4 id="4、使用RedissonClient"><a href="#4、使用RedissonClient" class="headerlink" title="4、使用RedissonClient"></a>4、使用RedissonClient</h4><p>创建并注入 RedissonClient 实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Redisson.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用@Autowired注解引用即可调用 api</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>                                 </span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br></pre></td></tr></table></figure><h3 id="三、分布式锁"><a href="#三、分布式锁" class="headerlink" title="三、分布式锁"></a>三、分布式锁</h3><p>Redisson提供了多种类型的锁，比如：可重入锁、公平锁、联锁、红锁、读写锁等，同时Redisson还提供了一种监控锁叫 “看门狗” 的机制，为了解决因Redisson 宕机导致死锁 和 由于业务执行时长超出锁有效期的bug，它通过不断延长锁的有效期处理此类问题。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Redisson 实现分布式锁的原理比较好理解，主要用到的命令还是setNx 和 expire，只不过Redisson 客户端是向 redis 发送一个lua脚本，这个脚本可以理解成数据库的存储过程，它是一些逻辑的合集，同在一个事务中，可以保证这段复杂业务逻辑执行的原子性。</p><p>加锁成功后会将 key 和锁对应的过期时间、锁次数等数据，放入到全局变量lockContentMap中。</p><p>看下边加锁核心类，RedisDistributionLockPlus 类实例化时会初始化一个ScheduleExecutor任务池，起一个叫Lock-Renew-Task 的定时任务，而这个任务执行的 ScheduleTask 工作就是从lockContentMap中查找快要过期的key，给key增加expire过期时间，以此达到给key续期的效果，也就是所谓的看门狗。</p><p>默认加锁的时间是30秒，过10秒检查一次，一旦加锁的业务没有执行完，就会进行一次续期，把锁的过期时间再次重置成30秒。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisDistributionLockPlus</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁超时时间，单位毫秒， 即：加锁时间内执行完操作，如果未完成会有并发现象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DEFAULT_LOCK_TIMEOUT = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIME_SECONDS_FIVE = <span class="number">5</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每个key的过期时间 &#123;<span class="doctag">@link</span> LockContent&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, LockContent&gt; lockContentMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">512</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * redis执行成功的返回</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long EXEC_SUCCESS = <span class="number">1L</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取锁lua脚本， k1：获锁key, k2：续约耗时key, arg1:requestId，arg2：超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SCRIPT = <span class="string">"if redis.call('exists', KEYS[2]) == 1 then ARGV[2] = math.floor(redis.call('get', KEYS[2]) + 10) end "</span> +</span><br><span class="line">        <span class="string">"if redis.call('exists', KEYS[1]) == 0 then "</span> +</span><br><span class="line">           <span class="string">"local t = redis.call('set', KEYS[1], ARGV[1], 'EX', ARGV[2]) "</span> +</span><br><span class="line">           <span class="string">"for k, v in pairs(t) do "</span> +</span><br><span class="line">             <span class="string">"if v == 'OK' then return tonumber(ARGV[2]) end "</span> +</span><br><span class="line">           <span class="string">"end "</span> +</span><br><span class="line">        <span class="string">"return 0 end"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁lua脚本, k1：获锁key, k2：续约耗时key, arg1:requestId，arg2：业务耗时 arg3: 业务开始设置的timeout</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String UNLOCK_SCRIPT = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then "</span> +</span><br><span class="line">        <span class="string">"local ctime = tonumber(ARGV[2]) "</span> +</span><br><span class="line">        <span class="string">"local biz_timeout = tonumber(ARGV[3]) "</span> +</span><br><span class="line">        <span class="string">"if ctime &gt; 0 then  "</span> +</span><br><span class="line">           <span class="string">"if redis.call('exists', KEYS[2]) == 1 then "</span> +</span><br><span class="line">               <span class="string">"local avg_time = redis.call('get', KEYS[2]) "</span> +</span><br><span class="line">               <span class="string">"avg_time = (tonumber(avg_time) * 8 + ctime * 2)/10 "</span> +</span><br><span class="line">               <span class="string">"if avg_time &gt;= biz_timeout - 5 then redis.call('set', KEYS[2], avg_time, 'EX', 24*60*60) "</span> +</span><br><span class="line">               <span class="string">"else redis.call('del', KEYS[2]) end "</span> +</span><br><span class="line">           <span class="string">"elseif ctime &gt; biz_timeout -5 then redis.call('set', KEYS[2], ARGV[2], 'EX', 24*60*60) end "</span> +</span><br><span class="line">        <span class="string">"end "</span> +</span><br><span class="line">        <span class="string">"return redis.call('del', KEYS[1]) "</span> +</span><br><span class="line">        <span class="string">"else return 0 end"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 续约lua脚本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RENEW_SCRIPT = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('expire', KEYS[1], ARGV[2]) else return 0 end"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RedisDistributionLockPlus</span><span class="params">(StringRedisTemplate redisTemplate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    ScheduleTask task = <span class="keyword">new</span> ScheduleTask(<span class="keyword">this</span>, lockContentMap);</span><br><span class="line">    <span class="comment">// 启动定时任务</span></span><br><span class="line">    ScheduleExecutor.schedule(task, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleExecutor</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">(ScheduleTask task, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> delay = unit.toMillis(initialDelay);</span><br><span class="line">        <span class="keyword">long</span> period_ = unit.toMillis(period);</span><br><span class="line">        <span class="comment">// 定时执行</span></span><br><span class="line">        <span class="keyword">new</span> Timer(<span class="string">"Lock-Renew-Task"</span>).schedule(task, delay, period_);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisDistributionLockPlus redisDistributionLock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, LockContent&gt; lockContentMap;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleTask</span><span class="params">(RedisDistributionLockPlus redisDistributionLock, Map&lt;String, LockContent&gt; lockContentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisDistributionLock = redisDistributionLock;</span><br><span class="line">        <span class="keyword">this</span>.lockContentMap = lockContentMap;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lockContentMap.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Map.Entry&lt;String, LockContent&gt;&gt; entries = lockContentMap.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, LockContent&gt; entry : entries) &#123;</span><br><span class="line">            String lockKey = entry.getKey();</span><br><span class="line">            LockContent lockContent = entry.getValue();</span><br><span class="line">            <span class="keyword">long</span> expireTime = lockContent.getExpireTime();</span><br><span class="line">            <span class="comment">// 减少线程池中任务数量</span></span><br><span class="line">            <span class="keyword">if</span> ((expireTime - System.currentTimeMillis())/ <span class="number">1000</span> &lt; TIME_SECONDS_FIVE) &#123;</span><br><span class="line">                <span class="comment">//线程池异步续约</span></span><br><span class="line">                ThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> renew = redisDistributionLock.renew(lockKey, lockContent);</span><br><span class="line">                    <span class="keyword">if</span> (renew) &#123;</span><br><span class="line">                        <span class="keyword">long</span> expireTimeNew = lockContent.getStartTime() + (expireTime - lockContent.getStartTime()) * <span class="number">2</span> - TIME_SECONDS_FIVE * <span class="number">1000</span>;</span><br><span class="line">                        lockContent.setExpireTime(expireTimeNew);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 续约失败，说明已经执行完 OR redis 出现问题</span></span><br><span class="line">                        lockContentMap.remove(lockKey);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加锁</span></span><br><span class="line"><span class="comment"> * 取到锁加锁，取不到锁一直等待知道获得锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestId 全局唯一</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expire   锁过期时间, 单位秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String lockKey, String requestId, <span class="keyword">long</span> expire)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"开始执行加锁, lockKey =&#123;&#125;, requestId=&#123;&#125;"</span>, lockKey, requestId);</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="comment">// 判断是否已经有线程持有锁，减少redis的压力</span></span><br><span class="line">        LockContent lockContentOld = lockContentMap.get(lockKey);</span><br><span class="line">        <span class="keyword">boolean</span> unLocked = <span class="keyword">null</span> == lockContentOld;</span><br><span class="line">        <span class="comment">// 如果没有被锁，就获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (unLocked) &#123;</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 计算超时时间</span></span><br><span class="line">            <span class="keyword">long</span> bizExpire = expire == <span class="number">0L</span> ? DEFAULT_LOCK_TIMEOUT : expire;</span><br><span class="line">            String lockKeyRenew = lockKey + <span class="string">"_renew"</span>;</span><br><span class="line"> </span><br><span class="line">            RedisScript&lt;Long&gt; script = RedisScript.of(LOCK_SCRIPT, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            keys.add(lockKey);</span><br><span class="line">            keys.add(lockKeyRenew);</span><br><span class="line">            Long lockExpire = redisTemplate.execute(script, keys, requestId, Long.toString(bizExpire));</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != lockExpire &amp;&amp; lockExpire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 将锁放入map</span></span><br><span class="line">                LockContent lockContent = <span class="keyword">new</span> LockContent();</span><br><span class="line">                lockContent.setStartTime(startTime);</span><br><span class="line">                lockContent.setLockExpire(lockExpire);</span><br><span class="line">                lockContent.setExpireTime(startTime + lockExpire * <span class="number">1000</span>);</span><br><span class="line">                lockContent.setRequestId(requestId);</span><br><span class="line">                lockContent.setThread(Thread.currentThread());</span><br><span class="line">                lockContent.setBizExpire(bizExpire);</span><br><span class="line">                lockContent.setLockCount(<span class="number">1</span>);</span><br><span class="line">                lockContentMap.put(lockKey, lockContent);</span><br><span class="line">                log.info(<span class="string">"加锁成功, lockKey =&#123;&#125;, requestId=&#123;&#125;"</span>, lockKey, requestId);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重复获取锁，在线程池中由于线程复用，线程相等并不能确定是该线程的锁</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockContentOld.getThread()</span><br><span class="line">                  &amp;&amp; requestId.equals(lockContentOld.getRequestId()))&#123;</span><br><span class="line">            <span class="comment">// 计数 +1</span></span><br><span class="line">            lockContentOld.setLockCount(lockContentOld.getLockCount()+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 如果被锁或获取锁失败，则等待100毫秒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// 这里用lombok 有问题</span></span><br><span class="line">            log.error(<span class="string">"获取redis 锁失败, lockKey =&#123;&#125;, requestId=&#123;&#125;"</span>, lockKey, requestId, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解锁</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockValue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unlock</span><span class="params">(String lockKey, String lockValue)</span> </span>&#123;</span><br><span class="line">    String lockKeyRenew = lockKey + <span class="string">"_renew"</span>;</span><br><span class="line">    LockContent lockContent = lockContentMap.get(lockKey);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">long</span> consumeTime;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == lockContent) &#123;</span><br><span class="line">        consumeTime = <span class="number">0L</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lockValue.equals(lockContent.getRequestId())) &#123;</span><br><span class="line">        <span class="keyword">int</span> lockCount = lockContent.getLockCount();</span><br><span class="line">        <span class="comment">// 每次释放锁， 计数 -1，减到0时删除redis上的key</span></span><br><span class="line">        <span class="keyword">if</span> (--lockCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lockContent.setLockCount(lockCount);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        consumeTime = (System.currentTimeMillis() - lockContent.getStartTime()) / <span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"释放锁失败，不是自己的锁。"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除已完成key，先删除本地缓存，减少redis压力, 分布式锁，只有一个，所以这里不加锁</span></span><br><span class="line">    lockContentMap.remove(lockKey);</span><br><span class="line"> </span><br><span class="line">    RedisScript&lt;Long&gt; script = RedisScript.of(UNLOCK_SCRIPT, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    keys.add(lockKey);</span><br><span class="line">    keys.add(lockKeyRenew);</span><br><span class="line"> </span><br><span class="line">    Long result = redisTemplate.execute(script, keys, lockValue, Long.toString(consumeTime),</span><br><span class="line">            Long.toString(lockContent.getBizExpire()));</span><br><span class="line">    <span class="keyword">return</span> EXEC_SUCCESS.equals(result);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 续约</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockContent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true:续约成功，false:续约失败（1、续约期间执行完成，锁被释放 2、不是自己的锁，3、续约期间锁过期了（未解决））</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">renew</span><span class="params">(String lockKey, LockContent lockContent)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 检测执行业务线程的状态</span></span><br><span class="line">    Thread.State state = lockContent.getThread().getState();</span><br><span class="line">    <span class="keyword">if</span> (Thread.State.TERMINATED == state) &#123;</span><br><span class="line">        log.info(<span class="string">"执行业务的线程已终止,不再续约 lockKey =&#123;&#125;, lockContent=&#123;&#125;"</span>, lockKey, lockContent);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    String requestId = lockContent.getRequestId();</span><br><span class="line">    <span class="keyword">long</span> timeOut = (lockContent.getExpireTime() - lockContent.getStartTime()) / <span class="number">1000</span>;</span><br><span class="line"> </span><br><span class="line">    RedisScript&lt;Long&gt; script = RedisScript.of(RENEW_SCRIPT, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    keys.add(lockKey);</span><br><span class="line"> </span><br><span class="line">    Long result = redisTemplate.execute(script, keys, requestId, Long.toString(timeOut));</span><br><span class="line">    log.info(<span class="string">"续约结果，True成功，False失败 lockKey =&#123;&#125;, result=&#123;&#125;"</span>, lockKey, EXEC_SUCCESS.equals(result));</span><br><span class="line">    <span class="keyword">return</span> EXEC_SUCCESS.equals(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>}</p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入也就是说某个线程已经获得过某个锁，还可以再次获取锁而不会出现死锁。</p><p>Redisson锁的使用与 java.util.concurrent.locks.Lock 使用方法是一致的。下面是最简单的使用方式。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RLock reentrantLock = redissonClient.getLock(<span class="string">"order:A0001"</span>);</span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="comment">//TODO something</span></span><br><span class="line">reentrantLock.unlock();</span><br></pre></td></tr></table></figure><p>还可以给锁加过期时间，这样无需调用unlock方法手动解锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加锁以后10秒钟自动解锁</span></span><br><span class="line">reentrantLock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>Redisson 还提供一个leaseTime 参数来指定尝试加锁的时间，如下最多等待100秒，超过这个时间则放弃加锁。</p><p>// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> res = reentrantLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h4><p>公平锁，它保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RLock fairLock= redissonClient.getFairLock(<span class="string">"order:A0001"</span>);</span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="keyword">if</span> (fairLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Redisson 还为分布式可重入公平锁提供了异步执行的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RLock fairLock= redissonClient.getFairLock(<span class="string">"order:A0001"</span>);</span><br><span class="line"><span class="comment">// 开启异步模式</span></span><br><span class="line">fairLock.lockAsync();</span><br><span class="line"><span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line"><span class="keyword">if</span> (fairLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">       lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="联锁"><a href="#联锁" class="headerlink" title="联锁"></a>联锁</h4><p>联锁，Redisson 将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。也就说多个 key 同时加锁成功才算获得所。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RLock lock1 = redissonClient.getLock(<span class="string">"order:A0001"</span>);</span><br><span class="line">RLock lock2 = redissonClient.getLock(<span class="string">"order:A0002"</span>);</span><br><span class="line">RLock lock3 = redissonClient.getLock(<span class="string">"order:A0003"</span>);</span><br><span class="line"></span><br><span class="line">RLock multiLock = redissonClient.getMultiLock(lock1, lock2, lock3);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (multiLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">//TODO something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    multiLock.unlock();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    multiLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="红锁"><a href="#红锁" class="headerlink" title="红锁"></a>红锁</h4><p>红锁和联锁很相似，也是多个RLock对象关联为一个联锁，不同的是红锁中只要部分 key 加锁成功，即视为获得锁成功。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RLock lock1 = redissonClient.getLock(<span class="string">"order:A0001"</span>);</span><br><span class="line">RLock lock2 = redissonClient.getLock(<span class="string">"order:A0002"</span>);</span><br><span class="line">RLock lock3 = redissonClient.getLock(<span class="string">"order:A0003"</span>);</span><br><span class="line"></span><br><span class="line">RLock multiLock = redissonClient.getMultiLock(lock1, lock2, lock3);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (multiLock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">        <span class="comment">//TODO something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    multiLock.unlock();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    multiLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>读写锁，分为读锁与写锁，允许同时有多个读锁和一个写锁处于加锁状态。</p><p>RReadWriteLock readWriteLock = redissonClient.getReadWriteLock(“order:A0001”);</p><pre><code> try {

    if (readWriteLock.writeLock().tryLock(100, 10, TimeUnit.SECONDS)) {
        //TODO something
    }

    if (readWriteLock.readLock().tryLock(100, 10, TimeUnit.SECONDS)) {
        //TODO something
    }

    if (readWriteLock.readLock().tryLock(100, 10, TimeUnit.SECONDS)) {
        //TODO something
    }

} catch (Exception e) {
    readWriteLock.writeLock().unlock();
    readWriteLock.readLock().unlock();
} finally {
    readWriteLock.writeLock().unlock();
    readWriteLock.readLock().unlock();
}</code></pre><h3 id="四、分布式实时对象（Live-Object）服务"><a href="#四、分布式实时对象（Live-Object）服务" class="headerlink" title="四、分布式实时对象（Live Object）服务"></a>四、分布式实时对象（Live Object）服务</h3><p>我们可以将Live Object理解成多Redisson节点应用间共享的一个对象，这个对象不仅可以被一个JVM里的各个线程相引用，还可以被多个位于不同JVM里的线程同时引用。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>分布式对象运用代理类（Proxy），将一个指定的普通Java类里的所有字段，全部映射到一个Redis Hash的数据结构。而每个字段的 get和 set 方法最终被转译为针对同一个Redis Hash的 hget 和 hset命令，从而使所有连接到同一个Redis节点的所有可以客户端同时对一个指定的对象进行操作。</p><h4 id="设计分布式实时对象有什么好处呢？"><a href="#设计分布式实时对象有什么好处呢？" class="headerlink" title="设计分布式实时对象有什么好处呢？"></a>设计分布式实时对象有什么好处呢？</h4><p>相比于平时操作redis数据结构，分布式实时对象避免了针对任何一个字段操作都需要将整个对象序列化和反序列化的繁琐，进而降低了程序开发的复杂性和其数据模型的复杂性，从任何一个客户端修改一个字段的值，处在其他服务器上的客户端即刻便能查看到，实现代码与单机程序代码无异。</p><p>由于Redis是一个单线程的程序，针对实时对象的所有的字段操作也全部是原子性操作，也就是说在读取一个字段的过程不会担心被其他线程所修改。</p><p>如果一个Java对象要作为分布式对象，要使用到@REntity、@RId、@RIndex注解。</p><p>@REntity和@RId两个注解是分布式实时对象的必要条件。</p><p>注意： 标注@RId的字段类型不能是数组类（Array），比如int[]，long[]，double[]，byte[]。</p><p>@RIndex 用来指定可用于搜索的字段。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@REntity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderInfo</span> </span>&#123;</span><br><span class="line"><span class="meta">@RId</span></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RIndex</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RIndex</span></span><br><span class="line"><span class="keyword">private</span> String age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(String age)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>persist() 持久化对象相当于add，如果对象已存在，添加会报错，需判断对象是否已存在。</p><p>attach()、merge() 是对象的两种更新操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reduceStock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   RLiveObjectService service = redissonClient.getLiveObjectService();</span><br><span class="line">    OrderInfo orderInfo = <span class="keyword">new</span> OrderInfo();</span><br><span class="line">    orderInfo.setId(<span class="number">1</span>);</span><br><span class="line">    orderInfo.setName(<span class="string">"小富"</span>);</span><br><span class="line">    orderInfo.setAge(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    OrderInfo orderInfo2 = <span class="keyword">new</span> OrderInfo();</span><br><span class="line">    orderInfo2.setId(<span class="number">2</span>);</span><br><span class="line">    orderInfo2.setName(<span class="string">"小瑞"</span>);</span><br><span class="line">    orderInfo2.setAge(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将orderInfo对象当前的状态持久化到Redis里并与之保持同步。</span></span><br><span class="line">    <span class="keyword">if</span> (!service.isExists(orderInfo)) &#123;</span><br><span class="line">        orderInfo = service.persist(orderInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isExists(orderInfo2)) &#123;</span><br><span class="line">        orderInfo2 = service.persist(orderInfo2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抛弃orderInfo对象当前的状态，并与Redis里的数据建立连接并保持同步。</span></span><br><span class="line">    <span class="comment">//orderInfo = service.attach(orderInfo);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将orderInfo对象当前的状态与Redis里的数据合并之后与之保持同步。</span></span><br><span class="line">    <span class="comment">//orderInfo = service.merge(orderInfo);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询条件可以是含（IN），或（OR），和（AND）或相等（EQ）以及它们的任意组合。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reduceStock</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">   RLiveObjectService service = redissonClient.getLiveObjectService();</span><br><span class="line">    <span class="comment">// 通过ID获取分布式实时对象</span></span><br><span class="line">    OrderInfo myObject = service.get(OrderInfo<span class="class">.<span class="keyword">class</span>, 1)</span>;</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(myObject)) &#123;</span><br><span class="line">        System.out.println(<span class="string">"单条:"</span> + JSON.toJSONString(myObject));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过索引查找分布式实时对象</span></span><br><span class="line">    Collection&lt;OrderInfo&gt; myObjects = service.find(OrderInfo.class, Conditions.in("age", 16));</span><br><span class="line">    Collection&lt;OrderInfo&gt; myObjects1 = service.find(OrderInfo.class, Conditions.and(Conditions.in("name", "小富", "小瑞"), Conditions.eq("age", 1)));</span><br><span class="line">        System.out.println(<span class="string">"多条:"</span> + JSON.toJSONString(myObjects));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Spring Boot 减少JAR的大小</title>
    <url>/post/ed2b4eb8.html</url>
    <content><![CDATA[<blockquote><p>微服务架构，每个Jar包太大，传包速度又很慢 ~</p></blockquote><a id="more"></a><h3 id="一、POM增加一下配置"><a href="#一、POM增加一下配置" class="headerlink" title="一、POM增加一下配置"></a>一、POM增加一下配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 打出的jar包包名  --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                     <span class="comment">&lt;!-- 项目启动文件路径 --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.violet.BaseServerApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!-- 解决windows命令行窗口中文乱码 --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">jvmArguments</span>&gt;</span>-Dfile.encoding=UTF-8<span class="tag">&lt;/<span class="name">jvmArguments</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">layout</span>&gt;</span>ZIP<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!-- 配置需要打包进项目的jar包 --&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!-- 需要排除所有依赖 配置non-exists这个就行 --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--&lt;include&gt; --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--   &lt;groupId&gt;non-exists&lt;/groupId&gt; --&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--   &lt;artifactId&gt;non-exists&lt;/artifactId&gt; --&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!--&lt;/include&gt; --&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!-- 需要打包进jar包的依赖配置在这里 --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">include</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.violet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>base-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">goal</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 项目打包分离项目代码和依赖jar 插件 --&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                         <span class="comment">&lt;!-- 抽出的lib包存放了路径 --&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                           <span class="comment">&lt;!-- 是否排除依赖传递性 --&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">excludeTransitive</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeTransitive</span>&gt;</span></span><br><span class="line">                           <span class="comment">&lt;!-- 是否去掉jar包版本信息 --&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">stripVersion</span>&gt;</span>false<span class="tag">&lt;/<span class="name">stripVersion</span>&gt;</span></span><br><span class="line">                           <span class="comment">&lt;!-- 包含范围 --&gt;</span></span><br><span class="line">                           <span class="tag">&lt;<span class="name">includeScope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">includeScope</span>&gt;</span></span><br><span class="line">                       <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二、Jar包启动脚本"><a href="#二、Jar包启动脚本" class="headerlink" title="二、Jar包启动脚本"></a>二、Jar包启动脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-Xms: 设置初始化堆内存大小；</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-Xmx: 设置最大可分配堆内存大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MetaspaceSize:元空间默认大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">MaxMetaspaceSize:元空间最大大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash">JVM参数</span></span><br><span class="line">JVM_OPTS="-Xms128m -XX:MetaspaceSize=128M -Xmx128m -XX:MaxMetaspaceSize=512M -Dfile.encoding=utf-8"</span><br><span class="line"><span class="meta">#</span><span class="bash">日志输出路径</span></span><br><span class="line">LOG_HOME="/opt/data/logs/"</span><br><span class="line"><span class="meta">#</span><span class="bash">服务名称</span></span><br><span class="line">SERVER_NAME="base-server"</span><br><span class="line"><span class="meta">#</span><span class="bash">当前日期 如：2022-01-01</span></span><br><span class="line">TODAY=$(date -d "now" +"%Y-%m-%d")</span><br><span class="line">LOG_PATH="$&#123;LOG_HOME&#125;$&#123;SERVER_NAME&#125;/$&#123;TODAY&#125;/deb.log"</span><br><span class="line">ACTIVE="test"</span><br><span class="line"><span class="meta">#</span><span class="bash">脚本绝对路径</span></span><br><span class="line">SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" &amp;&amp; pwd )"</span><br><span class="line">JAR_PATH="$&#123;SCRIPT_DIR&#125;/$&#123;SERVER_NAME&#125;.jar"</span><br><span class="line">LIB_PATH="$&#123;SCRIPT_DIR&#125;/lib"</span><br><span class="line"><span class="meta">#</span><span class="bash">杀死已有进程</span></span><br><span class="line">echo stop $&#123;SERVER_NAME&#125; ..</span><br><span class="line">PID=$(ps -ef | grep $&#123;SERVER_NAME&#125;.jar | grep -v grep | awk '&#123;print $2&#125;')</span><br><span class="line"></span><br><span class="line">if [ ! $PID ]; then</span><br><span class="line">    echo "process $&#123;SERVER_NAME&#125; not exit"</span><br><span class="line">else</span><br><span class="line">    echo "process id: $PID"</span><br><span class="line">kill -9 $&#123;PID&#125;</span><br><span class="line">  if [ $? -eq 0 ]; then</span><br><span class="line">    echo "stop $&#123;SERVER_NAME&#125; success"</span><br><span class="line">  else</span><br><span class="line">    exit</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo start $&#123;SERVER_NAME&#125; ..</span><br><span class="line"><span class="meta">#</span><span class="bash">启动jar包 输出启动日志</span></span><br><span class="line">nohup java $&#123;JVM_OPTS&#125; -jar -Dloader.path=$&#123;LIB_PATH&#125; $&#123;JAR_PATH&#125; -Dspring.profiles.active=$&#123;ACTIVE&#125;&gt;$&#123;LOG_PATH&#125; 2&gt;&amp;1 &amp; tail -200f $&#123;LOG_PATH&#125;</span><br><span class="line">echo 'start successful'</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>SpringBoot 插件化开发模式，泰酷辣~</title>
    <url>/post/bb3db52d.html</url>
    <content><![CDATA[<blockquote><p>SpringBoot 插件化开发模式，泰酷辣~</p></blockquote><a id="more"></a><h3 id="一、使用插件的好处"><a href="#一、使用插件的好处" class="headerlink" title="一、使用插件的好处"></a>一、使用插件的好处</h3><h4 id="1、模块解耦"><a href="#1、模块解耦" class="headerlink" title="1、模块解耦"></a>1、模块解耦</h4><p>实现服务模块之间解耦的方式有很多，但是插件来说，其解耦的程度似乎更高，而且更灵活，可定制化、个性化更好。</p><h4 id="2、提升扩展性和开放性"><a href="#2、提升扩展性和开放性" class="headerlink" title="2、提升扩展性和开放性"></a>2、提升扩展性和开放性</h4><p>以spring来说，之所以具备如此广泛的生态，与其自身内置的各种可扩展的插件机制是分不开的，试想为什么使用了spring框架之后可以很方便的对接其他中间件，那就是spring框架提供了很多基于插件化的扩展点。</p><p>插件化机制让系统的扩展性得以提升，从而可以丰富系统的周边应用生态。</p><h4 id="3、方便第三方接入"><a href="#3、方便第三方接入" class="headerlink" title="3、方便第三方接入"></a>3、方便第三方接入</h4><p>有了插件之后，第三方应用或系统如果要对接自身的系统，直接基于系统预留的插件接口完成一套适合自己业务的实现即可，而且对自身系统的侵入性很小，甚至可以实现基于配置参数的热加载，方便灵活，开箱即用。</p><h3 id="二、-插件化常用实现思路"><a href="#二、-插件化常用实现思路" class="headerlink" title="二、 插件化常用实现思路"></a>二、 插件化常用实现思路</h3><p>以java为例，这里结合实际经验，整理一些常用的插件化实现思路：</p><ul><li>spi机制；</li><li>约定配置和目录，利用反射配合实现；</li><li>springboot中的Factories机制；</li><li>java agent（探针）技术；</li><li>spring内置扩展点；</li><li>第三方插件包，例如：spring-plugin-core；</li><li>spring aop技术；</li></ul><h3><a href="#" class="headerlink"></a></h3><h4 id="1、Serviceloader方式"><a href="#1、Serviceloader方式" class="headerlink" title="1、Serviceloader方式"></a>1、Serviceloader方式</h4><p>serviceloader是java提供的spi模式的实现。按照接口开发实现类，而后配置，java通过ServiceLoader来实现统一接口不同实现的依次调用。而java中最经典的serviceloader的使用就是Java的spi机制。</p><h4 id="2、SPI"><a href="#2、SPI" class="headerlink" title="2、SPI"></a>2、SPI</h4><p>SPI全称 Service Provider Interface ，是JDK内置的一种服务发现机制，SPI是一种动态替换扩展机制，比如有个接口，你想在运行时动态给他添加实现，你只需按照规范给他添加一个实现类即可。比如大家熟悉的jdbc中的Driver接口，不同的厂商可以提供不同的实现，有mysql的，也有oracle的，而Java的SPI机制就可以为某个接口寻找服务的实现。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230625145517296.png" alt=""></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>QPS、TPS</title>
    <url>/post/f89ad074.html</url>
    <content><![CDATA[<blockquote><p>QPS、TPS ~</p></blockquote><a id="more"></a><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>有一道题：10W个请求，4秒内完成处理，每个请求耗时2秒，系统QPS需要达到多少才能满足？每秒多少并发才能达到这样的QPS？</p><h3 id="QPS"><a href="#QPS" class="headerlink" title="QPS"></a>QPS</h3><p>QPS（每秒查询率或每秒请求率）是衡量系统处理能力的一项重要指标，表示系统在单位时间内能够处理的请求数或查询数。一般来说，QPS越高，系统的处理能力就越强，可以处理更多的请求或查询。QPS的计算公式为：<strong>QPS = 总请求数 / 总处理时间</strong> 。例如，一个系统在1秒内处理了1000个请求，则该系统的QPS为1000。QPS的高低取决于系统的性能、硬件配置、网络带宽等因素，是评估系统性能的重要指标之一。</p><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>首先，我们可以计算出每个请求的处理时间为2秒。然后，我们可以使用以下公式来计算系统的 QPS（每秒请求数）：</p><p><strong>QPS = 总请求数 / 总处理时间</strong></p><p>在这个问题中，总请求数为10万（即100,000），总处理时间为4秒。</p><p>QPS = 100,000 / 4 = 25,000</p><p>因此，系统的 QPS 需要达到25,000。</p><p>要计算每秒的并发数，我们可以使用以下公式：</p><p><strong>并发数 = QPS * 平均响应时间</strong></p><p>在这个问题中，平均响应时间为2秒。</p><p>并发数 = 25,000 * 2 = 50,000</p><p>因此，每秒需要达到50,000的并发数才能满足这样的 QPS。</p><h3 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h3><p>TPS（每秒事务数）是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是<strong>指一个客户机向服务器发送请求然后服务器做出反应的过程</strong>。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。计算TPS的公式如下：</p><p><strong>TPS = 总事务数 / 总时间</strong></p><p>其中，总事务数是指在给定时间内完成的事务数量，总时间是指完成这些事务所花费的总时间。</p><p>请注意，TPS与QPS的概念略有不同。TPS通常用于衡量系统的事务处理能力，而QPS通常用于衡量系统的请求数量。</p><blockquote><p>TPS处理流程：</p><p>Tps即每秒处理事务数，包括了</p><p>1、用户请求服务器</p><p>2、服务器自己的内部查询等处理</p><p>3、服务器返回给用户</p><p>这三个过程，每秒能够完成N个这三个过程，Tps也就是3；</p><p>QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入QPS之中。每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</p><p>一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><p>如果是对一个接口（单场景）压测，且这个接口内部不会再去请求其它接口，那么TPS等于QPS，否则，TPS 不等于 QPS</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>MySql规范</title>
    <url>/post/569feba.html</url>
    <content><![CDATA[<blockquote><p>MySql规范介绍 ~</p></blockquote><a id="more"></a><h2 id="1-背景和目的"><a href="#1-背景和目的" class="headerlink" title="1. 背景和目的"></a>1. 背景和目的</h2><p>开发人员在项目中针对DB（MySQL）需要规范使用。</p><h2 id="2-MySQL数据库规范"><a href="#2-MySQL数据库规范" class="headerlink" title="2. MySQL数据库规范"></a>2. MySQL数据库规范</h2><p>以下所有规范会按照<strong>【强制】、【建议】</strong>两个级别进行标注，<strong>强制也表示此规范必须要落地</strong>。</p><h3 id="2-1-1-字符集"><a href="#2-1-1-字符集" class="headerlink" title="2.1.1 字符集"></a>2.1.1 字符集</h3><p>【强制】数据库本身库、表、列所有字符集必须保持一致， 使用<code>utf8mb4（使用MySQL版本 5.7.27，可完美支持emoji字符)</code>。</p><h3 id="2-1-2-一般命名规则-（适用于-库名，表名，字段-索引名-）"><a href="#2-1-2-一般命名规则-（适用于-库名，表名，字段-索引名-）" class="headerlink" title="2.1.2 一般命名规则 （适用于 库名，表名，字段 索引名 ）"></a>2.1.2 一般命名规则 （适用于 库名，表名，字段 索引名 ）</h3><ol><li>【强制】避免使用保留字作为名称。</li><li>【推荐】有效的可理解的名称，禁止使用拼音，英文单词使用单数；</li></ol><h3 id="2-2-库"><a href="#2-2-库" class="headerlink" title="2.2 库"></a>2.2 库</h3><h4 id="2-2-1-规则"><a href="#2-2-1-规则" class="headerlink" title="2.2.1 规则"></a>2.2.1 规则</h4><ol><li><p>【强制】库的名称格式：业务域名_应用名，只包含小写字母和下划线，且以小写字母开头，长度不超过64个字符。</p></li><li><p>【强制】创建数据库时必须显式指定字符集，并且字符集只能是 utf8mb4。创建数据库 SQL 举例：</p><p><code>create</code> <code>database</code> db_name default<code></code>character<code></code>set<code></code>utf8mb4；</p></li></ol><h3 id="2-3-表"><a href="#2-3-表" class="headerlink" title="2.3 表"></a>2.3 表</h3><h4 id="2-3-1-表设计原则"><a href="#2-3-1-表设计原则" class="headerlink" title="2.3.1 表设计原则"></a>2.3.1 表设计原则</h4><ol><li>更快速的实现业务支撑&amp;数据更好维护</li><li>在线上业务压力增大的情况，或是要支撑更大的并发时，知道怎么做能获得最佳的实践。</li></ol><h4 id="2-3-2-表设计目标"><a href="#2-3-2-表设计目标" class="headerlink" title="2.3.2 表设计目标"></a>2.3.2 表设计目标</h4><ol><li>尽量小的原则，不浪费</li><li>为了高并发，建议禁止使用外键</li><li>字符集和库级保持一致。不单独定义字段字符集( utf8mb4)。</li></ol><h4 id="2-3-3-表设计规则"><a href="#2-3-3-表设计规则" class="headerlink" title="2.3.3 表设计规则"></a>2.3.3 表设计规则</h4><ol><li><p>【强制】只包含小写字母和下划线，且以小写字母开头，长度不超过64个字符。</p></li><li><p>【强制】 <strong>以下针对非分库分表场景</strong> 关于主键：(1) 命名为 <code>id</code>，<strong>强制bigint，且为 <code>auto_increment</code></strong>；(2) 标识表里每一行主体的字段不要设为主键，建议设为其它字段如 <code>user_id</code>，<code>order_id</code>等，根据实际使用频率来建立索引。</p></li><li><p>【强制】 <strong>针对分库分表场景 关于主键策略，假定使用MyCat，需考虑使用全局主键生成方案:</strong> 1. 本地文件方式：使用服务器本地磁盘文件的方式. 2. 本地时间戳方式：使用时间戳方式。</p></li><li><p>【建议】相关模块的表名与表名之间尽量体现 join 的关系，如 <code>user</code> 表和 <code>user_login</code> 表。</p></li><li><p>【强制】创建表时必须显式指定字符集为 utf8mb4。</p></li><li><p>【强制】创建表时必须显式指定表存储引擎类型，如无特殊需求，一律为 InnoDB。</p></li><li><p>【强制】建表必须有 comment。</p></li><li><p>【建议】核心表（如用户表，金钱相关的表）必须有行数据的创建时间字段 <code>create_time</code> 和最后更新时间字段 <code>update_time</code>，建议数据类型是datatime,建议 <code>create_time的默认数值是CURRENT_TIMESTAMP().</code></p></li><li><p>【建议】初始化建表时所有字段必须都是 <code>NOT NULL</code> 属性(<strong>除了特殊业务场景下的时间类型字段</strong>)，业务可以根据需要定义 <code>DEFAULT</code> 值。后期对原始表进行ddl操作,表数据量达到百万级别时，可以允许为null（主要是减少变更耗时）</p></li><li><p>【建议】建议对表里的 <code>blob</code>、<code>text</code> 等大字段，垂直拆分到其它表里，仅在需要读这些对象的时候才去 select，比如订单order表，有comment字段，可以创建order_comment映射表,所有的comment单独放在comment表里.</p></li><li><p>【强制】中间表用于保留中间结果集，名称必须以 <code>tmp_</code> 开头。备份表用于备份或抓取源表快照，名称必须以 _<code>bak</code>结尾。中间表和备份表定期清理。</p></li></ol><h3 id="2-4-字段"><a href="#2-4-字段" class="headerlink" title="2.4 字段"></a>2.4 字段</h3><h4 id="2-4-1-字段设计原则"><a href="#2-4-1-字段设计原则" class="headerlink" title="2.4.1 字段设计原则"></a>2.4.1 字段设计原则</h4><ul><li>InnoDB表是索引聚集组织表（IOT）， 所有的行数据（row data）都是以主键（严格意义讲，是聚集索引）逻辑顺序存储，而二级索引（或称辅助索引，secondary index）的value则同时包含主键。</li><li>InnoDB的最小I/O单位是data page（默认一个data page大小是16KB），在buffer pool中的最小单位是data page（而不是每行数据哦）。因此也可以这么理解，一个data page里的热点数据越多，其在buffer pool的命中率就会越高。</li><li>MySQL复制环境中，如果binlog format是row的，则从库上的数据更新时是以主键为依据进行apply的，如果没有主键则将可能会有灾难性的后果。</li><li>此外，建议每张表三个必加字段：id（int/bigint unsigned类型，自增长列，并且作为主键），create_time（timestamp或int unsigned）、update_time（和create_time相同）用于记录行创建时间以及最后更新时间，在业务上以及日常维护上会有很多便利；</li></ul><h4 id="2-4-2-字段设计目标"><a href="#2-4-2-字段设计目标" class="headerlink" title="2.4.2 字段设计目标"></a>2.4.2 字段设计目标</h4><p>​ 优先选择符合存储需要的最小的数据类型</p><h4 id="2-4-3-字段设计规则"><a href="#2-4-3-字段设计规则" class="headerlink" title="2.4.3 字段设计规则"></a>2.4.3 字段设计规则</h4><ol><li>【强制】只包含小写字母和下划线，且以小写字母开头，长度不超过64个字符。</li><li>【强制】避免使用保留字作为字段名称；</li><li>【强制】避免使用与表名相同的字段名，这会在编写查询时造成混淆。</li><li>【建议】从性能角度，不建议使用外键。</li><li>【强制】字段名称长度不超过64个字符。</li><li>【建议】 使用完整单词加下划线命名，避免使用缩写或基于首字母缩写词的名称。</li></ol><h3 id="2-5-索引设计"><a href="#2-5-索引设计" class="headerlink" title="2.5 索引设计"></a>2.5 索引设计</h3><h4 id="2-5-1-索引设计原则"><a href="#2-5-1-索引设计原则" class="headerlink" title="2.5.1 索引设计原则"></a>2.5.1 索引设计原则</h4><ol><li>数据库索引是一种数据结构，它以额外的写入和存储空间为代价来提高数据库表上数据检索操作的速度。通俗来说，索引类似于书的目录，根据其中记录的页码可以快速找到所需的内容。</li><li>索引并不是越多越好，要根据查询，有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是使用了索引还是全表扫描。</li><li>值分布很稀少的字段不适合建索引。</li><li>针对索引的各种类型(普通索引,唯一索引,主键索引,全文索引,组合索引),有针对性的创建。</li></ol><h4 id="2-5-2-索引设计目标"><a href="#2-5-2-索引设计目标" class="headerlink" title="2.5.2 索引设计目标"></a>2.5.2 索引设计目标</h4><ol><li>降低查询时间。</li><li>增加索引命中率。</li></ol><h4 id="2-5-3-索引设计规则"><a href="#2-5-3-索引设计规则" class="headerlink" title="2.5.3 索引设计规则"></a>2.5.3 索引设计规则</h4><ol><li>【强制】符合最左前缀匹配原则.</li><li>【强制】<strong>以下针对非分库分表场景</strong> ，InnoDB表必须主键为bigint auto_increment,且主键值禁止被更新.</li><li>【建议】唯一键以“uk_”开头，普通索引以“idx_”开头，主键以“pk”开头，一律使用小写格式，以字段的名称或缩写作为后缀.</li><li>【强制】 引擎强制为InnoDB，索引类型必须为BTREE；MEMORY表可以根据需要选择HASH或者BTREE类型索引</li><li>【建议】正确使用前缀索引，如果字段值超过10个字符，可以考虑建立前缀索引，例如Key（字段（6）），针对字段的前6个字符建立索引 ，不用建立整个字段的索引。</li><li>【建议】单个表上的索引个数不能超过5个.</li><li>【建议】在建立索引时，多考虑建立联合索引，根据使用频率， 并把区分度最高的字段放在最前面。如列userid的区分度可由select count(distinct userid)计算出来.</li><li>【建议】在多表join的SQL里，保证被驱动表的连接列上有索引，同时建议用小的数据表驱动大的表，这样join执行效率最高.</li><li>【建议】根据业务场景和需求，保证表里互相不存在冗余索引。对于MySQL来说，如果表里已经存在key(a,b)，则key(a)为冗余索引，建议删除.</li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>kafka消费者组积压</title>
    <url>/post/c02adc20.html</url>
    <content><![CDATA[<blockquote><p>正确理解kafka消息积压 ~</p></blockquote><a id="more"></a><p>“消费者”与“消费者”组：</p><ul><li>消费者组是一组具有共同消费特征的消费者的集合，对于kafka来说，这个特征就是这些消费者共同消费一个或几个主题。</li><li>消费者组存在的一个重要原因是：单个消费者无法满足某个主题下的数据处理的速度，所以需要多个消费者来负载</li></ul><p>每一个消费者组内的消费者都具备一个共享id，即group id（消费者组id）。在创建消费者的时候，设置group id。默认创建消费者的group id。</p><h3 id="一、主题分区与消费者的数量"><a href="#一、主题分区与消费者的数量" class="headerlink" title="一、主题分区与消费者的数量"></a>一、主题分区与消费者的数量</h3><p>在开始为大家介绍消费者之前，有必要深入的了解一下“主题分区数量”与“消费者数量”之间的关系。kafka主题分区消费的一个原则是：<strong>一个分区只能被消费者组里面的一个消费者消费</strong>。</p><h4 id="1-1-当分区数量多于消费者的数量"><a href="#1-1-当分区数量多于消费者的数量" class="headerlink" title="1.1.当分区数量多于消费者的数量"></a>1.1.当分区数量多于消费者的数量</h4><p>当某个主题的分区数量，大于订阅它的消费者组内消费者数量，就会出现下面的情况。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/0a0410547d61489e9eaab96a0b2a8f67.png" alt=""></p><ul><li>一个消费者消费多个分区</li><li>分区尽量均衡的分给消费者组内的多个消费者</li></ul><h4 id="1-2-当分区数量小于消费者数量"><a href="#1-2-当分区数量小于消费者数量" class="headerlink" title="1.2.当分区数量小于消费者数量"></a>1.2.当分区数量小于消费者数量</h4><p>当某个主题的分区数量，小于订阅它的消费者组内消费者数量，比如下图中，四个分区五个消费者，就会有一个消费者处于空闲状态。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/b12988acab994583959eebd307f6d501.png" alt=""></p><p>所以kafka消费者组内的消费者不是越多越好，也不是消费者越多处理速度越快。<strong>如果分区数没有匹配消费者数量，创建再多的消费者也不会提高数据消费速率。</strong></p><h4 id="1-3-当分区数量等于消费者的数量"><a href="#1-3-当分区数量等于消费者的数量" class="headerlink" title="1.3.当分区数量等于消费者的数量"></a>1.3.当分区数量等于消费者的数量</h4><p>基于上面的内容，以及<strong>一个分区只能被消费者组里面的一个消费者消费</strong>的原则，最佳状态如下图所示：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/89ac128920f04e6c915cc9c7f4d59046.png" alt=""></p><p>所以当我们发现某一个主题的消费数据积压的时候，首先想到的应该是优化消费者数据消费的程序，提高数据处理效率。如果仍然无法满足需求，则<strong>同步的加大主题的分区数量以及消费者组内消费者的数量，让二者保持数量一致</strong>。</p><h4 id="1-4-多个消费者组-多主题"><a href="#1-4-多个消费者组-多主题" class="headerlink" title="1.4.多个消费者组-多主题"></a>1.4.多个消费者组-多主题</h4><p>下面再用一张更复杂一点的图帮助大家理解，“主题分区数量”与“消费者数量”之间的关系。</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/2ef7976792b84d6b9b167af5c2fe0ad1.png" alt=""></p><ul><li>一个分区只能被消费者组里面的一个消费者消费</li><li>一个消费者可能会消费某个主题内的多个分区</li><li>最佳状态时主题分区数等于消费者组内消费者数量</li><li>如果某消费者组消费者数量大于其订阅的主题的分区数，会发生多出来的消费者空转的现象。</li></ul><h3 id="二、查看消费者组的数据积压"><a href="#二、查看消费者组的数据积压" class="headerlink" title="二、查看消费者组的数据积压"></a>二、查看消费者组的数据积压</h3><p>在为大家讲解如何查看“消费者组的数据积压”之前，先纠正部分朋友的一个错误概念：<strong>积压不是在kafka主题分区内产生的么？为什么要查看消费者组的数据积压？</strong>。这个问题是我在刚开始学习kafka的时候没想通的一个问题。</p><ul><li>一个主题可以被多个消费者组订阅，比如消费者组A、消费者组B</li><li>消费者组A的消费进度和消费者组B的消费进度一定不一样</li><li>如果消费者组B的消费进度慢，就是消费者组B的消息数据发生积压。与消费者组A无关。</li></ul><p>所以查看数据消费进度，或者消息数据是否积压，是以“消费者”组为单位进行查看的。可以通过命令行查看某个消费者组的消费进度情况</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bin/kafka-consumer-groups.sh --bootstrap-server zimug1:9092 --describe --group my-group</span></span><br></pre></td></tr></table></figure><p>得到类似于下面的这样的响应结果：</p><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/83061ac8755e41648951ff2eadada8c1.png" alt=""></p><p>由上文结果我们可以得到如下信息</p><ul><li>一个主题的一个分区信息占一行</li><li>该消费者组订阅了三个主题：topic1（一个分区0）、topic2（两个分区0、1）、topic3（三个分区0、1、2）</li><li>CURRENT-OFFSET是当前数据消费进度的偏移</li><li>LOG-END-OFFSET是当前分区已经接收到的数据信息偏移</li><li>LAG = （LOG-END-OFFSET - CURRENT-OFFSET）。LAG的值越大说明数据积压越严重。</li></ul><h3 id="三、数据积压如何处理？"><a href="#三、数据积压如何处理？" class="headerlink" title="三、数据积压如何处理？"></a>三、数据积压如何处理？</h3><h4 id="什么是数据积压"><a href="#什么是数据积压" class="headerlink" title="什么是数据积压"></a>什么是数据积压</h4><p>答：我看过有的文章说LAG&gt;0是数据积压，可能笔者对这个问题的理解不同。举个例子：如果某分区一天平均1000万数据，积压量稳定在1万条，这算是数据积压么？我觉得可以算也可以不算，这取决于你的用户对于数据延时的需求是什么样的？如果你平时LAG就是1万，从用户感知的角度也没有提出降低数据延时的需求，那么这就不是数据积压。如果你平时的LAG是1万，异常状态下变成了几十万，那么这就是数据积压了。</p><h4 id="如何解决积压"><a href="#如何解决积压" class="headerlink" title="如何解决积压"></a>如何解决积压</h4><p>如果发生数据积压，从以下几个方面入手</p><ul><li>优化数据处理程序，提高数据处理的速度</li><li>增大发生积压的主题的分区的数量</li><li>同时增大消费该主题的消费者的数量，让其等于该主题的分区数</li><li>前面三点都是基于kafka去处理，或者我们可以抛开kafka，在用户请求产生数据的时候给予一定的流量控制，比如：微服务可以使用Spring Cloud alibaba sentinal</li></ul><blockquote><p>示例1：主题分区数=40，节点总数=10，监听器线程数=40/10=4</p><p>示例2：主题分区数=108，应用节点总数=18，监听器线程数=108/18=6</p><p>公式：</p><p>1、主题分区数= 应用节点总数 * 监听器线程数</p><p>2、应用节点总数 = 主题分区数 / 监听器线程数</p><p>3、监听器线程数 = 主题分区数/ 应用节点总数</p></blockquote><p>如何增大主题分区数量？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. &gt; bin/kafka-topics.sh --alter \</span><br><span class="line">2. --bootstrap-server broker1:9092,broker2:9092,broker3:9092 \</span><br><span class="line">3. --topic my_topic_name </span><br><span class="line">4. --partitions 4</span><br></pre></td></tr></table></figure><p>比如原来my_topic_name 主题分区数2个，我想增大为4个，可以使用上面的命令。<strong>注意：主题的分区数只能增大，不能减小，所以请谨慎评估，合理扩容。</strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>HikariPool最佳配置</title>
    <url>/post/dfff14d8.html</url>
    <content><![CDATA[<blockquote><p>HikariPool 配置 ~</p></blockquote><a id="more"></a><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>Spring Boot 默认使用 HikariPool 这是我在控制台中遇到的错误：Possibly consider using a shorter maxLifetime value。</p><h3 id="二、原因"><a href="#二、原因" class="headerlink" title="二、原因"></a>二、原因</h3><p>spring.datasource.hikari.maxLifetime 的默认值（30 分钟）高于数据库的“wait_timeout”（10 分钟）。</p><h3 id="三、方案"><a href="#三、方案" class="headerlink" title="三、方案"></a>三、方案</h3><ol><li>将 hikari.maxLifetime 减少到 10 分钟以下。</li><li>增加数据库的“wait_timeout”属性。</li></ol><h3 id="四、最佳配置"><a href="#四、最佳配置" class="headerlink" title="四、最佳配置"></a>四、最佳配置</h3><p><img data-src="https://shuaizinanyihao.github.io/shuaizi-image/blogImg/image-20230830173019491.png" alt="推荐配置1"></p><p>最佳配置2：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 较佳配置</span></span><br><span class="line"><span class="attr">hikari:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">validation-timeout:</span> <span class="number">3000</span></span><br><span class="line">    <span class="attr">idle-timeout:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">login-timeout:</span> <span class="number">5</span>	</span><br><span class="line">    <span class="attr">max-lifetime:</span> <span class="number">60000</span></span><br><span class="line">    <span class="attr">maximum-pool-size:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">minimum-idle:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">read-only:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="五、参数说明"><a href="#五、参数说明" class="headerlink" title="五、参数说明"></a>五、参数说明</h3><p><code>autoCommit</code><br>此属性控制从池返回的连接的默认自动提交行为。它是一个布尔值。 <em>默认值：真</em></p><p>⏳<code>connectionTimeout</code><br>此属性控制客户端（即您）将等待来自池的连接的最大毫秒数。如果在没有可用连接的情况下超过此时间，将引发 SQLException。可接受的最低连接超时为 250 毫秒。 <em>默认值：30000（30 秒）</em></p><p>⏳<code>idleTimeout</code><br>此属性控制允许连接在池中空闲的最长时间。 <strong>此设置仅在<code>minimumIdle</code>定义为小于时适用<code>maximumPoolSize</code>。</strong>一旦池达到连接， 空闲连接将<em>不会<em><code>minimumIdle</code>被淘汰。连接是否因空闲而退出取决于最大变化为 +30 秒，平均变化为 +15 秒。在此超时</em>之前*，连接永远不会因为空闲而退出。值 0 表示永远不会从池中删除空闲连接。允许的最小值为 10000 毫秒（10 秒）。 *默认值：600000（10 分钟）</em></p><p>⏳<code>keepaliveTime</code><br>此属性控制 HikariCP 尝试保持连接活动的频率，以防止它被数据库或网络基础设施超时。该值必须小于该 <code>maxLifetime</code>值。“keepalive”只会发生在空闲连接上。当针对给定连接的“keepalive”时间到达时，该连接将从池中删除，“ping”，然后返回到池中。“ping”是以下之一：调用 JDBC4<code>isValid()</code>方法，或执行 <code>connectionTestQuery</code>. 通常，池外的持续时间应该以个位数毫秒甚至亚毫秒为单位测量，因此应该对性能影响很小或没有明显影响。允许的最小值为 30000 毫秒（30 秒）， <em>默认值：0（禁用）</em></p><p>⏳<code>maxLifetime</code><br>此属性控制池中连接的最大生命周期。使用中的连接永远不会被淘汰，只有当它关闭时才会被删除。在逐个连接的基础上，应用较小的负衰减以避免池中的大规模灭绝。 <strong>我们强烈建议设置此值，它应该比任何数据库或基础设施强加的连接时间限制短几秒钟。</strong> 值 0 表示没有最大生命周期（无限生命周期），当然取决于<code>idleTimeout</code>设置。允许的最小值为 30000 毫秒（30 秒）。 <em>默认值：1800000（30 分钟）</em></p><p>🔤<code>connectionTestQuery</code><br><strong>如果您的驱动程序支持 JDBC4，我们强烈建议不要设置此属性。</strong>这适用于不支持 JDBC4 的“旧版”驱动程序<code>Connection.isValid() API</code>。这是将在池中为您提供连接之前执行的查询，以验证与数据库的连接是否仍然存在。<em>同样，尝试在没有此属性的情况下运行池，如果您的驱动程序不符合 JDBC4，HikariCP 将记录错误以通知您。</em> <em>默认值：无</em></p><p>🔢<code>minimumIdle</code><br>此属性控制HikariCP 尝试在池中维护的最小<em>空闲连接数。<em>如果空闲连接低于此值并且池中的总连接数小于<code>maximumPoolSize</code>，HikariCP 将尽最大努力快速有效地添加额外的连接。但是，为了获得最大性能和对峰值需求的响应，我们建议</em>不要<em>设置此值，而是允许 HikariCP 充当</em>固定大小*的连接池。 *默认值：与 maximumPoolSize 相同</em></p><p>🔢<code>maximumPoolSize</code><br>此属性控制池允许达到的最大大小，包括空闲和使用中的连接。基本上，此值将确定与数据库后端的实际连接的最大数量。一个合理的值最好由您的执行环境确定。<code>connectionTimeout</code>当池达到这个大小并且没有可用的空闲连接时，对 getConnection() 的调用将在超时之前阻塞长达几毫秒。请阅读<a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" target="_blank" rel="noopener">有关池大小</a>的信息。 <em>默认值：10</em></p><p>📈<code>metricRegistry</code><br>此属性仅可通过编程配置或 IoC 容器使用。此属性允许您指定<em>Codahale/Dropwizard</em> <code>MetricRegistry</code>的实例，以供池用于记录各种指标。有关详细信息，请参阅<a href="https://github.com/brettwooldridge/HikariCP/wiki/Dropwizard-Metrics" target="_blank" rel="noopener">度量</a> wiki 页面。 <em>默认值：无</em></p><p>📈<code>healthCheckRegistry</code><br>此属性仅可通过编程配置或 IoC 容器使用。此属性允许您指定<em>Codahale/Dropwizard</em> <code>HealthCheckRegistry</code>的实例，供池用于报告当前的健康信息。有关详细信息，请参阅运行<a href="https://github.com/brettwooldridge/HikariCP/wiki/Dropwizard-HealthChecks" target="_blank" rel="noopener">状况检查</a> wiki 页面。 <em>默认值：无</em></p><p>🔤<code>poolName</code><br>此属性表示连接池的用户定义名称，主要出现在日志记录和 JMX 管理控制台中，以识别池和池配置。 <em>默认值：自动生成</em>。</p><table><thead><tr><th><code>spring.datasource.hikari.connection-timeout</code></th><th>控制客户端等待来自数据库连接池连接的最大毫秒数。如果在没有可用连接的情况下超过此时间，将引发 SQLException。可接受的最低连接超时为 250 毫秒。 <strong>默认值：30000（30 秒）</strong></th></tr></thead><tbody><tr><td><code>spring.datasource.hikari.idle-timeout</code></td><td>只有当minimum-idle小于maximum-pool-size时，这个参数才生效，当空闲连接数超过minimum-idle，而且空闲时间超过idleTimeout，则会被移除。</td></tr><tr><td><code>spring.datasource.hikari.max-lifetime</code></td><td>连接在连接池中的最大<a href="https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020" target="_blank" rel="noopener">生命周期</a>， 强烈建议设置此值，它应该比任何数据库或基础设施强加的连接时间限制短几秒钟。 值 0 表示没有最大生命周期（无限生命周期），当然取决于<code>idleTimeout</code>设置。允许的最小值为 30000 毫秒（30 秒）。 <em>默认值：1800000（30 分钟）</em>注意：max-lifetime必须比数据库的wait_timeout参数短一些</td></tr><tr><td><code>spring.datasource.hikari.maximum-pool-size</code></td><td>此属性表示数据库连接池允许达到的最大大小，包括空闲和使用中的连接。</td></tr><tr><td><code>spring.datasource.hikari.minimum-idle</code></td><td>此属性表示数据库连接池中维护的最小空闲连接数</td></tr><tr><td><code>spring.datasource.hikari.pool-name</code></td><td>此属性表示连接池的用户定义名称，主要出现在日志记录和 JMX 管理控制台中，以识别池和池配置。</td></tr></tbody></table><p><strong>官网：<a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP</a></strong></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-Plus如何将字段修改为空值</title>
    <url>/post/62b88c18.html</url>
    <content><![CDATA[<blockquote><p>MyBatis-Plus如何将字段修改为空值 ~</p></blockquote><a id="more"></a><h3 id="方案一、修改全局更新策略（不推荐）"><a href="#方案一、修改全局更新策略（不推荐）" class="headerlink" title="方案一、修改全局更新策略（不推荐）"></a>方案一、修改全局更新策略（不推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mybatis-plus:</span><br><span class="line">	global-config:</span><br><span class="line">		#字段策略 IGNORED："忽略判断"、NOT_NULL："非NULL判断"、NOT_EMPTY："非空判断"</span><br><span class="line">    	field-strategy: IGNORED</span><br></pre></td></tr></table></figure><blockquote><p>不推荐使用原因：作用范围太广。<font color="red"><strong>注意：调用MyBatis-Plus封装的 update 也会不经意将字段改为空，影响其他接口。</strong></font></p></blockquote><h3 id="方案二、修改指定字段的更新策略（不推荐）"><a href="#方案二、修改指定字段的更新策略（不推荐）" class="headerlink" title="方案二、修改指定字段的更新策略（不推荐）"></a>方案二、修改指定字段的更新策略（不推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableField</span>(strategy = FieldStrategy.IGNORED)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><blockquote><p>不推荐使用原因：相对于方案一作用范围相对较小。<font color="red"><strong>注意：调用MyBatis-Plus封装的 update 也会不经意将字段改为空，影响其他接口。</strong></font></p></blockquote><h3 id="方案三、使用LambdaUpdateWrapper只在特定需求下做处理（推荐）"><a href="#方案三、使用LambdaUpdateWrapper只在特定需求下做处理（推荐）" class="headerlink" title="方案三、使用LambdaUpdateWrapper只在特定需求下做处理（推荐）"></a>方案三、使用LambdaUpdateWrapper只在特定需求下做处理（推荐）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">order.setId(<span class="number">1</span>);</span><br><span class="line">order.setPrice(<span class="number">3.8</span>)</span><br><span class="line">order.setName(<span class="keyword">null</span>)</span><br><span class="line">LambdaUpdateWrapper&lt;Order&gt; lambdaUpdate = Wrappers.lambdaUpdate();</span><br><span class="line"><span class="comment">//构建where条件根据id修改</span></span><br><span class="line">lambdaUpdate.eq(Order::getId, order.getId()); </span><br><span class="line"><span class="comment">//name属性为空时可以修改字段为NULL</span></span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(order.getName())) lambdaUpdate.set(Order::getName, <span class="keyword">null</span>); </span><br><span class="line"><span class="comment">//此时生成的SQL语句为update order set price = 3.8, name = null where id = 1</span></span><br><span class="line"><span class="keyword">super</span>.update(order, lambdaUpdate);</span><br></pre></td></tr></table></figure><blockquote><p>推荐原因：不影响任何地方只在此处生效</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>OpenSSL生成证书</title>
    <url>/post/da432f73.html</url>
    <content><![CDATA[<blockquote><p>OpenSSL介绍 ~</p></blockquote><a id="more"></a><h3 id="一、事前准备"><a href="#一、事前准备" class="headerlink" title="一、事前准备"></a>一、事前准备</h3><p>使用版本：OpenSSL 1.0.2k-fips 26 Jan 2017</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line">yum install openssl</span><br><span class="line">yum install vim</span><br><span class="line">mkdir /opt/ssl</span><br><span class="line">cd /opt/ssl/</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 生成证书的时候每次都执行以下命令，清除缓存</span></span></span><br><span class="line">cp /etc/pki/tls/openssl.cnf ./</span><br><span class="line">rm -rf /etc/pki/CA/*.old</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 删除证书索引库数据库文件</span></span></span><br><span class="line">rm -rf /etc/pki/CA/index.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 生成证书索引库数据库文件</span></span></span><br><span class="line">touch /etc/pki/CA/index.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 指定第一个颁发证书的序列号</span></span></span><br><span class="line">echo 01 &gt; /etc/pki/CA/serial</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 创建文件夹</span></span></span><br><span class="line">rm -rf certs;mkdir certs</span><br></pre></td></tr></table></figure><h3 id="二、生成证书"><a href="#二、生成证书" class="headerlink" title="二、生成证书"></a>二、生成证书</h3><h4 id="1-生成CA根证书"><a href="#1-生成CA根证书" class="headerlink" title="1. 生成CA根证书"></a>1. 生成CA根证书</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">根证书：</span><br><span class="line">1.生成根证书私钥；</span><br><span class="line">openssl genrsa -out IoTRootCA.key 2048</span><br><span class="line">2.生成根证书签发申请文件并生成根证书；</span><br><span class="line">openssl req -x509 -new -key IoTRootCA.key -sha256 -days 3650 -subj "/C=CN/ST=Zhejiang/L=Hangzhou/O=EMQ/OU=Broker/CN=RootCA" -out IoTRootCA.pem -config openssl.cnf</span><br></pre></td></tr></table></figure><h4 id="2-生成服务端证书"><a href="#2-生成服务端证书" class="headerlink" title="2. 生成服务端证书"></a>2. 生成服务端证书</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.生成服务端证书的私钥；</span><br><span class="line">openssl genrsa -out EMQServer.key 2048</span><br><span class="line">2.根据私钥签发一个证书请求；</span><br><span class="line">openssl req -new  -days 3650 -key EMQServer.key -out EMQServer.csr -subj "/C=CN/ST=Zhejiang/L=Hangzhou/O=EMQ/OU=Broker/CN=Server"</span><br><span class="line">3.生成证书;</span><br><span class="line">openssl ca -config openssl.cnf -extensions v3_req -days 3650 -in EMQServer.csr -out EMQServer.pem  -cert IoTRootCA.pem -keyfile IoTRootCA.key</span><br></pre></td></tr></table></figure><h4 id="3-生成客户端证书"><a href="#3-生成客户端证书" class="headerlink" title="3. 生成客户端证书"></a>3. 生成客户端证书</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.生成客户端证书的私钥；</span><br><span class="line">openssl genrsa -out Client.key 2048</span><br><span class="line">2.根据私钥签发一个证书请求;</span><br><span class="line">openssl req -new -key Client.key -out Client.csr -subj "/C=CN/ST=Beijing/L=Beijing/O=ENN/OU=GZ24G/CN=GZ24GD001"</span><br><span class="line">3.生成证书;</span><br><span class="line">openssl x509 -req -CAserial IoTRootCA.srl -CAcreateserial  -in Client.csr -signkey Client.key -CA IoTRootCA.pem -CAkey IoTRootCA.key -out Client.pem -days 36500 -sha256</span><br></pre></td></tr></table></figure><h4 id="4-生成客户端公钥"><a href="#4-生成客户端公钥" class="headerlink" title="4. 生成客户端公钥"></a>4. 生成客户端公钥</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rsa -in Client.key -out client_pub.key -pubout</span><br></pre></td></tr></table></figure><h3 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、验证</h3><h4 id="1-验证CA根证书"><a href="#1-验证CA根证书" class="headerlink" title="1. 验证CA根证书"></a>1. 验证CA根证书</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl verify -CAfile IoTRootCA.pem IoTRootCA.pem</span><br></pre></td></tr></table></figure><h4 id="2-单向认证测试"><a href="#2-单向认证测试" class="headerlink" title="2. 单向认证测试"></a>2. 单向认证测试</h4><p>打开2个ssh会话窗口，第一个窗口执行第一个命令，第二个窗口执行第二个命令，查看Verify return code返回值。双向认证也是如此。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl s_server -accept 2009 -key EMQServer.key -cert EMQServer.pem</span><br><span class="line">openssl s_client -connect localhost:2009 -CAfile IoTRootCA.pem -showcerts</span><br><span class="line">结果：</span><br><span class="line">Verify return code: 0 (ok)</span><br></pre></td></tr></table></figure><h4 id="3-双向认证测试"><a href="#3-双向认证测试" class="headerlink" title="3. 双向认证测试"></a>3. 双向认证测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl s_server -accept 2009 -key EMQServer.key -cert EMQServer.pem -CAfile IoTRootCA.pem -Verify 1</span><br><span class="line">openssl s_client -connect localhost:2009 -key Client.key -cert Client.pem -CAfile IoTRootCA.pem -showcerts</span><br><span class="line">结果：</span><br><span class="line">Verify return code: 0 (ok)</span><br></pre></td></tr></table></figure><h3 id="四、术语"><a href="#四、术语" class="headerlink" title="四、术语"></a>四、术语</h3><ol><li>key通常指私钥。</li><li>CSR 是Certificate Signing Request的缩写，即证书签名申请，这不是证书，这是要求CA给证书签名的一种正式申请，该申请包含申请证书的实体的公钥及该实体店某些信息。该数据将成为证书的一部分。CSR始终使用它携带的公钥所对应的私钥进行签名。</li><li>CRT 即 certificate的缩写，即证书，可以将pem文件的后缀改为crt结尾，就可以看到证书。</li><li>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码；</li></ol><h3 id="五、自定义域名限制或者IP限制"><a href="#五、自定义域名限制或者IP限制" class="headerlink" title="五、自定义域名限制或者IP限制"></a>五、自定义域名限制或者IP限制</h3><p>打开<code>openssl.cnf</code>文件，找到subjectAltName，增加 <code>alt_names</code>。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[alt_names]</span><br><span class="line">DNS.1 = osw.uio.owsxxb.com</span><br><span class="line">IP.1 = 10.23.65.34</span><br><span class="line">IP.2 = 127.0.0.1</span><br></pre></td></tr></table></figure><p>添加成功后可以在生成客户端证书或者服务端证书看到。</p><h3 id="六、文献"><a href="#六、文献" class="headerlink" title="六、文献"></a>六、文献</h3><p><a href="https://www.openssl.org/" target="_blank" rel="noopener">OpenSsl 官网</a></p><p><a href="https://www.cnblogs.com/juanjuankaikai/p/11425598.html" target="_blank" rel="noopener">EMQ启用TLS双向认证</a></p><h3 id="七、FAQ"><a href="#七、FAQ" class="headerlink" title="七、FAQ"></a>七、FAQ</h3><ol><li>出现奇葩问题，可以更换emq服务器中的证书位置。</li><li>出现奇葩问题，可以清除缓存。</li></ol><h3 id="八、linux可执行sh文件"><a href="#八、linux可执行sh文件" class="headerlink" title="八、linux可执行sh文件"></a>八、linux可执行sh文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf /etc/pki/CA/*.old</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 删除证书索引库数据库文件</span></span></span><br><span class="line">rm -rf /etc/pki/CA/index.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 生成证书索引库数据库文件</span></span></span><br><span class="line">touch /etc/pki/CA/index.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 指定第一个颁发证书的序列号</span></span></span><br><span class="line">echo 01 &gt; /etc/pki/CA/serial</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">根证书</span></span><br><span class="line">openssl genrsa -out IoTRootCA.key 2048</span><br><span class="line">openssl req -x509 -new -key IoTRootCA.key -sha256 -days 3650 -subj "/C=CN/ST=Zhejiang/L=Hangzhou/O=EMQ/OU=Broker/CN=RootCA" -out IoTRootCA.pem -config openssl.cnf</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">服务器证书</span></span><br><span class="line">openssl genrsa -out EMQServer.key 2048</span><br><span class="line">openssl req -new  -days 3650 -key EMQServer.key -out EMQServer.csr -subj "/C=CN/ST=Zhejiang/L=Hangzhou/O=EMQ/OU=Broker/CN=Server"</span><br><span class="line">openssl ca -config openssl.cnf -extensions v3_req -days 3650 -in EMQServer.csr -out EMQServer.pem  -cert IoTRootCA.pem -keyfile IoTRootCA.key</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">客户端证书</span></span><br><span class="line">openssl genrsa -out Client.key 2048</span><br><span class="line">openssl req -new -key Client.key -out Client.csr -subj "/C=CN/ST=Beijing/L=Beijing/O=ENN/OU=GZ24G/CN=GZ24GD001"</span><br><span class="line">openssl x509 -req -CAserial IoTRootCA.srl -CAcreateserial  -in Client.csr -signkey Client.key -CA IoTRootCA.pem -CAkey IoTRootCA.key -out Client.pem -days 36500 -sha256</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">客户端公钥</span></span><br><span class="line">openssl rsa -in Client.key -out client_pub.key -pubout;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>mybatis基础上兼容mybatisPlus</title>
    <url>/post/bbfd51f8.html</url>
    <content><![CDATA[<blockquote><p>SpringBoot在原有使用 Mybatis 基础上兼容 MybatisPlus ~</p></blockquote><a id="more"></a><h3 id="一、Pom-引入-MybatisPlus依赖"><a href="#一、Pom-引入-MybatisPlus依赖" class="headerlink" title="一、Pom  引入 MybatisPlus依赖"></a>一、Pom 引入 MybatisPlus依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--兼容mybatis和mybatisPlus依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="二、继承MybatisPlus各层的依赖"><a href="#二、继承MybatisPlus各层的依赖" class="headerlink" title="二、继承MybatisPlus各层的依赖"></a>二、继承MybatisPlus各层的依赖</h3><p>service层、serviceImpl、dao层各自继承自带的封装好的Service CRUD 接口。</p><p>增加扫描配置文件：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/**/*.xml</span></span><br></pre></td></tr></table></figure><h3 id="三、官网"><a href="#三、官网" class="headerlink" title="三、官网"></a>三、官网</h3><p><a href="https://baomidou.com/" target="_blank" rel="noopener">https://baomidou.com/</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Mybatis批量插入优化</title>
    <url>/post/53b6cfac.html</url>
    <content><![CDATA[<blockquote><p>批量插入优化 ~</p></blockquote><a id="more"></a><h3 id="一、普通插入"><a href="#一、普通插入" class="headerlink" title="一、普通插入"></a>一、普通插入</h3><p>遍历 insert 语句，单条执行，效率低下，如果大批量数据累积插入，性能肯定会有问题。</p><h3 id="二、Foreach-优化插入"><a href="#二、Foreach-优化插入" class="headerlink" title="二、Foreach  优化插入"></a>二、Foreach 优化插入</h3><p>如果要优化插入速度时，可以将许多小型操作组合到一个大型操作中。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"batchInsert"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">    insert into table1 (field1, field2) values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"t"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span> </span><br><span class="line">        (#&#123;t.field1&#125;, #&#123;t.field2&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实际效果如下：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`table1`</span> (<span class="string">`field1`</span>, <span class="string">`field2`</span>) </span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">"data1"</span>, <span class="string">"data2"</span>),</span><br><span class="line">(<span class="string">"data1"</span>, <span class="string">"data2"</span>),</span><br><span class="line">(<span class="string">"data1"</span>, <span class="string">"data2"</span>),</span><br><span class="line">(<span class="string">"data1"</span>, <span class="string">"data2"</span>),</span><br><span class="line">(<span class="string">"data1"</span>, <span class="string">"data2"</span>);</span><br></pre></td></tr></table></figure><p><strong>Foreach 遇到数量大，性能瓶颈</strong></p><p>项目实践发现，当表的列数较多（超过20），以及一次性插入的行数较多（上万条）时，插入性能非常差，通常需要20分钟以上。</p><p><strong>如果需要使用 <code>foreach</code>来优化数据插入的话，需要将每次插入的记录控制在 10-100 左右是比较快的，建议每次100来分割数据，也就是<code>分而治之</code>思想。</strong></p><h3 id="三、Mybatis-plus-批量插入"><a href="#三、Mybatis-plus-批量插入" class="headerlink" title="三、Mybatis-plus 批量插入"></a>三、Mybatis-plus 批量插入</h3><p>Mybatis-Plus<code>为service层提供了</code>ServiceImpl<code>的实现类，可以直接</code>extends ServiceImpl&lt;mapper,object&gt;进行调用</p><p>里面有封装好的批量插入方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="keyword">int</span> batchSize)</span> </span>&#123;</span><br><span class="line">  String sqlStatement = <span class="keyword">this</span>.getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">  sqlSession.insert(sqlStatement, entity);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> SqlHelper.executeBatch(<span class="keyword">this</span>.entityClass, <span class="keyword">this</span>.log, list, batchSize, consumer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SqlHelper.executeBatch</code>的具体的实现如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="keyword">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> </span>&#123;</span><br><span class="line">        Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">"batchSize must not be less than one"</span>, <span class="keyword">new</span> Object[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, (sqlSession) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">int</span> idxLimit = Math.min(batchSize, size);</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(Iterator var7 = list.iterator(); var7.hasNext(); ++i) &#123;</span><br><span class="line">                E element = var7.next();</span><br><span class="line">                consumer.accept(sqlSession, element);</span><br><span class="line">                <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                    sqlSession.flushStatements();</span><br><span class="line">                    idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Consumer&lt;SqlSession&gt; consumer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SqlSessionFactory sqlSessionFactory = sqlSessionFactory(entityClass);</span><br><span class="line">            SqlSessionHolder sqlSessionHolder = (SqlSessionHolder)TransactionSynchronizationManager.getResource(sqlSessionFactory);</span><br><span class="line">            <span class="keyword">boolean</span> transaction = TransactionSynchronizationManager.isSynchronizationActive();</span><br><span class="line">            SqlSession sqlSession;</span><br><span class="line">            <span class="keyword">if</span> (sqlSessionHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sqlSession = sqlSessionHolder.getSqlSession();</span><br><span class="line">                sqlSession.commit(!transaction);</span><br><span class="line">            &#125;</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">            <span class="keyword">if</span> (!transaction) &#123;</span><br><span class="line">                log.warn(<span class="string">"SqlSession ["</span> + sqlSession + <span class="string">"] Transaction not enabled"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> var7;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                consumer.accept(sqlSession);</span><br><span class="line">                sqlSession.commit(!transaction);</span><br><span class="line">                var7 = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var15) &#123;</span><br><span class="line">                sqlSession.rollback();</span><br><span class="line">                Throwable unwrapped = ExceptionUtil.unwrapThrowable(var15);</span><br><span class="line">                <span class="keyword">if</span> (unwrapped <span class="keyword">instanceof</span> PersistenceException) &#123;</span><br><span class="line">                    MyBatisExceptionTranslator myBatisExceptionTranslator = <span class="keyword">new</span> MyBatisExceptionTranslator(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), <span class="keyword">true</span>);</span><br><span class="line">                    Throwable throwable = myBatisExceptionTranslator.translateExceptionIfPossible((PersistenceException)unwrapped);</span><br><span class="line">                    <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> throwable;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ExceptionUtils.mpe(unwrapped);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sqlSession.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> var7;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var17) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var17;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启 ExecutorType.BATCH 模式，经过试验，使用了 ExecutorType.BATCH 的插入方式，性能显著提升，不到 2s 便能全部插入完成。</p><h3 id="四、mybatis-设置-executorType-为-batch模式"><a href="#四、mybatis-设置-executorType-为-batch模式" class="headerlink" title="四、mybatis 设置 executorType 为 batch模式"></a>四、mybatis 设置 executorType 为 batch模式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">protected</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveOrder</span><span class="params">(Order t)</span> </span>&#123;</span><br><span class="line">	SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH);</span><br><span class="line">	OrderMapper orderMapper = sqlSession.getMapper(OrderMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		orderMapper.save(t);</span><br><span class="line">		sqlSession.commit();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		logger.error(<span class="string">"批量导入数据异常，事务回滚"</span>, e);</span><br><span class="line">		sqlSession.rollback();</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (sqlSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">	  		sqlSession.close();</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、springboot-下开启-batch模式"><a href="#五、springboot-下开启-batch模式" class="headerlink" title="五、springboot 下开启 batch模式"></a>五、springboot 下开启 batch模式</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">executor-type:</span> <span class="string">batch</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionTemplate <span class="title">sqlSessionTemplate</span><span class="params">(SqlSessionFactory sqlSessionFactory)</span> </span>&#123;</span><br><span class="line">        ExecutorType executorType = <span class="keyword">this</span>.properties.getExecutorType();</span><br><span class="line">        <span class="keyword">if</span> (executorType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory, executorType);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SqlSessionTemplate(sqlSessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>前端精度丢失-@JsonSerialize</title>
    <url>/post/9b061489.html</url>
    <content><![CDATA[<blockquote><p>Long 值超过前端 js 显示的长度范围时会导致前端回显错误 ~</p></blockquote><a id="more"></a><h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>Long 值超过前端 js 显示的长度范围时会导致前端回显错误。</p><h3 id="二、解决方案"><a href="#二、解决方案" class="headerlink" title="二、解决方案"></a>二、解决方案</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>直接定义成String类型，后端使用的时候转成Long类型</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p><code>入参：定义成Long，通过dataType制定类型</code><br><code>@ApiModelProperty(value = &quot;团队ID&quot;, dataType = &quot;java.lang.String&quot;)</code><br><code>private Long teamId;</code></p><p><code>出参：处理dataType之外，还需要定义JsonSerialize</code><br><code>@JsonSerialize(using = ToStringSerializer.class)</code><br><code>@ApiModelProperty(value = &quot;项目id&quot;, dataType = &quot;java.lang.String&quot;)</code><br><code>private Long projectId;</code></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>布隆过滤器</title>
    <url>/post/9a0369ec.html</url>
    <content><![CDATA[<blockquote><p>布隆过滤器介绍 ~</p></blockquote><a id="more"></a><h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位Bit数组中把对应下标的值置为 1。</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决哈希冲突的方式：</span><br><span class="line">1.线性探测，冲突后再次寻找空位置；</span><br><span class="line">2.多重散列，多次哈希函数计算；（布隆过滤器使用的这种）</span><br><span class="line">3.链表法，HsahMap；</span><br></pre></td></tr></table></figure><blockquote><p>PS：布隆过滤器的底层就是基于 BitMap 数据结构实现的。</p></blockquote><p>初始bit数组都为0，只加载两个数据为：人生和人力。将位置3，10，12，15，20置为1，已经加载的数据，也就是存在的数据就会返回true，不存在的返回false。</p><p><strong>但是当数据量特别大的时候，会有误报概率。</strong><br>就会出现下面的情况。未加载的数据：人生好。在哈希后也打在了3,12,20上，也返回了true。</p><p><strong>这也就是布隆过滤器的基本原理：存在不是一定存在，不存在就一定不存在。</strong></p><p><strong>如果布隆过滤器说一个元素不在集合中，那么它一定不在这个集合中；但如果它说一个元素在集合中，则有可能是不存在的（存在误差）。</strong></p><p>它就可以很好的用在黑名单这样的场景中，<strong>如果不在黑名单中就一定不在，相对的如果在的话不是一定在，而大部分数据都是不在的，黑名单中的毕竟只是少量数据。如果再通过具体业务数据验证。这样调用量就大大降低。</strong></p><p>除了用在黑名单中，我们在缓存穿透的场景中也可以适用。</p><p><code>缓存穿透是大量不存在的key绕过redis，进入DB中，导致系统压力过大。</code></p><h3 id="二、代码"><a href="#二、代码" class="headerlink" title="二、代码"></a>二、代码</h3><h4 id="1-本地布隆过滤器一般都是使用Google的guava"><a href="#1-本地布隆过滤器一般都是使用Google的guava" class="headerlink" title="1. 本地布隆过滤器一般都是使用Google的guava"></a>1. 本地布隆过滤器一般都是使用Google的guava</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>32.1.2-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BloomFilterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个预期插入数量为1000，误报概率为0.01的布隆过滤器</span></span><br><span class="line">        <span class="keyword">int</span> insertions = <span class="number">1000</span>;</span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), insertions &lt;&lt; <span class="number">1</span>, <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向布隆过滤器中添加元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            bloomFilter.put(<span class="string">"string"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查布隆过滤器中是否可能包含某个元素</span></span><br><span class="line">        <span class="keyword">int</span> falsePositiveCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1001</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(<span class="string">"string"</span> + i)) &#123;</span><br><span class="line">                falsePositiveCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"预期误报概率: 0.01"</span>);</span><br><span class="line">        System.out.println(<span class="string">"实际误报概率: "</span> + (<span class="keyword">double</span>) falsePositiveCount / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，将预期插入数量设置得比实际插入数量稍大一些是一个比较好的选择，因为这样可以在保持较低误报率的同时，不会过多地增加存储空间需求。</p><h4 id="2-Redis的布隆过滤器"><a href="#2-Redis的布隆过滤器" class="headerlink" title="2.Redis的布隆过滤器"></a>2.Redis的布隆过滤器</h4><p>需要<code>Redis服务</code>安装<code>RedisBloom</code>，才能支持。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.RedisBloom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>JRedisBloom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisBloomFilterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个Jedis连接池</span></span><br><span class="line">        JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        JedisPool jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个RedisBloom客户端</span></span><br><span class="line">        Client client = <span class="keyword">new</span> Client(jedisPool);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义布隆过滤器的名称</span></span><br><span class="line">        String bloomFilterName = <span class="string">"myBloomFilter"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用RedisBloom客户端创建一个布隆过滤器，预期插入数量为1000，误报概率为0.01</span></span><br><span class="line">        client.createFilter(bloomFilterName, <span class="number">1000</span>, <span class="number">0.01</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向布隆过滤器中添加元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            client.add(bloomFilterName, <span class="string">"string"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查布隆过滤器中是否可能包含某个元素</span></span><br><span class="line">        <span class="keyword">int</span> falsePositiveCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1001</span>; i &lt; <span class="number">2000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client.exists(bloomFilterName, <span class="string">"string"</span> + i)) &#123;</span><br><span class="line">                falsePositiveCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"预期误报概率: 0.01"</span>);</span><br><span class="line">        System.out.println(<span class="string">"实际误报概率: "</span> + (<span class="keyword">double</span>) falsePositiveCount / <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭连接池</span></span><br><span class="line">        jedisPool.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-Hutool的布隆过滤器"><a href="#3-Hutool的布隆过滤器" class="headerlink" title="3.Hutool的布隆过滤器"></a>3.<code>Hutool</code>的布隆过滤器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">BitMapBloomFilter filter = <span class="keyword">new</span> BitMapBloomFilter(<span class="number">10</span>);</span><br><span class="line">filter.add(<span class="string">"123"</span>);</span><br><span class="line">filter.add(<span class="string">"abc"</span>);</span><br><span class="line">filter.add(<span class="string">"ddd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找</span></span><br><span class="line">filter.contains(<span class="string">"abc"</span>)</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>MYSQL MyISAM插入慢问题解决</title>
    <url>/post/e4853862.html</url>
    <content><![CDATA[<blockquote><p><code>MySQL MyISAM</code>插入慢 ~</p></blockquote><a id="more"></a><h3 id="解决MySQL-MyISAM插入慢的问题"><a href="#解决MySQL-MyISAM插入慢的问题" class="headerlink" title="解决MySQL MyISAM插入慢的问题"></a>解决<code>MySQL MyISAM</code>插入慢的问题</h3><p>在使用<code>MySQL</code>数据库时，可能会遇到插入数据过慢的问题，特别是当表使用<code>MyISAM</code>引擎时。MyISAM是一种MySQL数据库引擎，虽然在某些情况下性能很好，但在插入大量数据时可能会出现性能下降的情况。本文将介绍如何解决<code>MySQL MyISAM</code>插入慢的问题，并提供一些代码示例。</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p><code>MySQL</code>的<code>MyISAM</code>引擎在插入大量数据时，会出现表锁定的情况，导致插入操作变慢。这是因为MyISAM引擎是表级锁定的，即在插入数据时会锁定整个表，其他操作必须等待插入操作完成后才能执行，从而导致性能下降。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li>使用<code>InnoDB</code>引擎<br>一个解决<code>MySQL MyISAM</code>插入慢的方法是将表的引擎从<code>MyISAM</code>改为<code>InnoDB</code>。<code>InnoDB</code>是<code>MySQL</code>的另一种引擎，它支持行级锁定，能够提高插入数据的性能。下面是一个示例代码，演示如何将表的引擎从<code>MyISAM</code>改为<code>InnoDB</code>：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>批量插入数据<br>另一个解决<code>MySQL MyISAM</code>插入慢的方法是使用批量插入数据的方式。通过一次性插入多条数据，可以减少表的锁定时间，提高插入数据的效率。下面是一个示例代码，演示如何批量插入数据：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2),</span><br><span class="line">       (value3, value4),</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure><ol start="3"><li>关闭自动提交<br>在插入大量数据时，可以考虑关闭<code>MySQL</code>的自动提交功能。在每次插入数据后手动提交事务，可以减少事务日志的写入，提高插入数据的性能。下面是一个示例代码，演示如何关闭自动提交：</li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> autocommit=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2) <span class="keyword">VALUES</span> (value1, value2);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Sql</category>
      </categories>
      <tags>
        <tag>Sql</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>offset和limit分页，性能太差！</title>
    <url>/post/ca74cc7d.html</url>
    <content><![CDATA[<blockquote><p>offset和limit分页，性能太差！</p></blockquote><a id="more"></a><p>如何实现高性能分页？</p><h3 id="1、OFFSET-和-LIMIT-有什么问题？"><a href="#1、OFFSET-和-LIMIT-有什么问题？" class="headerlink" title="1、OFFSET 和 LIMIT 有什么问题？"></a>1、OFFSET 和 LIMIT 有什么问题？</h3><p>OFFSET 和 LIMIT 对于数据量少的项目来说是没有问题的。</p><p><strong>但是，当数据库里的数据量超过服务器内存能够存储的能力，并且需要对所有数据进行分页，问题就会出现。</strong></p><p>为了实现分页，每次收到分页请求时，数据库都需要进行低效的全表扫描。</p><p><strong>什么是全表扫描？</strong></p><p>全表扫描 (又称顺序扫描) 就是在数据库中进行逐行扫描，顺序读取表中的每一行记录，然后检查各个列是否符合查询条件。这种扫描是已知最慢的，因为需要进行大量的磁盘 I/O，而且从磁盘到内存的传输开销也很大。</p><p>这意味着，如果你有 1 亿个用户，OFFSET 是 5 千万，那么它需要获取所有这些记录 (包括那么多根本不需要的数据)，将它们放入内存，然后获取 LIMIT 指定的 20 条结果。</p><p>也就是说，为了获取一页的数据：</p><p>10万行中的第5万行到第5万零20行</p><p>需要先获取 5 万行。这么做是多么低效？</p><p>这背后都发生了什么：OFFSET 越高，查询时间就越长。</p><h3 id="2、优化方案"><a href="#2、优化方案" class="headerlink" title="2、优化方案"></a>2、优化方案</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> limit_test <span class="keyword">WHERE</span> <span class="keyword">id</span>&gt;<span class="number">10</span> <span class="keyword">limit</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>这是一种基于指针的分页。</p><p>你要在本地保存上一次接收到的主键 (通常是一个 ID) 和 LIMIT，而不是 OFFSET 和 LIMIT，那么每一次的查询可能都与此类似。</p><p>为什么？因为通过显式告知数据库最新行，数据库就确切地知道从哪里开始搜索（基于有效的索引），而不需要考虑目标范围之外的记录。</p><p>要使用这种基于游标的分页，需要有一个惟一的序列字段 (或多个)，比如惟一的整数 ID 或时间戳，但在某些特定情况下可能无法满足这个条件。</p><h4 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h4><p>类似于查询 <code>SELECT * FROM table_name WHERE id &gt; 3400000 LIMIT 20;</code> 这样的效率非常快，因为主键上是有索引的，但是这样有个缺点，就是<strong>ID必须是连续的</strong>，并且查询不能有WHERE语句，因为WHERE语句会造成过滤数据。那使用场景就非常的局限了，于是我们可以这样：</p><p><strong>使用覆盖索引优化</strong></p><p>MySQL的查询完全命中索引的时候，称为覆盖索引,是非常快的，因为查询只需要在索引上进行查找，之后可以直接返回，而不用再回数据表拿数据。因此我们可以先查出索引的 ID，然后根据 Id 拿数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> table_name <span class="keyword">LIMIT</span> <span class="number">3400000</span>,<span class="number">20</span>) a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> table_name b <span class="keyword">ON</span> a.id = b.id;</span><br><span class="line"><span class="comment">#或者是</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name a <span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> table_name <span class="keyword">LIMIT</span> <span class="number">3400000</span>,<span class="number">20</span>) b <span class="keyword">USING</span> (<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><ul><li>数据量大的时候不能使用OFFSET/LIMIT来进行分页，因为OFFSET越大，查询时间越久。基于大量数据做查询操作，Rick James 的文章提供了更深入的指导。 <a href="http://mysql.rjweb.org/doc.php/lists" target="_blank" rel="noopener">http://mysql.rjweb.org/doc.php/lists</a></li><li>当然不能说所有的分页都不可以，如果你的数据就那么几千、几万条，那就很无所谓，随便使用。</li><li>如果我们的表没有主键，比如是具有多对多关系的表，那么就使用传统的 OFFSET/LIMIT 方式。</li><li>这种方法适用于要求ID为数值类型，并且查出的数据ID连续的场景且不能有其他字段的排序。</li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Spring Cache获取所有缓存数据</title>
    <url>/post/8a8dfd6b.html</url>
    <content><![CDATA[<blockquote><p>如何查询本地缓存的内容详情 ~</p></blockquote><a id="more"></a><p>简单粗暴，直接上代码~</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Log</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CacheManager cacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheController</span><span class="params">(CacheManager cacheManager)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cacheManager = cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"clearAllCaches"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">clearAllCaches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String cacheName : cacheManager.getCacheNames()) &#123;</span><br><span class="line">            Objects.requireNonNull(cacheManager.getCache(cacheName)).clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/getCacheValues"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;CacheEntry&gt;&gt; getCacheValues() &#123;</span><br><span class="line">        List&lt;CacheEntry&gt; cacheEntries = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String cacheName : cacheManager.getCacheNames()) &#123;</span><br><span class="line">            Cache cache = cacheManager.getCache(cacheName);</span><br><span class="line">            <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Map&lt;String, Object&gt; cacheMap = cacheToMap(cache);</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : cacheMap.entrySet()) &#123;</span><br><span class="line">                    Object key = entry.getKey();</span><br><span class="line">                    Object value = entry.getValue();</span><br><span class="line">                    cacheEntries.add(<span class="keyword">new</span> CacheEntry(cacheName, key, value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(cacheEntries);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">cacheToMap</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">        Object obj = cache.getNativeCache();</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Field[] fields = obj.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">                field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                map.put(field.getName(), field.get(obj));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"ObjToMap exp"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取Cache.map中的cache</span></span><br><span class="line">        <span class="keyword">return</span> (Map&lt;String, Object&gt;)map.get(<span class="string">"cache"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheEntry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cacheName;</span><br><span class="line">        <span class="keyword">private</span> Object key;</span><br><span class="line">        <span class="keyword">private</span> Object value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CacheEntry</span><span class="params">(String cacheName, Object key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.cacheName = cacheName;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>数据脱敏</title>
    <url>/post/abac9caf.html</url>
    <content><![CDATA[<blockquote><p>数据脱敏介绍 ~</p></blockquote><a id="more"></a><h3 id="一、SQL数据脱敏实现"><a href="#一、SQL数据脱敏实现" class="headerlink" title="一、SQL数据脱敏实现"></a>一、SQL数据脱敏实现</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- CONCAT()、LEFT()和RIGHT()字符串函数组合使用，请看下面具体实现</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- CONCAT(str1,str2,…)：返回结果为连接参数产生的字符串</span></span><br><span class="line"><span class="comment">-- LEFT(str,len)：返回从字符串str 开始的len 最左字符</span></span><br><span class="line"><span class="comment">-- RIGHT(str,len)：从字符串str 开始，返回最右len 字符</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 电话号码脱敏sql：</span></span><br><span class="line"><span class="keyword">SELECT</span> mobilePhone <span class="keyword">AS</span> 脱敏前电话,<span class="keyword">CONCAT</span>(<span class="keyword">LEFT</span>(mobilePhone,<span class="number">3</span>), <span class="string">'********'</span> ) <span class="keyword">AS</span> 脱敏后电话 <span class="keyword">FROM</span> <span class="keyword">user</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 身份证号码脱敏sql:</span></span><br><span class="line"><span class="keyword">SELECT</span> idcard <span class="keyword">AS</span> 未脱敏身份证, <span class="keyword">CONCAT</span>(<span class="keyword">LEFT</span>(idcard,<span class="number">3</span>), <span class="string">'****'</span> ,<span class="keyword">RIGHT</span>(idcard,<span class="number">4</span>)) <span class="keyword">AS</span> 脱敏后身份证号 <span class="keyword">FROM</span> <span class="keyword">user</span></span><br></pre></td></tr></table></figure><h3 id="二、JAVA数据脱敏实现"><a href="#二、JAVA数据脱敏实现" class="headerlink" title="二、JAVA数据脱敏实现"></a>二、JAVA数据脱敏实现</h3><p>可参考：海强 / sensitive-plus</p><blockquote><p><a href="https://gitee.com/strong_sea/sensitive-plus" target="_blank" rel="noopener">https://gitee.com/strong_sea/sensitive-plus</a></p></blockquote><p>数据脱敏插件，目前支持地址脱敏、银行卡号脱敏、中文姓名脱敏、固话脱敏、身份证号脱敏、手机号脱敏、密码脱敏 一个是正则脱敏、另外一个根据显示长度脱敏，默认是正则脱敏，可以根据自己的需要配置自己的规则。</p><h3 id="三、mybatis-mate-sensitive-jackson"><a href="#三、mybatis-mate-sensitive-jackson" class="headerlink" title="三、mybatis-mate-sensitive-jackson"></a>三、mybatis-mate-sensitive-jackson</h3><p>mybatisplus 的新作，可以测试使用，生产需要收费。根据定义的策略类型，对数据进行脱敏，当然策略可以自定义。</p><p><a href="https://gitee.com/baomidou/mybatis-mate-examples/tree/master/mybatis-mate-sensitive-jackson" target="_blank" rel="noopener">mybatis-mate-sensitive-jackson</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>多线程异步任务的几种方式</title>
    <url>/post/18cb4f97.html</url>
    <content><![CDATA[<blockquote><p>多线程异步任务的几种方式介绍 ~</p></blockquote><a id="more"></a><h3 id="一、线程-Thread"><a href="#一、线程-Thread" class="headerlink" title="一、线程 Thread"></a>一、线程 Thread</h3><ol><li><p>创建类并 <strong>继承Thread</strong> 或者 <strong>实现 Runnable</strong> 再或者 <strong>实现 Callable 接口</strong> 接口实现。</p></li><li><p>采用线程池，可以将业务逻辑封装到Runnable或Callable中，交由线程池来执行。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory namedThreadFactory =</span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">"thread-call-runner-%d"</span>).build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executorService =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>, <span class="number">20</span>, <span class="number">200L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(), namedThreadFactory);</span><br><span class="line"><span class="comment">// 开启新的线程执行任务</span></span><br><span class="line">executorService.submit(() -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="二、经典的Future"><a href="#二、经典的Future" class="headerlink" title="二、经典的Future"></a>二、经典的Future</h3><p>Java 从1.5版本开始，提供了 Callable 和 Future，可以在任务执行完毕之后得到任务执行结果。但是有不足之处：</p><ol><li><strong>无法被动接收异步任务的计算结果：</strong>虽然我们可以主动将异步任务提交给线程池中的线程来执行，但是待异步任务执行结束之后，主线程无法得到任务完成与否的通知，它需要通过get方法主动获取任务执行的结果。</li><li><strong>Future件彼此孤立：</strong>有时某一个耗时很长的异步任务执行结束之后，你想利用它返回的结果再做进一步的运算，该运算也会是一个异步任务，两者之间的关系需要程序开发人员手动进行绑定赋予，Future并不能将其形成一个任务流（pipeline），每一个Future都是彼此之间都是孤立的，所以才有了后面的<code>CompletableFuture</code>，<code>CompletableFuture</code>就可以将多个Future串联起来形成任务流。</li><li><strong>Futrue没有很好的错误处理机制：</strong>截止目前，如果某个异步任务在执行发的过程中发生了异常，调用者无法被动感知，必须通过捕获get方法的异常才知晓异步任务执行是否出现了错误，从而在做进一步的判断处理。</li></ol><h3 id="三、CompletableFuture实现异步"><a href="#三、CompletableFuture实现异步" class="headerlink" title="三、CompletableFuture实现异步"></a>三、<code>CompletableFuture</code>实现异步</h3><p>Java 从1.8版本开始，开始支持<code>CompletableFuture</code>实现异步，可以解决<code>Future</code> 的这些缺陷。<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了运行多个 <code>CompletableFuture</code>、函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><h3 id="四、Spring的-Async异步"><a href="#四、Spring的-Async异步" class="headerlink" title="四、Spring的@Async异步"></a>四、Spring的<code>@Async</code>异步</h3><p><strong>（1）自定义异步线程池</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池参数配置，多个线程池实现线程池隔离，<span class="doctag">@Async</span>注解，默认使用系统自定义线程池，可在项目中设置多个线程池，在异步调用的时候，指明需要调用的线程池名称，比如：<span class="doctag">@Async</span>("taskName")</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">taskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回可用处理器的Java虚拟机的数量 12</span></span><br><span class="line">        <span class="keyword">int</span> i = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        System.out.println(<span class="string">"系统最大线程数  ："</span> + i);</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        <span class="comment">//核心线程池大小</span></span><br><span class="line">        executor.setCorePoolSize(<span class="number">16</span>);</span><br><span class="line">        <span class="comment">//最大线程数</span></span><br><span class="line">        executor.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">        <span class="comment">//配置队列容量，默认值为Integer.MAX_VALUE</span></span><br><span class="line">        executor.setQueueCapacity(<span class="number">99999</span>);</span><br><span class="line">        <span class="comment">//活跃时间</span></span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//线程名字前缀</span></span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"asyncServiceExecutor -"</span>);</span><br><span class="line">        <span class="comment">//设置此执行程序应该在关闭时阻止的最大秒数，以便在容器的其余部分继续关闭之前等待剩余的任务完成他们的执行</span></span><br><span class="line">        executor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        <span class="comment">//等待所有的任务结束后再关闭线程池</span></span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2） <code>AsyncService</code></strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function">MessageResult <span class="title">sendSms</span><span class="params">(String callPrefix, String mobile, String actionType, String content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncServiceImpl</span> <span class="keyword">implements</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IMessageHandler mesageHandler;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageResult <span class="title">sendSms</span><span class="params">(String callPrefix, String mobile, String actionType, String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            mesageHandler.sendSms(callPrefix, mobile, actionType, content);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"发送短信异常 -&gt; "</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Spring-ApplicationEvent事件实现异步"><a href="#五、Spring-ApplicationEvent事件实现异步" class="headerlink" title="五、Spring ApplicationEvent事件实现异步"></a>五、<code>Spring ApplicationEvent</code>事件实现异步</h3><p><strong>（1）定义事件</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSendEmailEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮箱</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主题</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String subject;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内容</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收者</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">private</span> String targetUserId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）定义事件处理器</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSendEmailEventHandler</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">AsyncSendEmailEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IMessageHandler mesageHandler;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Async</span>(<span class="string">"taskExecutor"</span>)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(AsyncSendEmailEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String email = event.getEmail();</span><br><span class="line">        String subject = event.getSubject();</span><br><span class="line">        String content = event.getContent();</span><br><span class="line">        String targetUserId = event.getTargetUserId();</span><br><span class="line">        mesageHandler.sendsendEmailSms(email, subject, content, targerUserId);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、hutool-的ThreadUtil异步工具类"><a href="#六、hutool-的ThreadUtil异步工具类" class="headerlink" title="六、hutool 的ThreadUtil异步工具类"></a>六、<code>hutool</code> 的<code>ThreadUtil</code>异步工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            ThreadUtil.execAsync(() -&gt; &#123;</span><br><span class="line">                ThreadLocalRandom threadLocalRandom = ThreadLocalRandom.current();</span><br><span class="line">                <span class="keyword">int</span> number = threadLocalRandom.nextInt(<span class="number">20</span>) + <span class="number">1</span>;</span><br><span class="line">                System.out.println(number);</span><br><span class="line">            &#125;);</span><br><span class="line">            log.info(<span class="string">"当前第："</span> + i + <span class="string">"个线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"task finish!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、Guava异步"><a href="#七、Guava异步" class="headerlink" title="七、Guava异步"></a>七、Guava异步</h3><p>Guava的 <code>ListenableFuture</code> 顾名思义就是可以监听的Future，是对java原生Future的扩展增强。我们知道Future表示一个异步计算任务，当任务完成时可以得到计算结果。如果我们希望一旦计算完成就拿到结果展示给用户或者做另外的计算，就必须使用另一个线程不断的查询计算状态。这样做，代码复杂，而且效率低下。使用「Guava <code>ListenableFuture</code>」可以帮我们检测Future是否完成了，不需要再通过 get() 方法苦苦等待异步的计算结果，如果完成就自动调用回调函数，这样可以减少并发程序的复杂度。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ListeningExecutorService executorService = MoreExecutors.listeningDecorator(Executors.newCachedThreadPool());</span><br><span class="line">        <span class="keyword">final</span> ListenableFuture&lt;Integer&gt; listenableFuture = executorService.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                log.info(<span class="string">"callable execute..."</span>)</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Futures.addCallback(listenableFuture, <span class="keyword">new</span> FutureCallback&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Integer result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//成功执行...</span></span><br><span class="line">        System.out.println(<span class="string">"Get listenable future's result with callback "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//异常情况处理...</span></span><br><span class="line">        t.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, executorService);</span><br></pre></td></tr></table></figure><h3 id="八、京东asyncTool"><a href="#八、京东asyncTool" class="headerlink" title="八、京东asyncTool"></a>八、京东<code>asyncTool</code></h3><p>见官网： <a href="https://gitee.com/jd-platform-opensource/asyncTool" target="_blank" rel="noopener">asyncTool</a></p><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li><a href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html" target="_blank" rel="noopener">CompletableFuture 原理与实践-外卖商家端 API 的异步化 - 美团技术团队</a></li><li><a href="https://mp.weixin.qq.com/s/32Ak-WFLynQfpn0Cg0N-0A" target="_blank" rel="noopener">读 RocketMQ 源码，学习并发编程三大神器 - 勇哥 java 实战分享</a></li></ul><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>时间戳批次计算算法</title>
    <url>/post/f3a01f01.html</url>
    <content><![CDATA[<blockquote><p>时间戳批次计算算法 ~</p></blockquote><a id="more"></a><blockquote class="pullquote mindmap mindmap-lg"><ul><li>时间戳批次计算算法<ul><li>公式<ul><li>数据上报时间批次号 = 时间戳 / 存储周期</li></ul></li><li>理解<ul><li>时间戳和存储周期都是以秒为单位，那么”数据上报时间批次号”的值表示该数据上报属于时间划分后的哪个时间段。</li></ul></li><li>举例<ul><li>① 假如时间戳为：1705483754（2024-01-17 17:29:14），存储周期为300秒，那么数据上报时间批次号 1705483754/300 大约等于 5684946。这个结果表示该数据上报属于第 5684946个 300秒 的时间段。</li><li>② 假如时间戳为：1705483874（2024-01-17 17:31:14），存储周期为300秒，那么数据上报时间批次号 1705483874/300 大约等于 5684946。这个结果表示该数据上报属于第 5684946个 300秒 的时间段。</li><li>③ 假如时间戳为：1705484085（2024-01-17 17:34:45），存储周期为300秒，那么数据上报时间批次号 1705484085/300 大约等于 5684947。这个结果表示该数据上报属于第 5684947个 300秒 的时间段。</li></ul></li><li>结果<ul><li>等到第②步的时候，表示在同一个批次里面。等到第③步的时候，表示不在同一个批次里面。</li></ul></li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Spring-Kafka —— Ack机制和手动提交分析总结</title>
    <url>/post/fe9f8905.html</url>
    <content><![CDATA[<blockquote><p>spring-kafka AckMode模式，及手动提交offset。</p></blockquote><a id="more"></a><h3 id="一、Ack配置"><a href="#一、Ack配置" class="headerlink" title="一、Ack配置"></a>一、Ack配置</h3><blockquote><p>spring for kafka的consumer在spring.kafka.consumer.enable-auto-commit是false情况下，AckMode的选项，及手动提交offset。</p></blockquote><p>Kafka 生产者的 ACK 机制指的是生产者在发送消息后，对消息副本的确认机制。ACK 机制可以帮助生产者确保消息被成功写入 Kafka 集群中的多个副本，并在需要时获取确认信息。</p><p>Kafka 提供了三种 ACK 机制的配置选项，分别是：</p><ol><li><p>acks=0：生产者在成功将消息发送到网络缓冲区后即视为消息已被提交，不等待任何服务器响应。这种配置下，可能会出现消息丢失的情况。</p></li><li><p>acks=1：生产者在成功将消息发送到主题的分区 leader 后即视为消息已被提交。这种配置下，生产者会收到分区 leader<br>的确认，但仍有可能出现消息丢失的情况，例如当 leader 出现故障，而消息尚未复制到其他副本时。</p></li><li><p>acks=all 或acks=-1：生产者需要等待所有分区副本都成功写入消息后才视为消息已被提交。这种配置下，生产者会等待所有分区副本的确认，确保消息被复制到足够数量的副本后才返回提交确认。这是最安全的确认方式，但也会导致较长的等待时间。</p></li></ol><p>在实际使用中，根据对消息可靠性和延迟的要求，可以选择不同的 ACKs 级别。<strong>一般来说，如果对消息的可靠性要求较高，可以选择较高的 ACKs 级别，但需要考虑相应的延迟成本。</strong></p><h3 id="二、AckMode模式"><a href="#二、AckMode模式" class="headerlink" title="二、AckMode模式"></a>二、AckMode模式</h3><ol><li><p>RECORD：当每一条记录被消费者监听器（ListenerConsumer）处理之后提交<br>当使用 RECORD 确认模式时，消息监听容器会在每个消息被单独处理后进行确认。这意味着，如果一条消息被成功处理，它将作为单独的记录进行确认；如果处理失败，也会针对该消息进行错误记录。这种确认模式适用于需要精确处理每个消息的应用场景，例如确保每个消息都被正确处理。</p></li><li><p>BATCH：当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后提交<br>当使用 BATCH 确认模式时，消息监听容器会在批量处理一组消息后进行确认。这意味着，消息监听容器会将多个消息合并为批次，并将它们作为一组进行处理。只有在整个批次都被成功处理后，该批次的所有消息才会被确认。这种确认模式适用于需要提高处理效率的场景，例如批量处理大量消息以减少网络传输和系统调用的开销。</p></li><li><p>TIME：当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，距离上次提交时间大于TIME时提交</p></li><li><p>COUNT：当每一批poll()的数据被消费者监听器（ListenerConsumer）处理之后，被处理record数量大于等于COUNT时提交</p></li><li><p>COUNT_TIME：TIME或COUNT 有一个条件满足时提交</p></li><li><p>MANUAL：这是手动确认模式，消费者需要显式地调用 Acknowledgment.acknowledge() 方法来确认消息。只有当消费者调用 acknowledge() 方法后，才会向 Kafka 服务器发送确认消息。这种模式可以保证消息的可靠性和顺序性，但需要消费者显式地处理确认逻辑。</p></li><li><p>MANUAL_IMMEDIATE：这是立即手动确认模式，与 MANUAL 模式类似，但消费者在调用 acknowledge() 方法时，会立即向 Kafka 服务器发送确认消息。这种模式可以提高消息处理的速度，但可能会增加重复消费的风险。</p></li></ol><blockquote><p>MANUAL和MANUAL_IMMEDIATE的区别？</p><ol><li><p>MANUAL 和 MANUAL_IMMEDIATE 都是 Kafka 消费者的手动确认模式，它们的区别在于确认的时机不同。</p></li><li><p>MANUAL 模式下，消费者需要显式地调用 Acknowledgment.acknowledge() 方法来确认消息，在调用该方法之后，消息才会被标记为已消费，并且确认消息会在下次 poll() 时发送到 Kafka 服务器。这种模式的优点是可以保证消息的可靠性和顺序性，但需要消费者显式地处理确认逻辑。</p></li></ol><p>相比之下，MANUAL_IMMEDIATE 模式下，在消费者调用 Acknowledgment.acknowledge() 方法时，会立即向 Kafka 服务器发送确认消息。这种模式可以提高消息处理的速度，但可能会增加重复消费的风险，因为如果消息处理失败，Kafka 不会再次发送该消息，而是认为该消息已经被成功消费了。</p></blockquote><p><strong>在实际使用中，应根据业务需求和性能要求来选择合适的确认模式。如果要求消息的可靠性和顺序性比较高，可以选择 MANUAL 模式；如果要求处理速度比较高，可以选择 MANUAL_IMMEDIATE 模式。</strong></p><h3 id="三、手动提交"><a href="#三、手动提交" class="headerlink" title="三、手动提交"></a>三、手动提交</h3><p>kafka默认是自动提交ack的，很多时候，我们都需要手动提交，这就要进行以下配置</p><p>1、设置enable-auto-commit=false，禁止自动提交<br>2、设置ack-mode为manual_immediate</p><p>在配置文件进行如下配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.kafka.consumer.enable-auto-commit</span> = <span class="string">false</span></span><br><span class="line"><span class="meta">spring.kafka.listener.ack-mode</span> = <span class="string">manual_immediate</span></span><br></pre></td></tr></table></figure><p>3、监听方法的入参加入Acknowledgment ack 参数，并在消费完成之后调用acknowledge方法，如下所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@KafkaListener</span>(topics = <span class="string">"主题"</span>,groupId = <span class="string">"组ID"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">receiveMessage2</span><span class="params">(String message, Acknowledgment ack)</span></span>&#123;</span><br><span class="line">    log.info(<span class="string">"消费消息："</span> + message);</span><br><span class="line">    <span class="comment">//ack确认</span></span><br><span class="line">    ack.acknowledge();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Redis Lettuce 大坑！</title>
    <url>/post/1634bc5d.html</url>
    <content><![CDATA[<blockquote><p>Redis Lettuce 大坑！ ~</p></blockquote><a id="more"></a><h3 id="一、错误日志"><a href="#一、错误日志" class="headerlink" title="一、错误日志"></a>一、错误日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.springframework.dao.QueryTimeoutException: Redis command timed out; nested exception is io.lettuce.core.RedisCommandTimeoutException: io.lettuce.core.RedisCommandTimeoutException: Command timed out after <span class="number">3</span> second(s)</span><br></pre></td></tr></table></figure><h3 id="二、原因分析"><a href="#二、原因分析" class="headerlink" title="二、原因分析"></a>二、原因分析</h3><p><code>spring boot2.x</code>版本默认<code>redis</code>连接池为lettuce，拿到一个已经断开的<code>Redis</code>连接，所以一直会超时，而且 <strong>Lettuce</strong> 也没有自动重连。而以前的<code>jedis</code>是没有此问题的。</p><h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><h4 id="1-放弃使用lettuce，使用Jedis。"><a href="#1-放弃使用lettuce，使用Jedis。" class="headerlink" title="1.放弃使用lettuce，使用Jedis。"></a>1.放弃使用lettuce，使用<code>Jedis</code>。</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- jedis客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- spring2.X集成redis所需common-pool2，使用jedis必须依赖它--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">redis:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">jedis:</span></span><br><span class="line">   <span class="attr">pool:</span></span><br><span class="line">    <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#连接池的最大数据库连接数。设为0表示无限制</span></span><br><span class="line">    <span class="attr">max-wait:</span> <span class="number">-1</span> <span class="comment">#最大建立连接等待时间。如果超过此时间将接到异常。设为-1表示无限制。</span></span><br><span class="line">    <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment">#最大空闲数</span></span><br><span class="line">    <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">#redis 连接超时时间ms</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10000</span></span><br><span class="line">  <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">password:</span></span><br></pre></td></tr></table></figure><h4 id="2-加入定时心跳，保活。"><a href="#2-加入定时心跳，保活。" class="headerlink" title="2.加入定时心跳，保活。"></a>2.加入定时心跳，保活。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionCommands;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisScheduleTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisScheduleTask</span><span class="params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 minutes</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">60000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"ping redis"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        redisTemplate.execute(RedisConnectionCommands::ping);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>Spring事务：提交事务之后执行其他操作</title>
    <url>/post/f9b392b4.html</url>
    <content><![CDATA[<blockquote><p>Spring提交事务之后执行其他操作 ~</p></blockquote><a id="more"></a><h3 id="一、场景说明"><a href="#一、场景说明" class="headerlink" title="一、场景说明"></a>一、场景说明</h3><p>在 <code>service1</code>中往数据库中新插入了一条数据，同时在这个 <code>service1</code> 中调用了另外一个异步方法，在异步方法中需要查询刚刚 <code>service1</code>中新插入的数据，发现查询不到。</p><h3 id="二、解决思路"><a href="#二、解决思路" class="headerlink" title="二、解决思路"></a>二、解决思路</h3><p>让<code>service1</code>方法事务提交之后，再调用异步方法（事务提交之后执行其他操作）</p><h3 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h3><h4 id="方式一（推荐使用）"><a href="#方式一（推荐使用）" class="headerlink" title="方式一（推荐使用）"></a>方式一（推荐使用）</h4><p>使用 <code>TransactionSynchronizationManager</code> 注册回调Spring 提供的 <code>TransactionSynchronizationManager</code> 可以帮助在事务提交后执行某个操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册事务同步回调，在事务提交后发送消息</span></span><br><span class="line"><span class="keyword">if</span> (TransactionSynchronizationManager.isActualTransactionActive()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 事务提交后执行其他操作</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(<span class="keyword">int</span> status)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 执行完成后, 可以是提交 也可以是回滚</span></span><br><span class="line">                    <span class="keyword">if</span> (status == TransactionSynchronization.STATUS_ROLLED_BACK) &#123;</span><br><span class="line">                        log.info(<span class="string">"=============!回滚==================="</span>);</span><br><span class="line">                        <span class="comment">// do</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionSynchronizationAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.support.TransactionSynchronizationManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事务工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在事务提交后同步执行</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterCommitSyncExecute</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    runnable.run();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在事务提交后异步执行</span></span><br><span class="line"><span class="comment">     * ScheduledExecutorService executorService = new ScheduledThreadPoolExecutor(5,</span></span><br><span class="line"><span class="comment">     *         new ThreadFactoryBuilder().setDaemon(false).setNamePrefix("execApiCache").build());</span></span><br><span class="line"><span class="comment">     *         </span></span><br><span class="line"><span class="comment">     *  Ps：setDaemon(false) 注意这里守护线程标记必须设置为 false，否则主线程执行完，异步线程没执行完的话，异步线程会马上被中断、关闭，所以这里不能设置* 成守护（用户）线程。</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterCommitAsyncExecute</span><span class="params">(Executor executor, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">            TransactionSynchronizationManager.registerSynchronization(<span class="keyword">new</span> TransactionSynchronizationAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCommit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    executor.execute(runnable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用案例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Service</span></span></span><br><span class="line"><span class="comment">     * public class UserService &#123;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     <span class="doctag">@Autowired</span></span></span><br><span class="line"><span class="comment">     *     private UserMapper userMapper;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     <span class="doctag">@Transactional</span>(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="comment">     *     public void add(User user)&#123;</span></span><br><span class="line"><span class="comment">     *         userMapper.insert(user);</span></span><br><span class="line"><span class="comment">     *         TransactionUtils.afterCommitSyncExecute(()-&gt;&#123;</span></span><br><span class="line"><span class="comment">     *             System.out.println("事务提交后执行的方法");</span></span><br><span class="line"><span class="comment">     *         &#125;);</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>使用 <code>@TransactionalEventListener</code> 结合 Spring事件监听机制，将发送消息的逻辑解耦，并确保事件只在事务提交后被处理。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务Service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span>  ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userDao.save(user);</span><br><span class="line">        <span class="comment">// 注册事件</span></span><br><span class="line">        applicationEventPublisher.publishEvent(<span class="keyword">new</span> SavedUserEvent(user.getId()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存用户事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SavedUserEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userId;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavedUserEvent</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// getter and setter</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件侦听，处理对应事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">FooEventListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MailService mailService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">sendEmail</span><span class="params">(SavedUserEvent savedUserEvent)</span> </span>&#123;</span><br><span class="line">        User user = userDao.get(userId);</span><br><span class="line">        String email = user.getEmail();</span><br><span class="line">        mailService.send(email);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、资料"><a href="#四、资料" class="headerlink" title="四、资料"></a>四、资料</h3><p><a href="https://blog.csdn.net/weixin_43911286/article/details/118314291" target="_blank" rel="noopener">《Spring事务提交之后，再进行其他操作》</a><br><a href="https://blog.csdn.net/Dream_Weave/article/details/109366633?utm_source=miniapp_weixin" target="_blank" rel="noopener">《Spring - TransactionalEventListener 解决事务未提交读取不到数据问题》</a><br><a href="https://www.jyoryo.com/archives/155.html" target="_blank" rel="noopener">《Spring 事务事件控制 解决业务异步操作解耦》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>简单版本-动态线程池</title>
    <url>/post/2a3700fd.html</url>
    <content><![CDATA[<blockquote><p>动态线程池 ~</p></blockquote><a id="more"></a><h3 id="一、基于Apollo实现简单版本"><a href="#一、基于Apollo实现简单版本" class="headerlink" title="一、基于Apollo实现简单版本"></a>一、基于Apollo实现简单版本</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.Inet4Address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.NetworkInterface;</span><br><span class="line"><span class="keyword">import</span> java.util.Enumeration;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.task.TaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.ctrip.framework.apollo.model.ConfigChange;</span><br><span class="line"><span class="keyword">import</span> com.ctrip.framework.apollo.model.ConfigChangeEvent;</span><br><span class="line"><span class="keyword">import</span> com.ctrip.framework.apollo.spring.annotation.ApolloConfigChangeListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.ObjectUtil;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态线池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXECUTOR_POOL = <span class="string">"calItemExecutor"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXECUTOR_POOL_MAX_SIZE = <span class="string">"task.thread.pool.max.size"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXECUTOR_POOL_CORE_SIZE = <span class="string">"task.thread.pool.core.size"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String serverIp = getIpAddress();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, ThreadPoolTaskExecutor&gt; threadPoolMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务计算项线程池</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 业务计算项线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"calItemExecutor"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TaskExecutor <span class="title">calItemExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor taskExecutor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        taskExecutor.setCorePoolSize(<span class="number">3</span>);</span><br><span class="line">        taskExecutor.setMaxPoolSize(<span class="number">15</span>);</span><br><span class="line">        taskExecutor.setQueueCapacity(<span class="number">2000</span>);</span><br><span class="line">        taskExecutor.setKeepAliveSeconds(<span class="number">0</span>);</span><br><span class="line">        taskExecutor.setThreadNamePrefix(<span class="string">"calItemExecutor--"</span>);</span><br><span class="line">        taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        taskExecutor.setAwaitTerminationSeconds(<span class="number">60</span>);</span><br><span class="line">        taskExecutor.initialize();</span><br><span class="line">        threadPoolMap.put(<span class="string">"calItemExecutor"</span>, taskExecutor);</span><br><span class="line">        <span class="keyword">return</span> taskExecutor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">10000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledFixedRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadPoolMap.forEach(</span><br><span class="line">            (k, threadPoolExecutor) -&gt; threadPoolStatus(threadPoolExecutor.getThreadPoolExecutor(), k, <span class="string">"定时监控"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 监听apollo中application命名空间下，task.thread.pool前缀相关的线程池配置</span></span><br><span class="line"><span class="comment">     *  task.thread.pool.max.size = 5 task.thread.pool.core.size = 2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  2. 实现线程池核心参数修改接收，调用线程池参数动态修改方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> changeEvent 配置文件变化事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ApolloConfigChangeListener</span>(value = <span class="string">"application"</span>, interestedKeyPrefixes = <span class="string">"task.thread.pool"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(ConfigChangeEvent changeEvent)</span> </span>&#123;</span><br><span class="line">        changeCalItemThreadPool(changeEvent, EXECUTOR_POOL, EXECUTOR_POOL_MAX_SIZE, EXECUTOR_POOL_CORE_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeCalItemThreadPool</span><span class="params">(ConfigChangeEvent changeEvent, String threadPoolKey, String maxKey,</span></span></span><br><span class="line"><span class="function"><span class="params">        String coreKey)</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; changedKeys = changeEvent.changedKeys();</span><br><span class="line">        <span class="keyword">if</span> (changedKeys.contains(maxKey) || changedKeys.contains(coreKey)) &#123;</span><br><span class="line">            ThreadPoolTaskExecutor threadPoolTaskExecutor = threadPoolMap.get(threadPoolKey);</span><br><span class="line">            <span class="keyword">boolean</span> flag = Boolean.FALSE;</span><br><span class="line">            <span class="keyword">int</span> max = threadPoolTaskExecutor.getMaxPoolSize();</span><br><span class="line">            <span class="keyword">int</span> core = threadPoolTaskExecutor.getCorePoolSize();</span><br><span class="line">            ConfigChange maxChange = changeEvent.getChange(maxKey);</span><br><span class="line">            Integer maxUpdate = update(maxChange);</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtil.isNotNull(maxUpdate)) &#123;</span><br><span class="line">                flag = Boolean.TRUE;</span><br><span class="line">                max = maxUpdate;</span><br><span class="line">            &#125;</span><br><span class="line">            ConfigChange coreChange = changeEvent.getChange(coreKey);</span><br><span class="line">            Integer coreUpdate = update(coreChange);</span><br><span class="line">            <span class="keyword">if</span> (ObjectUtil.isNotNull(coreUpdate)) &#123;</span><br><span class="line">                flag = Boolean.TRUE;</span><br><span class="line">                core = coreUpdate;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; max &gt;= core) &#123;</span><br><span class="line">                dynamicModifyExecutor(core, max, threadPoolKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"当前线程池调整未生效, 请检查配置!, ip:&#123;&#125;,threadNamePrefix：&#123;&#125;"</span>, serverIp, threadPoolKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Integer <span class="title">update</span><span class="params">(ConfigChange coreChange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isNotNull(coreChange)) &#123;</span><br><span class="line">            Integer newValue =</span><br><span class="line">                ObjectUtil.isNotNull(coreChange.getNewValue()) ? Integer.parseInt(coreChange.getNewValue()) : <span class="keyword">null</span>;</span><br><span class="line">            Integer oldValue =</span><br><span class="line">                ObjectUtil.isNotNull(coreChange.getOldValue()) ? Integer.parseInt(coreChange.getOldValue()) : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (!ObjectUtil.equals(newValue, oldValue)) &#123;</span><br><span class="line">                <span class="keyword">return</span> newValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池参数动态修改</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> corePoolSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxPoolSize</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nameThreadFactoryPrefix</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dynamicModifyExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maxPoolSize, String nameThreadFactoryPrefix)</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = threadPoolMap.get(nameThreadFactoryPrefix);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = threadPoolTaskExecutor.getThreadPoolExecutor();</span><br><span class="line">        threadPoolStatus(threadPoolExecutor, nameThreadFactoryPrefix, <span class="string">"changer before"</span>);</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(corePoolSize);</span><br><span class="line">        threadPoolExecutor.setMaximumPoolSize(maxPoolSize);</span><br><span class="line">        threadPoolExecutor.prestartAllCoreThreads();</span><br><span class="line">        threadPoolStatus(threadPoolExecutor, nameThreadFactoryPrefix, <span class="string">"changer after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印线程池状态</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadPoolExecutor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> threadNamePrefix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tag</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">threadPoolStatus</span><span class="params">(ThreadPoolExecutor threadPoolExecutor, String threadNamePrefix, String tag)</span> </span>&#123;</span><br><span class="line">        ThreadPoolTaskExecutor threadPoolTaskExecutor = threadPoolMap.get(threadNamePrefix);</span><br><span class="line">        <span class="keyword">if</span> (threadPoolTaskExecutor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            threadPoolExecutor = threadPoolTaskExecutor.getThreadPoolExecutor();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LinkedBlockingQueue queue = (LinkedBlockingQueue)threadPoolExecutor.getQueue();</span><br><span class="line">        log.info(</span><br><span class="line">            <span class="string">"统计线程池状态[&#123;&#125;], ip:&#123;&#125;,threadNamePrefix：&#123;&#125;, 核心线程数:&#123;&#125;, 最大线程数:&#123;&#125;, 活跃线程数：&#123;&#125;, 排队线程数：&#123;&#125;,队列大小：&#123;&#125;, getTaskCount:&#123;&#125;,getCompletedTaskCount:&#123;&#125;,getLargestPoolSize:&#123;&#125;"</span>,</span><br><span class="line">            tag, serverIp, threadNamePrefix, threadPoolExecutor.getCorePoolSize(),</span><br><span class="line">            threadPoolExecutor.getMaximumPoolSize(), threadPoolExecutor.getActiveCount(), queue.size(),</span><br><span class="line">            queue.size() + queue.remainingCapacity(), threadPoolExecutor.getTaskCount(),</span><br><span class="line">            threadPoolExecutor.getCompletedTaskCount(), threadPoolExecutor.getLargestPoolSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取服务器IP地址</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ip</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getIpAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;NetworkInterface&gt; allNetInterfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">            InetAddress ip;</span><br><span class="line">            <span class="keyword">while</span> (allNetInterfaces.hasMoreElements()) &#123;</span><br><span class="line">                NetworkInterface netInterface = allNetInterfaces.nextElement();</span><br><span class="line">                <span class="keyword">if</span> (netInterface.isLoopback() || netInterface.isVirtual() || !netInterface.isUp()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Enumeration&lt;InetAddress&gt; addresses = netInterface.getInetAddresses();</span><br><span class="line">                    <span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">                        ip = addresses.nextElement();</span><br><span class="line">                        <span class="keyword">if</span> (ip <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">                            <span class="keyword">return</span> ip.getHostAddress();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">"IP地址获取失败"</span> + e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、大厂版本"><a href="#二、大厂版本" class="headerlink" title="二、大厂版本"></a>二、大厂版本</h3><p><a href="https://hippo4j.cn/" target="_blank" rel="noopener">《hippo4j》</a><br><a href="https://dynamictp.cn/" target="_blank" rel="noopener">《美团 dynamictp》</a><br><a href="https://blog.csdn.net/m0_57334678/article/details/131466456" target="_blank" rel="noopener">《网友自定义简单版本线程池》</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>程序员遇到紧急生产事件，该怎么办?</title>
    <url>/post/d84e5a96.html</url>
    <content><![CDATA[<blockquote><p>程序员遇到紧急生产事件，该怎么办~</p></blockquote><a id="more"></a><blockquote class="pullquote mindmap mindmap-lg"><ul><li>方法论<ul><li>心态<ul><li>沉稳</li><li>冷静</li><li>淡定</li></ul></li><li>5WHY分析法<ul><li>精髓<ul><li>多问几次为什么，直至找到根本原因。</li></ul></li><li>步骤<ul><li>1 说明问题并描述相关信息</li><li>2 问为什么直到找出根本原因</li><li>3 制定对策并执行</li><li>4 执行后，验证有效性</li></ul></li></ul></li><li>排查思路与方法<ul><li>1 以具体发生问题的对象为切入点</li><li>2 列出问题出现的所有环节，并逐个检查<ul><li>1 画出问题相关联的流程图</li><li>2 查看依赖使用的中间件各类监控指标，CPU\内存\IO\网络\磁盘等<ul><li>a 关系型数据库</li><li>b 缓存型数据库</li><li>c 各种中间件，如：redis、kafka、zookeeper、mq等</li></ul></li></ul></li><li>3 列出与问题相关的怀疑点，并逐个排查</li><li>4 采用问题复现的方式，重现问题</li></ul></li><li>解决思路与方法<ul><li>事前</li><li>事中</li><li>事后</li></ul></li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>读写分离和分库分表</title>
    <url>/post/e60e6d3f.html</url>
    <content><![CDATA[<blockquote><p>ShardingSphere ~</p></blockquote><a id="more"></a><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h3 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h3><p><code>Apache ShardingSphere</code> 是一款分布式的数据库生态系统， 可以将任意数据库转换为分布式数据库，并通过数据分片、弹性伸缩、加密等能力对原有数据库进行增强。<code>ShardingSphere</code> 项目（包括 <code>Sharding-JDBC</code>、<code>Sharding-Proxy</code> 和 <code>Sharding-Sidecar</code>）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。<code>ShardingSphere</code> 绝对可以说是当前分库分表的首选！</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><code>ShardingSphere</code> 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理、影子库、数据加密和脱敏等功能。<code>ShardingSphere</code> 的优势如下（摘自 <a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">ShardingSphere官方文档</a>）</p><ul><li>极致性能：驱动程序端历经长年打磨，效率接近原生 <code>JDBC</code>，性能极致。</li><li>生态兼容：代理端支持任何通过 <code>MySQL/PostgreSQL</code> 协议的应用访问，驱动程序端可对接任意实现 <code>JDBC</code> 规范的数据库。</li><li>业务零侵入：面对数据库替换场景，<code>ShardingSphere</code> 可满足业务无需改造，实现平滑业务迁移。</li><li>运维低成本：在保留原技术栈不变前提下，对 DBA 学习、管理成本低，交互友好。</li><li>安全稳定：基于成熟数据库底座之上提供增量能力，兼顾安全性及稳定性。</li><li>弹性扩展：具备计算、存储平滑在线扩展能力，可满足业务多变的需求。</li><li>开放生态：通过多层次（内核、功能、生态）插件化能力，为用户提供可定制满足自身特殊需求的独有系统。</li></ul><p>另外，<code>ShardingSphere</code> 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在很多公司都是用的类似于 <code>TiDB</code> 这种分布式关系型数据库，不需要手动进行分库分表（数据库层面已经帮我们做了）。</p><p>也不需要解决手动分库分表引入的各种问题，直接一步到位，内置很多实用的功能（如无感扩容和缩容、冷热存储分离）。</p><p>如果公司条件允许的话，个人也是比较推荐这种方式！</p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><h4 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h4><p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p><ol><li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li><li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</li><li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li></ol><h4 id="实际落地"><a href="#实际落地" class="headerlink" title="实际落地"></a>实际落地</h4><h5 id="代理方式"><a href="#代理方式" class="headerlink" title="代理方式"></a>代理方式</h5><p>可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。提供类似功能的中间件有 <strong>MySQL Router</strong>（官方， MySQL Proxy 的替代方案）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>MaxScale</strong>、<strong>MyCat</strong>。</p><blockquote><p>关于 MySQL Router 多提一点：在 MySQL 8.2 的版本中，MySQL Router 能自动分辨对数据库读写/操作并把这些操作路由到正确的实例上。这是一项有价值的功能，可以优化数据库性能和可扩展性，而无需在应用程序中进行任何更改。具体介绍可以参考官方博客：<a href="https://blogs.oracle.com/mysql/post/mysql-82-transparent-readwrite-splitting" target="_blank" rel="noopener">MySQL 8.2 – transparent read/write splitting</a></p></blockquote><h5 id="组件方式"><a href="#组件方式" class="headerlink" title="组件方式"></a>组件方式</h5><p>通过引入第三方组件来帮助我们读写请求。这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。你可以在 shardingsphere 官方找到 <a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/" target="_blank" rel="noopener">sharding-jdbc 关于读写分离的操作</a>。</p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>MySql</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
</search>
